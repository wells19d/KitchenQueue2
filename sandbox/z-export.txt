

--- FILE: App.jsx ---

//*App.jsx
import React, {useEffect, useState} from 'react';
import {Provider} from 'react-redux';
import {store, persistor} from './store';
import {PersistGate} from 'redux-persist/integration/react';
import {GestureHandlerRootView} from 'react-native-gesture-handler';
import {
  StatusBar,
  View,
  Text,
  TextInput,
  PixelRatio,
  Platform,
  AccessibilityInfo,
} from 'react-native';
import SplashScreen from './src/components/SplashScreen';
import Toast from 'react-native-toast-message';
import toastConfig from './src/KQ-UI/KQToast';
import Main from './Main';
import {getAuth, onAuthStateChanged} from '@react-native-firebase/auth';
import {initializeApp, getApps} from '@react-native-firebase/app';
import {SafeAreaProvider} from 'react-native-safe-area-context';
import {kqconsole} from './src/utilities/helpers';

const App = () => {
  global.kqconsole = kqconsole;
  const [appReady, setAppReady] = useState(false);

  useEffect(() => {
    if (!getApps().length) {
      initializeApp();
    }

    const unsubscribe = onAuthStateChanged(getAuth(), () => {
      setAppReady(true);
    });

    return unsubscribe;
  }, []);

  const [isSplashVisible, setSplashVisible] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => setSplashVisible(false), 3000);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    if (Text.defaultProps == null) Text.defaultProps = {};
    if (TextInput.defaultProps == null) TextInput.defaultProps = {};

    Text.defaultProps.allowFontScaling = false;
    TextInput.defaultProps.allowFontScaling = false;

    if (Platform.OS === 'android') {
      PixelRatio.get = () => 1;
      PixelRatio.getFontScale = () => 1;
    }

    AccessibilityInfo.addEventListener('reduceMotionChanged', reduceMotion => {
      if (reduceMotion) {
        PixelRatio.get = () => 1;
        PixelRatio.getFontScale = () => 1;
      }
    });
  }, []);

  return (
    <Provider store={store}>
      <PersistGate loading={<SplashScreen />} persistor={persistor}>
        <GestureHandlerRootView style={{flex: 1}}>
          <SafeAreaProvider>
            <View style={{flex: 1, backgroundColor: '#fff'}}>
              <StatusBar barStyle="light-content" backgroundColor={'#29856c'} />
              <Main appReady={appReady} isSplashVisible={isSplashVisible} />
              <Toast config={toastConfig} />
            </View>
          </SafeAreaProvider>
        </GestureHandlerRootView>
      </PersistGate>
    </Provider>
  );
};

export default App;

/* 

Next Stable Trio
"react": "19.1.0",
"react-native": "0.79.0",
"@react-native-community/cli": "18.0.0"

*/


--- FILE: AppInfo.js ---

//* AppInfo.js
import {Platform} from 'react-native';
import version from './version.json';

const isIOS = Platform.OS === 'ios';
const isAndroid = Platform.OS === 'android';

export const AppInfo = {
  appName: 'Kitchen Queue',
  appleAppVersion: version.appleAppVersion,
  androidAppVersion: version.androidAppVersion,
  appleBuildVersion: version.appleBuildVersion,
  googleBuildVersion: version.googleBuildVersion,
  tosVersion: version.tosVersion,
  ppVersion: version.ppVersion,
  deviceAppVersion: isIOS ? version.appleAppVersion : version.androidAppVersion,
  deviceBuildVersion: isAndroid
    ? version.appleBuildVersion
    : version.googleBuildVersion,
};

// Build Versions: Apple and Google deployment version
// MAJOR.MINOR.PATCH
// MAJOR: Incremented for incompatible API changes -- yarn bump-major
// MINOR: Incremented for new features -- yarn bump-minor
// PATCH: Incremented for bug fixes -- yarn bump-patch
// ALPHA: Pre-release version (Closed Invitation)
// BETA: Pre-release version (Open Invitation)


--- FILE: Main.jsx ---

//* Main.jsx
import {NavigationContainer} from '@react-navigation/native';
import React, {useCallback, useEffect, useMemo, useRef, useState} from 'react';
import {
  Alert,
  Dimensions,
  Image,
  StatusBar,
  ActivityIndicator,
  Platform,
} from 'react-native';
import {SafeAreaView} from 'react-native-safe-area-context';
import {createNativeStackNavigator} from '@react-navigation/native-stack';
import NavMenu from './src/components/NavMenu';
import {useDispatch} from 'react-redux';
import {getNavMenuHeight} from './src/utilities/deviceUtils';
import Home from './src/screens/Home/Home';
import {
  useAccount,
  useAuth,
  useDeviceInfo,
  useProfile,
} from './src/hooks/useHooks';
import {setHapticFeedback} from './src/hooks/setHapticFeedback';
import Account from './src/screens/Account/Account';
import CupboardSingle from './src/screens/Cupboard/CupboardSingle';
import ShoppingList from './src/screens/Shopping/ShoppingList';
import CenterMenu from './src/screens/CenterMenu/CenterMenu';
import {BottomSheet, Button, Modal, Text, View} from './src/KQ-UI';
import DevInputs from './src/screens/Dev/DevInputs';
import DevButtons from './src/screens/Dev/DevButtons';
import DevDropdowns from './src/screens/Dev/DevDropdowns';
import DevPlayground from './src/screens/Dev/DevPlayground';
import DevModals from './src/screens/Dev/DevModals';
import DevText from './src/screens/Dev/DevText';
import {getAuth} from '@react-native-firebase/auth';
import {getApp} from '@react-native-firebase/app';
import Auth from './src/screens/Auth/Auth';
import {
  RTAccounts,
  RTProfiles,
  RTShopping,
  RTCupboards,
  RTUsers,
  RTAllowedProfiles,
  RTFavorites,
  RTRecipeBox,
} from './src/utilities/realtime';
import TermsService from './src/screens/Legal/TermsService';
import PrivacyPolicy from './src/screens/Legal/PrivacyPolicy';
import {AppInfo} from './AppInfo';
import {enableScreens} from 'react-native-screens';
import ShoppingCart from './src/screens/Shopping/ShoppingCart';
import CupboardGroup from './src/screens/Cupboard/CupboardGroup';
import ShoppingItems from './src/screens/Shopping/ShoppingItems';
import CupboardItems from './src/screens/Cupboard/CupboardItems';
import Settings from './src/screens/Account/Settings';
import Help from './src/screens/Account/Help';
import Profile from './src/screens/Account/Profile';
import Vibrations from './src/screens/Account/Vibrations';
import ItemDisplay from './src/screens/Account/ItemDisplay';
import Resets from './src/screens/Account/Resets';
import AccountSetup from './src/screens/Account/AccountSetup';
import FavoriteItems from './src/screens/Favorites/FavoriteItems';
import FavoritesList from './src/screens/Favorites/FavoritesList';
import RecipeSearch from './src/screens/Recipe/RecipeSearch';
import NavigationMode from 'react-native-navigation-mode';
import RecipeBox from './src/screens/Recipe/RecipeBox';
import AddRecipe from './src/screens/Recipe/AddRecipe';
import FastImage from 'react-native-fast-image';
import {useRequestPermissions} from './src/hooks/useRequestPermissions';
import AsyncStorage from '@react-native-async-storage/async-storage';
import EditRecipe from './src/screens/Recipe/EditRecipe';

const Main = props => {
  const {appReady, isSplashVisible} = props;

  const dispatch = useDispatch();
  const device = useDeviceInfo();
  const profile = useProfile();
  const account = useAccount();
  const useHaptics = setHapticFeedback();
  const Stack = createNativeStackNavigator();
  const isAuthenticated = useAuth();
  const [mode, setMode] = useState(null);

  const [headerColor, setHeaderColor] = useState('black');
  const [screenLocation, setScreenLocation] = useState('');
  const [bgColor, setBgColor] = useState('#ffffff');
  const [textColor, setTextColor] = useState('#373d43');
  const [isSheetOpen, setIsSheetOpen] = useState(false);
  const bottomHeight = getNavMenuHeight(device, mode);

  const [showPPModal, setShowPPModal] = useState(false);
  const [showTOSModal, setShowTOSModal] = useState(true);
  const [currentModal, setCurrentModal] = useState('');
  enableScreens(true);

  const [renderDisplay, setRenderDisplay] = useState('auth');

  // Request permissions (for camera and photos) on first launch
  const {requestPermissions} = useRequestPermissions(renderDisplay);
  const [showPermModal, setShowPermModal] = useState(false);

  useEffect(() => {
    const check = async () => {
      if (renderDisplay !== 'main') return;

      const alreadyShown = await AsyncStorage.getItem('permissionsModalShown');
      if (!alreadyShown) {
        setShowPermModal(true);
        await AsyncStorage.setItem('permissionsModalShown', 'true');
      }
    };
    check();
  }, [renderDisplay]);

  // checks navigation mode (gesture, buttons, etc) for android
  useEffect(() => {
    let isMounted = true;

    NavigationMode.getNavigationMode()
      .then(result => {
        if (isMounted) {
          setMode(result);
        }
      })
      .catch(err => {});

    return () => {
      isMounted = false;
    };
  }, []);

  // Step 1: Handle base state – app readiness and auth
  useEffect(() => {
    if (!appReady) {
      setRenderDisplay('logo');
      return;
    }

    if (!isAuthenticated) {
      setRenderDisplay('auth');
      return;
    }
  }, [appReady, isAuthenticated]);

  // Step 2: Wait until profile.account is fully resolved
  useEffect(() => {
    if (!appReady || !isAuthenticated) return;

    if (profile && 'account' in profile) {
      if (profile.account === null) {
        setRenderDisplay('accountSetup');
      } else {
        setRenderDisplay('main');
      }
    }
  }, [appReady, isAuthenticated, profile]);

  const RTEnabled = isAuthenticated && account !== null;
  RTAccounts(RTEnabled);
  RTUsers(RTEnabled);
  RTProfiles(RTEnabled);
  RTShopping(RTEnabled);
  RTCupboards(RTEnabled);
  RTAllowedProfiles(RTEnabled);
  RTFavorites(RTEnabled);
  RTRecipeBox(RTEnabled);

  useEffect(() => {
    try {
      const auth = getAuth(getApp());
      const user = auth.currentUser;

      if (user) {
        dispatch({type: 'SET_USER', payload: user});
      } else {
        dispatch({type: 'LOGOUT'});
      }
    } catch (e) {
      dispatch({type: 'LOGOUT'});
    }
  }, []);

  const borrowedParams = useMemo(
    () => ({bgColor, textColor, headerColor, screenLocation}),
    [bgColor, textColor, headerColor, screenLocation],
  );

  useEffect(() => {
    if (isAuthenticated && profile && account !== null) {
      if (!profile?.tosVersion || profile?.tosVersion !== AppInfo.tosVersion) {
        setCurrentModal('TOS');
        setShowTOSModal(true);
      } else if (
        !profile?.ppVersion ||
        profile?.ppVersion !== AppInfo.ppVersion
      ) {
        setCurrentModal('PP');
        setShowPPModal(true);
      }
    }
  }, [isAuthenticated, profile, account]);

  useEffect(() => {
    dispatch({type: 'FETCH_DEVICE_INFO'});

    const subscription = Dimensions.addEventListener('change', () => {
      dispatch({type: 'FETCH_DEVICE_INFO'});
    });

    return () => subscription?.remove();
  }, [dispatch]);

  const handlePPConfirm = () => {
    let updatedData = {
      ppVersion: AppInfo.ppVersion,
    };
    dispatch({
      type: 'UPDATE_PROFILE_REQUEST',
      payload: {userId: profile?.id, updatedData},
    });
    setShowPPModal(false);

    if (profile?.tosVersion !== AppInfo.tosVersion) {
      setCurrentModal('TOS');
      setShowTOSModal(true);
    }
  };

  const handleTOSConfirm = () => {
    let updatedData = {
      tosVersion: AppInfo.tosVersion,
    };
    dispatch({
      type: 'UPDATE_PROFILE_REQUEST',
      payload: {userId: profile?.id, updatedData},
    });
    setShowTOSModal(false);
    setCurrentModal('');
  };

  const handleCancel = type => {
    Alert.alert(
      `${type} Declined`,
      `Not accepting the ${type}, you will be logged out and prevented from using Kitchen Queue. Are you sure you want to decline?`,
      [
        {text: 'Back'},
        {
          text: 'Decline',
          style: 'destructive',
          onPress: () => {
            dispatch({type: 'LOGOUT'});
          },
        },
      ],
    );
  };

  const permissionLocation = () => {
    if (Platform.OS === 'ios') {
      return 'Settings → Apps → Kitchen Queue.';
    } else if (Platform.OS === 'android') {
      return 'Settings → Apps → Kitchen Queue → Permissions.';
    }
  };

  const toggleMenu = useCallback(() => {
    setIsSheetOpen(prev => !prev);
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
  }, [useHaptics]);

  const BottomMenu = () => (
    <BottomSheet
      visible={isSheetOpen}
      onClose={() => setIsSheetOpen(false)}
      snapPoints={[0.01, 0.95]}>
      <CenterMenu borrowedParams={borrowedParams} toggleMenu={toggleMenu} />
    </BottomSheet>
  );

  const Navigation = () => {
    return (
      <>
        <Stack.Navigator
          screenOptions={{
            animation: 'none',
            gestureEnabled: false,
            headerBackVisible: false,
            headerShown: false,
            navigationBarColor: '#f7f7f7',
          }}>
          <Stack.Screen
            name="Home"
            component={Home}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="ShoppingList"
            component={ShoppingList}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="ShoppingCart"
            component={ShoppingCart}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="ShoppingItems"
            component={ShoppingItems}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="CupboardList-Single"
            component={CupboardSingle}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="CupboardList-Group"
            component={CupboardGroup}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="CupboardItems"
            component={CupboardItems}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="FavoritesList"
            component={FavoritesList}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="FavoriteItems"
            component={FavoriteItems}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="RecipeSearch"
            component={RecipeSearch}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="AddRecipe"
            component={AddRecipe}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="EditRecipe"
            component={EditRecipe}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="RecipeBox"
            component={RecipeBox}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="Account"
            component={Account}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="AccountProfile"
            component={Profile}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="AccountSettings"
            component={Settings}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="AccountHelp"
            component={Help}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="Vibrations"
            component={Vibrations}
            options={{freezeOnBlur: true}}
          />
          <Stack.Screen
            name="ItemDisplay"
            component={ItemDisplay}
            options={{freezeOnBlur: true}}
          />
          {/* <Stack.Screen
            name="AdvancedFields"
            component={AdvancedFields}
            options={{ freezeOnBlur: true }} 
            
          /> */}
          {/* <Stack.Screen
            name="DefaultView"
            component={DefaultGroupView}
            options={{ freezeOnBlur: true }} 
          
          /> */}
          <Stack.Screen
            name="Resets"
            component={Resets}
            options={{freezeOnBlur: true}}
          />
          {/* <Stack.Screen
            name="Passwords"
            component={Passwords}
            options={{ freezeOnBlur: true }} 
        
          /> */}
          {__DEV__ && (
            <>
              <Stack.Screen
                name="DevPlayground"
                component={DevPlayground}
                options={{freezeOnBlur: true}}
              />
              <Stack.Screen
                name="DevText"
                component={DevText}
                options={{freezeOnBlur: true}}
              />
              <Stack.Screen
                name="DevInputs"
                component={DevInputs}
                options={{freezeOnBlur: true}}
              />
              <Stack.Screen
                name="DevButtons"
                component={DevButtons}
                options={{freezeOnBlur: true}}
              />
              <Stack.Screen
                name="DevModals"
                component={DevModals}
                options={{freezeOnBlur: true}}
              />
              <Stack.Screen
                name="DevDropdowns"
                component={DevDropdowns}
                options={{freezeOnBlur: true}}
              />
            </>
          )}
          <Stack.Screen name="Login" component={Auth} />
        </Stack.Navigator>
      </>
    );
  };

  if (renderDisplay === 'loading') {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: '#fff',
          justifyContent: 'center',
          alignItems: 'center',
        }}>
        <View style={{margin: 20}}>
          <ActivityIndicator size="large" color="#29856c" />
        </View>
        <Text size="medium" font="open-6">
          Just getting things ready...
        </Text>
      </View>
    );
  }

  if (renderDisplay === 'logo') {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: '#fff',
          justifyContent: 'center',
          alignItems: 'center',
        }}>
        <View style={{position: 'relative', top: 10}}>
          <Image source={require('./src/images/AppLogo_350.png')} />
        </View>
      </View>
    );
  }

  if (renderDisplay === 'auth') {
    return (
      <SafeAreaView style={{flex: 1, margin: 5}}>
        <Auth bgColor={bgColor} isSplashVisible={isSplashVisible} />
      </SafeAreaView>
    );
  }

  if (renderDisplay === 'main') {
    return (
      <NavigationContainer>
        <SafeAreaView
          style={{flex: 1, backgroundColor: '#29856c'}}
          edges={['top']}>
          <View style={{flex: 1}}>
            <Navigation />
            <BottomMenu toggleMenu={toggleMenu} />
          </View>
        </SafeAreaView>
        <SafeAreaView style={{height: bottomHeight}} edges={['bottom']}>
          <NavMenu
            bottomHeight={bottomHeight}
            bottomWidth={device?.dimensions?.width}
            toggleMenu={toggleMenu}
            setIsSheetOpen={setIsSheetOpen}
            device={device}
            navMode={mode}
          />
        </SafeAreaView>
        {currentModal === 'TOS' && (
          <Modal
            visible={showTOSModal}
            title="Terms of Service Update"
            fullScreen
            hideClose>
            <TermsService
              handleTOSConfirm={handleTOSConfirm}
              handleCancel={handleCancel}
            />
          </Modal>
        )}

        {currentModal === 'PP' && (
          <Modal
            visible={showPPModal}
            title="Privacy Policy Update"
            fullScreen
            hideClose>
            <PrivacyPolicy
              handlePPConfirm={handlePPConfirm}
              handleCancel={handleCancel}
            />
          </Modal>
        )}

        {showPermModal && (
          <Modal
            visible={showPermModal}
            onClose={() => setShowPermModal(false)}
            title="Permissions Required"
            headerFont="open-6"
            headerSize="small"
            height="50%"
            width="90%"
            // fullScreen
            hideClose>
            <View flex column>
              <View flex ph15 centerVH>
                <View mv10 ph10>
                  <Text size="medium" style={{marginBottom: 15}} centered>
                    Kitchen Queue needs access to your Camera and Photos to take
                    and upload images, as well as scan UPCs and recipes.
                  </Text>
                </View>
                <View mv10>
                  <Text centered italic>
                    You can update these permissions later in{' '}
                    {permissionLocation()}
                  </Text>
                </View>
              </View>
              <View mv25 ph15>
                <Button
                  onPress={async () => {
                    setShowPermModal(false);
                    await requestPermissions(); // triggers native system dialogs
                  }}>
                  Set Permissions
                </Button>
              </View>
            </View>
          </Modal>
        )}
      </NavigationContainer>
    );
  }

  if (renderDisplay === 'accountSetup') {
    return (
      <SafeAreaView style={{flex: 1, margin: 5}}>
        <StatusBar backgroundColor={bgColor} barStyle="light-content" />
        <AccountSetup />
      </SafeAreaView>
    );
  }
};

export default Main;


--- FILE: algolia_search/index.js ---

// algolia_search/index.js
const functions = require('firebase-functions');
const algoliasearch = require('algoliasearch');

let algoliaClient = null;

exports.searchRecipes = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  try {
    const algoliaConfig = functions.config().algolia;

    if (!algoliaConfig || !algoliaConfig.app_id || !algoliaConfig.api_key) {
      console.error(
        'Algolia configuration missing! Run: firebase functions:config:set algolia.app_id="..." algolia.api_key="..."',
      );
      return res.status(500).json({
        error: 'Server configuration error: Algolia credentials are not set.',
      });
    }

    const ALGOLIA_APP_ID = algoliaConfig.app_id;
    const ALGOLIA_API_KEY = algoliaConfig.api_key;

    // Initialize Algolia client only once per cold start
    if (!algoliaClient) {
      algoliaClient = algoliasearch(ALGOLIA_APP_ID, ALGOLIA_API_KEY);
    }
    const index = algoliaClient.initIndex('community_recipes');

    const {query} = req.query;
    if (!query) {
      return res.status(400).json({
        // Changed to .json() and added return
        error:
          'Missing query parameter. Please provide a "query" like /searchRecipes?query=...',
      });
    }

    // Perform the search in Algolia
    const {hits} = await index.search(query, {
      hitsPerPage: 20,
    });

    res.status(200).json(hits); // Changed to .json()
  } catch (error) {
    console.error('Algolia search error:', error);
    return res.status(500).json({
      // Changed to .json() and added return
      error: 'An error occurred during the search. Please try again later.',
    });
  }
});

//firebase deploy --only functions:algolia_search


--- FILE: algolia_search/package.json ---

{
  "name": "functions",
  "description": "Cloud Functions for Firebase",
  "scripts": {
    "serve": "firebase emulators:start --only functions:algolia_search",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions:algolia_search",
    "logs": "firebase functions:log",
    "clean-algolia": "rm -rf node_modules && yarn cache clean && yarn install"
  },
  "engines": {
    "node": "20"
  },
  "main": "index.js",
  "dependencies": {
    "algoliasearch": "^4.25.0",
    "firebase-admin": "^13.4.0",
    "firebase-functions": "^6.3.2"
  },
  "devDependencies": {
    "firebase-functions-test": "^3.1.0"
  },
  "private": true
}


--- FILE: app.json ---

{
  "name": "KitchenQueue",
  "displayName": "Kitchen Queue"
}


--- FILE: babel.config.js ---

//* bable.config.js
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: ['react-native-reanimated/plugin'],
};


--- FILE: barcodeSpiderSamples.json ---

[
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Hunts No Salt Sauce 15 oz",
      "upc": "027000852507",
      "ean": "0027000852507",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Hunt's",
      "model": "85250",
      "mpn": "212-22-0260",
      "manufacturer": "hunts",
      "publisher": "hunts",
      "asin": "B00ND797TC",
      "color": "",
      "size": "",
      "weight": "",
      "image": "https://images.barcodespider.com/upcimage/027000852507.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Hunts No Salt Sauce 15 oz",
        "image": "https://images-na.ssl-images-amazon.com/images/I/51VRdnq3nLL.jpg",
        "price": "6.99",
        "currency": "USD",
        "link": "https://www.barcodespider.com/getstore/MDI3MDAwODUyNTA3fEFtYXpvbiBVUw,,",
        "updated": "2019-06-14 23:06"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": false,
      "correct": false
    },
    "item_attributes": {
      "title": "Chopped Stainless Steel Tri-Ply 3pc Nonstick Champion Pan",
      "upc": "051000000118",
      "ean": "0051000000118",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "",
      "model": "",
      "mpn": "",
      "manufacturer": "",
      "publisher": "",
      "asin": "B002FA339I",
      "color": "",
      "size": "",
      "weight": "",
      "image": "https://images.barcodespider.com/upcimage/051000000118.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Chopped Stainless Steel Tri-Ply 3pc Nonstick Champion Pan",
        "image": "https://images-na.ssl-images-amazon.com/images/I/51Utsr%2BbtnL.jpg",
        "price": "",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/MDUxMDAwMDAwMTE4fEFtYXpvbiBVUw,,",
        "updated": "2019-06-14 17:28:43"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Pam Cooking Spray Original",
      "upc": "064144030217",
      "ean": "0064144030217",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Pam GM Concepts",
      "model": "6414403021",
      "mpn": "I00042063",
      "manufacturer": "Pam",
      "publisher": "Pam",
      "asin": "B0001CLG7S",
      "color": "",
      "size": "6 oz",
      "weight": "53 hundredths-pounds",
      "image": "https://images.barcodespider.com/upcimage/064144030217.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Pam Cooking Spray Original",
        "image": "https://images-na.ssl-images-amazon.com/images/I/31OYqvGkTOL.jpg",
        "price": "7.01",
        "currency": "USD",
        "link": "https://www.barcodespider.com/getstore/MDY0MTQ0MDMwMjE3fEFtYXpvbiBVUw,,",
        "updated": "2019-06-12 04:48:44"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Pompeian Smooth Extra Virgin Olive Oil, 32 Ounce",
      "upc": "070404002801",
      "ean": "0070404002801",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Pompeian",
      "model": "110136",
      "mpn": "070404002801",
      "manufacturer": "Pompeian, Inc.",
      "publisher": "Pompeian, Inc.",
      "asin": "B015LZCIY4",
      "color": "",
      "size": "32 Ounce",
      "weight": "200 hundredths-pounds",
      "image": "https://images.barcodespider.com/upcimage/070404002801.jpg",
      "is_adult": "2",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Pompeian Smooth Extra Virgin Olive Oil, 32 Ounce",
        "image": "https://images-na.ssl-images-amazon.com/images/I/41qDxHzFH%2BL.jpg",
        "price": "8.98",
        "currency": "USD",
        "link": "https://www.barcodespider.com/getstore/MDcwNDA0MDAyODAxfEFtYXpvbiBVUw,,",
        "updated": "2019-06-21 15:45:35"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Dunkin' Donuts Hazelnut Ground Coffee 12 OZ (Pack of 12)",
      "upc": "881334000498",
      "ean": "0881334000498",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Dunkin' Donuts",
      "model": "",
      "mpn": "881334000498",
      "manufacturer": "Dunkin' Donuts",
      "publisher": "Dunkin' Donuts",
      "asin": "B00KO8N1XQ",
      "color": "",
      "size": "12  Ounces",
      "weight": "900 hundredths-pounds",
      "image": "https://images.barcodespider.com/upcimage/881334000498.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Dunkin' Donuts Hazelnut Ground Coffee 12 OZ (Pack of 12)",
        "image": "https://images-na.ssl-images-amazon.com/images/I/41bIbG82OmL.jpg",
        "price": "92.67",
        "currency": "USD",
        "link": "https://www.barcodespider.com/getstore/ODgxMzM0MDAwNDk4fEFtYXpvbiBVUw,,",
        "updated": "2019-06-14 16:04:32"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "SWANSON CHICKEN BROTH 33% LESS SODIUM 32oz 3pack",
      "upc": "051000132796",
      "ean": "0051000132796",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Swanson",
      "model": "",
      "mpn": "826568",
      "manufacturer": "CAMPBELL'S SOUP COMPANY",
      "publisher": "CAMPBELL'S SOUP COMPANY",
      "asin": "B005PWAXJ6",
      "color": "",
      "size": "",
      "weight": "200 hundredths-pounds",
      "image": "https://images.barcodespider.com/upcimage/051000132796.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "SWANSON CHICKEN BROTH 33% LESS SODIUM 32oz 3pack",
        "image": "https://images-na.ssl-images-amazon.com/images/I/514zn3sK-WL.jpg",
        "price": "23.19",
        "currency": "USD",
        "link": "https://www.barcodespider.com/getstore/MDUxMDAwMTMyNzk2fEFtYXpvbiBVUw,,",
        "updated": "2019-06-13 07:34:13"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Creamette Elbow Macaroni, 32-Ounce",
      "upc": "015100000119",
      "ean": "0015100000119",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Riviana Foods Inc (Amazon Fresh)",
      "model": "902621SU",
      "mpn": "",
      "manufacturer": "RIVIANA FOODS INC.",
      "publisher": "RIVIANA FOODS INC.",
      "asin": "B01K4ORNNS",
      "color": "",
      "size": "",
      "weight": "200 hundredths-pounds",
      "image": "https://images.barcodespider.com/upcimage/015100000119.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Creamette Elbow Macaroni, 32-Ounce",
        "image": "https://images-na.ssl-images-amazon.com/images/I/51%2BXdXtIAxL.jpg",
        "price": "",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/MDE1MTAwMDAwMTE5fEFtYXpvbiBVUw,,",
        "updated": "2019-06-12 00:50:04"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": false,
      "correct": false
    },
    "item_attributes": {
      "title": "Rice a Roni Rice Mix, Broccoli au Gratin, 6.5 Oz",
      "upc": "015300430242",
      "ean": "0015300430242",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Rice-A-Roni",
      "model": "015300430242",
      "mpn": "VAIO PCG-8K1L",
      "manufacturer": "Rice a Roni",
      "publisher": "Rice a Roni",
      "asin": "B002DU0XMK",
      "color": "",
      "size": "",
      "weight": "184 grams",
      "image": "https://images.barcodespider.com/upcimage/015300430242.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Rice a Roni Rice Mix, Broccoli au Gratin, 6.5 Oz",
        "image": "https://images-na.ssl-images-amazon.com/images/I/21cM4cMXqpL.jpg",
        "price": "",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/MDE1MzAwNDMwMjQyfEFtYXpvbiBVUw,,",
        "updated": "2019-06-21 06:35:45"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Butter Kernel Cut Green Beans No Salt Added-14.5 oz.",
      "upc": "072273492783",
      "ean": "0072273492783",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Butter Kernel",
      "model": "",
      "mpn": "",
      "manufacturer": "Butter Kernel",
      "publisher": "Butter Kernel",
      "asin": "B007HO8QRQ",
      "color": "",
      "size": "",
      "weight": "",
      "image": "https://images.barcodespider.com/upcimage/072273492783.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Butter Kernel Cut Green Beans No Salt Added-14.5 oz.",
        "image": "https://images-na.ssl-images-amazon.com/images/I/41jvtgDSRuL.jpg",
        "price": "",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/MDcyMjczNDkyNzgzfEFtYXpvbiBVUw,,",
        "updated": "2019-07-06 07:52"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": false
    },
    "item_attributes": {
      "title": "TAKE YOUR TIME",
      "upc": "705814727210",
      "ean": "0705814727210",
      "parent_category": "Media",
      "category": "Music & Sound Recordings",
      "brand": "",
      "model": "",
      "mpn": "",
      "manufacturer": "",
      "publisher": "",
      "asin": "B0007D90R4",
      "color": "",
      "size": "",
      "weight": "",
      "image": "https://images.barcodespider.com/upcimage/705814727210.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "TAKE YOUR TIME",
        "image": "https://images-na.ssl-images-amazon.com/images/I/51NUeRvyirL.jpg",
        "price": "",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/NzA1ODE0NzI3MjEwfEFtYXpvbiBVUw,,",
        "updated": "2019-09-11 23:22:03"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Hunt's Petite Diced Tomatoes, 14.5 oz",
      "upc": "027000378311",
      "ean": "0027000378311",
      "parent_category": "Home & Garden",
      "category": "Kitchen & Dining",
      "brand": "Hunt's",
      "model": "",
      "mpn": "",
      "manufacturer": "ConAgra Foods Sales, Inc.",
      "publisher": "ConAgra Foods Sales, Inc.",
      "asin": "B015Z830KS",
      "color": "",
      "size": "",
      "weight": "91 hundredths-pounds",
      "image": "https://images.barcodespider.com/upcimage/027000378311.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Hunt's Petite Diced Tomatoes, 14.5 oz",
        "image": "https://images-na.ssl-images-amazon.com/images/I/513wZ-OMedL.jpg",
        "price": "6.16",
        "currency": "USD",
        "link": "https://www.barcodespider.com/getstore/MDI3MDAwMzc4MzExfEFtYXpvbiBVUw,,",
        "updated": "2019-06-14 22:59"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Hungry Jack Complete Buttermilk Pancake Mix and Waffle Mix  32 oz",
      "upc": "013300280645",
      "ean": "0013300280645",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Waffle & Pancake Mixes",
      "brand": "Hungry Jack",
      "model": "14636636",
      "mpn": "",
      "manufacturer": "Hungry Jack",
      "publisher": "Hungry Jack",
      "asin": "",
      "color": "Blue",
      "size": "",
      "weight": "3.18",
      "image": "https://images.barcodespider.com/upcimage/013300280645.jpg",
      "is_adult": "0",
      "description": "",
      "lowest_price": "2.19",
      "highest_price": "9.42"
    },
    "Stores": [
      {
        "store_name": "target.com",
        "title": "Hungry Jack Complete Buttermilk Pancake Mix and Waffle Mix  32 oz",
        "image": "https://i5.walmartimages.com/asr/9d80dd32-240b-43ec-83d0-150bd4b7174a.54860399f4cbdcafdd3e8c16550176c9.jpeg?odnHeight=450&odnWidth=450&odnBg=ffffff",
        "price": "2.19",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/MDEzMzAwMjgwNjQ1fHRhcmdldC5jb20,",
        "updated": "2020-08-07 03:24:18"
      },
      {
        "store_name": "unbeatablesale.com",
        "title": "Hungry Jack Complete Buttermilk Pancake Mix and Waffle Mix  32 oz",
        "image": "https://i5.walmartimages.com/asr/9d80dd32-240b-43ec-83d0-150bd4b7174a.54860399f4cbdcafdd3e8c16550176c9.jpeg?odnHeight=450&odnWidth=450&odnBg=ffffff",
        "price": "9.42",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/MDEzMzAwMjgwNjQ1fHVuYmVhdGFibGVzYWxlLmNvbQ,,",
        "updated": "2021-03-28 05:36:52"
      },
      {
        "store_name": "walmart.com",
        "title": "Hungry Jack Complete Buttermilk Pancake Mix and Waffle Mix  32 oz",
        "image": "https://i5.walmartimages.com/asr/9d80dd32-240b-43ec-83d0-150bd4b7174a.54860399f4cbdcafdd3e8c16550176c9.jpeg?odnHeight=450&odnWidth=450&odnBg=ffffff",
        "price": "2.77",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/MDEzMzAwMjgwNjQ1fHdhbG1hcnQuY29t",
        "updated": "2023-12-08 05:11:25"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": false,
      "correct": true
    },
    "item_attributes": {
      "title": "Creamette Angel Hair, 16-Ounce",
      "upc": "015100001673",
      "ean": "0015100001673",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "CREAMETTE",
      "model": "900078SU",
      "mpn": "15100-00167",
      "manufacturer": "Creamette",
      "publisher": "Creamette",
      "asin": "B00CHTUZ0M",
      "color": "",
      "size": "16 Ounce",
      "weight": "100 hundredths-pounds",
      "image": "https://images.barcodespider.com/upcimage/015100001673.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Creamette Angel Hair, 16-Ounce",
        "image": "https://images-na.ssl-images-amazon.com/images/I/11vv9ZhrsJL.jpg",
        "price": "68.62",
        "currency": "USD",
        "link": "https://www.barcodespider.com/getstore/MDE1MTAwMDAxNjczfEFtYXpvbiBVUw,,",
        "updated": "2019-06-13 20:08"
      }
    ]
  },
  {
    "upc": "017400118358",
    "title": "not found",
    "aka": "minute rice",
    "imagesAcceptable": false,
    "correct": false
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Hidden Valley Ranch Salad Dressing Salad Mix - 6 Pack",
      "upc": "071100200058",
      "ean": "0071100200058",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Hidden Valley",
      "model": "",
      "mpn": "",
      "manufacturer": "",
      "publisher": "",
      "asin": "B003G9L1TQ",
      "color": "",
      "size": "",
      "weight": "",
      "image": "https://images.barcodespider.com/upcimage/071100200058.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Hidden Valley Ranch Salad Dressing Salad Mix - 6 Pack",
        "image": "https://images-na.ssl-images-amazon.com/images/I/511NPmGIfnL.jpg",
        "price": "46.65",
        "currency": "USD",
        "link": "https://www.barcodespider.com/getstore/MDcxMTAwMjAwMDU4fEFtYXpvbiBVUw,,",
        "updated": "2019-06-18 17:02:42"
      }
    ]
  },
  {
    "item_response": {
      "code": 200,
      "status": "OK",
      "message": "Data returned",
      "imagesAcceptable": true,
      "correct": true
    },
    "item_attributes": {
      "title": "Old El Paso Stan 'N Stuff Soft Flour Tortillas - Pack of 3 (6.7oz Each Box) - Product of Mexico",
      "upc": "046000431512",
      "ean": "0046000431512",
      "parent_category": "Food, Beverages & Tobacco",
      "category": "Food Items",
      "brand": "Old El Paso",
      "model": "",
      "mpn": "",
      "manufacturer": "",
      "publisher": "",
      "asin": "B015U4HPQM",
      "color": "",
      "size": "",
      "weight": "",
      "image": "https://images.barcodespider.com/upcimage/046000431512.jpg",
      "is_adult": "0",
      "description": ""
    },
    "Stores": [
      {
        "store_name": "Amazon US",
        "title": "Old El Paso Stan 'N Stuff Soft Flour Tortillas - Pack of 3 (6.7oz Each Box) - Product of Mexico",
        "image": "https://images-na.ssl-images-amazon.com/images/I/41S2iZ5eprL.jpg",
        "price": "",
        "currency": "",
        "link": "https://www.barcodespider.com/getstore/MDQ2MDAwNDMxNTEyfEFtYXpvbiBVUw,,",
        "updated": "2019-06-12 06:32:07"
      }
    ]
  }
]


--- FILE: bumpVersion.js ---

const fs = require('fs');
const path = require('path');

// --- Helpers ---

function bumpVersion(version, type = 'patch') {
  const [major, minor, patchWithTag] = version.split('.');
  const patch = patchWithTag.split('-')[0];
  const tag = patchWithTag.includes('-')
    ? '-' + patchWithTag.split('-')[1]
    : '';

  let newMajor = parseInt(major, 10);
  let newMinor = parseInt(minor, 10);
  let newPatch = parseInt(patch, 10);

  if (type === 'major') {
    newMajor++;
    newMinor = 0;
    newPatch = 0;
  } else if (type === 'minor') {
    newMinor++;
    newPatch = 0;
  } else {
    newPatch++;
  }

  return `${newMajor}.${newMinor}.${newPatch}${tag}`;
}

function syncNative(versionData) {
  const infoPlistPath = path.resolve(
    __dirname,
    'ios',
    'KitchenQueue',
    'Info.plist',
  );
  const buildGradlePath = path.resolve(
    __dirname,
    'android',
    'app',
    'build.gradle',
  );

  // --- Update Info.plist ---
  let infoPlist = fs.readFileSync(infoPlistPath, 'utf8');

  infoPlist = infoPlist.replace(
    /<key>CFBundleVersion<\/key>\s*<string>.*?<\/string>/,
    `<key>CFBundleVersion</key>\n\t<string>${versionData.appleBuildVersion}</string>`,
  );

  infoPlist = infoPlist.replace(
    /<key>CFBundleShortVersionString<\/key>\s*<string>.*?<\/string>/,
    `<key>CFBundleShortVersionString</key>\n\t<string>${versionData.appleAppVersion}</string>`,
  );

  fs.writeFileSync(infoPlistPath, infoPlist, 'utf8');

  // --- Update build.gradle ---
  let buildGradle = fs.readFileSync(buildGradlePath, 'utf8');

  buildGradle = buildGradle.replace(
    /versionCode\s+\d+/,
    `versionCode ${versionData.googleBuildVersion}`,
  );

  buildGradle = buildGradle.replace(
    /versionName\s+["'][^"']*["']/,
    `versionName "${versionData.androidAppVersion}"`,
  );

  fs.writeFileSync(buildGradlePath, buildGradle, 'utf8');
}

// --- Main Execution ---

const bumpTarget = process.argv[2]; // apple, android, global
const bumpType = process.argv[3] || 'patch'; // patch, minor, major

const validTargets = ['apple', 'android', 'global'];
const validTypes = ['patch', 'minor', 'major'];

if (!validTargets.includes(bumpTarget) || !validTypes.includes(bumpType)) {
  console.error(
    `Usage: node bumpVersion.js [apple|android|global] [patch|minor|major]`,
  );
  process.exit(1);
}

// Load version.json
const versionPath = path.resolve(__dirname, 'version.json');
const versionData = JSON.parse(fs.readFileSync(versionPath, 'utf8'));

// Bump selected
if (bumpTarget === 'apple') {
  const oldVersion = versionData.appleAppVersion;
  versionData.appleAppVersion = bumpVersion(oldVersion, bumpType);
  versionData.appleBuildVersion++;
} else if (bumpTarget === 'android') {
  const oldVersion = versionData.androidAppVersion;
  versionData.androidAppVersion = bumpVersion(oldVersion, bumpType);
  versionData.googleBuildVersion++;
} else if (bumpTarget === 'global') {
  const oldApple = versionData.appleAppVersion;
  const oldAndroid = versionData.androidAppVersion;
  versionData.appleAppVersion = bumpVersion(oldApple, bumpType);
  versionData.androidAppVersion = bumpVersion(oldAndroid, bumpType);
  versionData.appleBuildVersion++;
  versionData.googleBuildVersion++;
}

// Save updated version.json
fs.writeFileSync(versionPath, JSON.stringify(versionData, null, 2), 'utf8');

// Sync to native files
syncNative(versionData);


--- FILE: desiredSamples.js ---

let samples = [
  {
    foodID: '2695621', // from fatSecret food_id
    ean: '0051000000118', // from spider ean
    upc: '051000000118', // from spider upc
    itemName: 'Tomato Soup', // from fatSecret food_name
    brandName: `Campbell's`, // from fatSecret brand_name
    packageSize: 10.75, // extracted from mapped over data on spider
    measurement: 'oz', // extracted from mapped over data on spider
    images: [], // images will be mapped over from what we get from the stores, if none, we'll take the default image from spider's image.
    servings: {
      serving: [
        {
          serving_id: '2628971',
          serving_description: '1 can',
          serving_url:
            'https://foods.fatsecret.com/calories-nutrition/campbells/tomato-soup/1-can',
          metric_serving_amount: '305.000',
          metric_serving_unit: 'g',
          number_of_units: '1.000',
          measurement_description: 'serving',
          calories: '225',
          carbohydrate: '50.00',
          protein: '5.00',
          fat: '0',
          sodium: '1440',
          potassium: '1450',
          fiber: '5.0',
          sugar: '30.00',
          added_sugars: '20.00',
          vitamin_c: '23.0',
          iron: '1.25',
        },
      ],
    }, // from fatSecret servings || serving // probably just serving to remove the un-needed nesting
  },
];


--- FILE: firebase.config.js ---

// firebase.config.js
import {getApp} from '@react-native-firebase/app';
import {
  getRemoteConfig,
  getValue,
  setDefaults,
} from '@react-native-firebase/remote-config';

export const fetchRemoteKeys = async () => {
  const app = getApp();
  const config = getRemoteConfig(app);

  await setDefaults(config, {
    EDAMAM_FOOD_ID: '',
    EDAMAM_FOOD_KEY: '',
    ALGOLIA_APP_ID: '',
    ALGOLIA_APP_SEARCH_KEY: '',
  });

  await config.fetch(0);
  await config.activate();

  return {
    food: {
      appId: getValue(config, 'EDAMAM_FOOD_ID').asString(),
      appKey: getValue(config, 'EDAMAM_FOOD_KEY').asString(),
    },
    algolia: {
      appID: getValue(config, 'ALGOLIA_APP_ID').asString(),
      searchKey: getValue(config, 'ALGOLIA_APP_SEARCH_KEY').asString(),
      writeKey: getValue(config, 'ALGOLIA_APP_WRITE_KEY').asString(),
      monitorKey: getValue(config, 'ALGOLIA_API_MONITORING_KEY').asString(),
      usagekey: getValue(config, 'ALGOLIA_API_USAGE_KEY').asString(),
      adminKey: getValue(config, 'ALGOLIA_APP_ADMIN_KEY').asString(),
    },
  };
};


--- FILE: firebase.json ---

{
  "functions": [
    {
      "source": "algolia_search",
      "codebase": "algolia_search",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ]
    },
    {
      "source": "reset_daily_usage",
      "codebase": "reset_daily_usage",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ]
    },
    {
      "source": "node_mailer",
      "codebase": "node_mailer",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ]
    }
  ]
}


--- FILE: index.js ---

//*index.js
globalThis.RNFB_SILENCE_MODULAR_DEPRECATION_WARNINGS = true;
import {AppRegistry, LogBox} from 'react-native';
import App from './App';
import {name as appName} from './app.json';

LogBox.ignoreAllLogs(true);

AppRegistry.registerComponent(appName, () => App);


--- FILE: jest.config.js ---

//* jest.config.js
module.exports = {
  preset: 'react-native',
};


--- FILE: metro.config.js ---

const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');
const path = require('path');

const config = {
  server: {
    enhanceMiddleware: middleware => {
      return (req, res, next) => {
        if (req.url.startsWith('/debugger-ui')) {
          res.writeHead(404);
          res.end();
          return;
        }
        return middleware(req, res, next);
      };
    },
  },
  resolver: {
    extraNodeModules: {
      react: path.resolve(__dirname, 'node_modules/react'),
    },
  },
};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);


--- FILE: node_mailer/index.js ---

// functions/index.js - For node mailer
const {initializeApp} = require('firebase-admin/app');
const {onDocumentCreated} = require('firebase-functions/v2/firestore');
const {logger} = require('firebase-functions');
const nodemailer = require('nodemailer');
const {defineSecret} = require('firebase-functions/params');

initializeApp();

const EMAIL_LOGIN = 'admin@kitchen-queue.com';
const EMAIL_USER = 'noreply@kitchen-queue.com'; // use noreply now for invites too?
const EMAIL_PASS = defineSecret('SMTP_EMAIL_PASSWORD');

exports.sendInviteEmail = onDocumentCreated(
  {
    document: 'accountInvites/{inviteCode}',
    region: 'us-central1',
    secrets: [EMAIL_PASS],
  },
  async event => {
    const data = event.data?.data();
    if (!data) {
      logger.warn('📭 No data found in the document snapshot.');
      return;
    }

    const transporter = nodemailer.createTransport({
      host: 'smtp.gmail.com',
      port: 465,
      secure: true,
      auth: {
        user: EMAIL_LOGIN, // must be admin@
        pass: EMAIL_PASS.value(), // App Password
      },
    });

    const recipientEmail = data.email;
    const inviterName = `${data.fromFirst} ${data.fromLast}`;

    const mailOptions = {
      from: `Kitchen Queue <${EMAIL_USER}>`, // this is the "visible" from
      to: recipientEmail,
      subject: 'You’ve been invited to join a Kitchen Queue account',
      text: `
Hello!

${inviterName} has invited you to join their Kitchen Queue account.

To get started, download the app, create a user/profile. After verification, log in and select "Join an Account" and use the 6-digit code below:

Invite Code: ${data.inviteCode}

This code will expire after 7 days.

Thanks,  
The Kitchen Queue Team
      `.trim(),
    };

    try {
      await transporter.sendMail(mailOptions);
      logger.info(`✉️ Email successfully sent to ${recipientEmail}`);
    } catch (error) {
      logger.error('❌ Failed to send invite email:', error);
    }
  },
);


--- FILE: node_mailer/package.json ---

{
  "name": "node_mailer",
  "description": "Custom mailer functions for Kitchen Queue",
  "main": "index.js",
  "engines": {
    "node": "20"
  },
  "dependencies": {
    "firebase-admin": "^12.6.0",
    "firebase-functions": "^6.3.2",
    "nodemailer": "^7.0.3"
  },
  "devDependencies": {
    "firebase-functions-test": "^3.1.0"
  },
  "private": true
}


--- FILE: package.json ---

{
  "name": "kitchen-queue",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "android": "react-native run-android",
    "ios": "react-native run-ios",
    "lint": "eslint .",
    "start": "react-native start",
    "start-clean": "react-native start --reset-cache",
    "pod-clean": "cd ios && rm -rf Pods Podfile.lock && pod install --repo-update && cd ..",
    "gradle-clean": "cd android && ./gradlew clean && cd ..",
    "clean-project": "rm -rf node_modules && yarn cache clean && yarn install && yarn pod-clean && yarn gradle-clean",
    "clean-project-hard": "rm -rf node_modules yarn.lock && yarn cache clean && yarn install && yarn pod-clean && yarn gradle-clean",
    "clean-and-start": "rm -rf node_modules && yarn cache clean && yarn install && yarn pod-clean && yarn gradle-clean && yarn start-clean",
    "connect-android": "adb -s RFCNB01E5GA reverse tcp:8081 tcp:8081 && yarn open-studio",
    "sync-version": "node syncVersion.js",
    "apple-patch++": "node bumpVersion.js apple patch",
    "apple-minor++": "node bumpVersion.js apple minor",
    "apple-major++": "node bumpVersion.js apple major",
    "android-patch++": "node bumpVersion.js android patch",
    "android-minor++": "node bumpVersion.js android minor",
    "android-major++": "node bumpVersion.js android major",
    "global-patch++": "node bumpVersion.js global patch",
    "global-minor++": "node bumpVersion.js global minor",
    "global-major++": "node bumpVersion.js global major",
    "open-studio": "open -a 'Android Studio'",
    "export-project": "node exportComponents.js",
    "test": "jest"
  },
  "dependencies": {
    "@dicebear/collection": "9.2.4",
    "@dicebear/core": "9.2.4",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-camera-roll/camera-roll": "7.10.2",
    "@react-native-clipboard/clipboard": "1.16.3",
    "@react-native-firebase/analytics": "23.4.0",
    "@react-native-firebase/app": "23.4.0",
    "@react-native-firebase/auth": "23.4.0",
    "@react-native-firebase/firestore": "23.4.0",
    "@react-native-firebase/remote-config": "23.4.0",
    "@react-native-firebase/storage": "23.4.0",
    "@react-navigation/native": "7.1.18",
    "@react-navigation/native-stack": "7.3.27",
    "@shopify/flash-list": "1.8.3",
    "algoliasearch": "4.25.2",
    "firebase-admin": "13.5.0",
    "firebase-functions": "6.5.0",
    "moment": "2.30.1",
    "pluralize": "8.0.0",
    "react": "19.0.0",
    "react-native": "0.78.2",
    "react-native-config": "1.5.9",
    "react-native-device-info": "14.1.1",
    "react-native-fast-image": "8.6.3",
    "react-native-fs": "2.20.0",
    "react-native-gesture-handler": "2.28.0",
    "react-native-haptic-feedback": "2.3.3",
    "react-native-image-crop-picker": "0.51.0",
    "react-native-navigation-mode": "1.2.3",
    "react-native-permissions": "5.4.2",
    "react-native-reanimated": "3.18.0",
    "react-native-safe-area-context": "5.6.1",
    "react-native-screens": "4.16.0",
    "react-native-svg": "15.14.0",
    "react-native-toast-message": "2.3.3",
    "react-native-uuid": "2.0.3",
    "react-native-vector-icons": "10.3.0",
    "react-native-vision-camera": "4.7.2",
    "react-redux": "9.2.0",
    "redux": "5.0.1",
    "redux-persist": "6.0.0",
    "redux-saga": "1.3.0"
  },
  "devDependencies": {
    "@babel/core": "7.28.4",
    "@babel/helpers": "7.28.4",
    "@babel/runtime": "7.28.4",
    "@react-native-community/cli": "15.1.3",
    "@react-native-community/cli-platform-android": "15.1.3",
    "@react-native-community/cli-platform-ios": "15.1.3",
    "@react-native/babel-preset": "0.78.2",
    "@react-native/eslint-config": "0.78.2",
    "@react-native/metro-config": "0.78.2",
    "@react-native/typescript-config": "0.78.2"
  },
  "resolutions": {
    "@babel/runtime": "7.28.4",
    "@babel/helpers": "7.28.4",
    "react": "19.0.0",
    "image-size": "1.2.1"
  },
  "engines": {
    "node": ">=18"
  }
}


--- FILE: react-native.config.js ---

//* react-native.config.js
module.exports = {
  project: {
    ios: {},
    android: {},
  },
  assets: ['./src/fonts'],
  dependencies: {
    'react-native-vector-icons': {
      platforms: {
        android: null, // 👈 Tells autolink to ignore it for Android native builds
      },
    },
  },
};


--- FILE: reset_daily_usage/index.js ---

//* reset_daily_usage/index.js
const {initializeApp} = require('firebase-admin/app');
const {getFirestore} = require('firebase-admin/firestore');
const {onSchedule} = require('firebase-functions/v2/scheduler');
const {logger} = require('firebase-functions');

initializeApp();
const db = getFirestore();

exports.resetDailyUsage = onSchedule(
  {
    schedule: 'every day 00:00',
    region: 'us-central1',
    timeZone: 'America/Los_Angeles', // Pacific Time to match Firebase reset
  },
  async () => {
    try {
      const snapshot = await db.collection('accounts').get();
      const batch = db.batch();

      snapshot.forEach(doc => {
        const ref = doc.ref;
        batch.update(ref, {
          dailyRecipeCounter: 0,
          dailyUPCCounter: 0,
        });
      });

      await batch.commit();
      logger.info(`✅ Reset daily counters for ${snapshot.size} accounts`);
    } catch (error) {
      logger.error('❌ Failed to reset daily usage:', error);
    }
  },
);


--- FILE: reset_daily_usage/package.json ---

{
  "name": "reset_daily_usage",
  "description": "Scheduled Cloud Function to reset daily usage counters",
  "main": "index.js",
  "scripts": {
    "deploy": "firebase deploy --only functions:resetDailyUsage",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "20"
  },
  "dependencies": {
    "firebase-admin": "^13.4.0",
    "firebase-functions": "^6.3.2"
  },
  "private": true
}


--- FILE: src/KQ-UI/KQBottomSheet.jsx ---

//* KQBottomSheet.jsx
import React, {useEffect, useRef, useState} from 'react';
import {
  View,
  Animated,
  StyleSheet,
  Dimensions,
  TouchableWithoutFeedback,
} from 'react-native';
import {PanGestureHandler, State} from 'react-native-gesture-handler';

const {height} = Dimensions.get('window');

const KQBottomSheet = ({
  visible,
  onClose,
  children,
  snapPoints = [0.01, 0.9],
  innerStyles = {},
}) => {
  const translateY = useRef(new Animated.Value(height)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  const [isFullyVisible, setIsFullyVisible] = useState(visible);
  const [heightMulti, setHeightMulti] = useState(0.8);

  useEffect(() => {
    if (visible) {
      setIsFullyVisible(true);
      Animated.parallel([
        Animated.spring(translateY, {
          toValue: height * (1 - snapPoints[1]),
          speed: 7,
          bounciness: 3,
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 1,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.spring(translateY, {
          toValue: height,
          speed: 5,
          bounciness: 0,
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start(() => {
        setTimeout(() => {
          setIsFullyVisible(false);
        }, 500);
      });
    }
  }, [visible]);

  if (!isFullyVisible) return null;

  const handleGesture = event => {
    const {translationY} = event.nativeEvent;

    if (translationY >= 0) {
      translateY.setValue(height * (1 - snapPoints[1]) + translationY);
    }
  };

  const handleStateChange = event => {
    const {translationY, velocityY} = event.nativeEvent;

    if (event.nativeEvent.state === State.END) {
      if (translationY > height * 0.5 || velocityY > 1.5) {
        Animated.timing(translateY, {
          toValue: height,
          duration: 250,
          useNativeDriver: true,
        }).start(() => onClose());
      } else {
        Animated.spring(translateY, {
          toValue: height * (1 - snapPoints[1]),
          speed: 7,
          bounciness: 3,
          useNativeDriver: true,
        }).start();
      }
    }
  };

  return (
    <TouchableWithoutFeedback
      onPress={e => {
        if (e.target === e.currentTarget) {
          onClose();
        }
      }}
      accessible={false}>
      <Animated.View style={[styles.overlay, {opacity}]}>
        <Animated.View
          style={[
            styles.sheet,
            {transform: [{translateY}]},
            {height: height * heightMulti},
          ]}>
          <PanGestureHandler
            onGestureEvent={handleGesture}
            onHandlerStateChange={handleStateChange}>
            <View style={styles.handleContainer}>
              <View style={styles.handle} />
            </View>
          </PanGestureHandler>
          <View style={[styles.viewableArea, innerStyles]}>{children}</View>
        </Animated.View>
      </Animated.View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'flex-end',
  },
  sheet: {
    width: '100%',
    height: height,
    backgroundColor: '#fff',
    borderTopLeftRadius: 15,
    borderTopRightRadius: 15,
  },
  handleContainer: {
    alignItems: 'center',
    paddingTop: 15,
    paddingBottom: 15,
  },
  handle: {
    width: 40,
    height: 5,
    backgroundColor: '#c4c4c4',
    borderRadius: 10,
  },
  viewableArea: {
    flex: 1,
    marginHorizontal: 5,
    // borderWidth: 1,
    marginBottom: 55,
  },
});

export default __DEV__ ? KQBottomSheet : React.memo(KQBottomSheet);


--- FILE: src/KQ-UI/KQButton.jsx ---

//* KQButton.jsx
import React, {useCallback} from 'react';
import {Keyboard, StyleSheet, TouchableOpacity} from 'react-native';
import {Text, View} from '../KQ-UI/';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {
  useColors,
  useFontStyles,
  useButtonStyles,
  useButtonSizes,
} from './KQUtilities';
import {useCoreInfo} from '../utilities/coreInfo';

const KQButton = ({
  children,
  onPress,
  style = {},
  textStyle = {},
  outerTextStyle = {},
  type = 'filled',
  size = 'small',
  color = 'primary',
  textSize = 'small',
  textColor = 'white',
  fontType = 'open-6',
  hapticFeedback = 'light',
  disabled = false,
  underline = false,
  underlineColor = null,
  underlineWidth = 1,
  symbols = false,
  symbolStyle = {},
  ...props
}) => {
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();
  const buttonColor = useColors(disabled ? 'basic' : color);
  const buttonStyle = useButtonStyles(type, buttonColor);
  const buttonSize = useButtonSizes(size);

  const fontStyles = useFontStyles(
    fontType,
    textSize,
    type === 'filled' ? textColor : buttonColor,
  );

  const handlePress = useCallback(() => {
    Keyboard.dismiss();
    useHaptics(core?.userSettings?.hapticStrength || hapticFeedback);
    if (onPress) onPress();
  }, [core?.userSettings?.hapticStrength, hapticFeedback, onPress]);

  return (
    <TouchableOpacity
      style={[ButtonStyles.buttonOC, buttonStyle, buttonSize, style]}
      onPress={!disabled ? handlePress : null}
      disabled={disabled}
      {...props}>
      <View
        style={[
          outerTextStyle,
          {
            borderBottomWidth: underline ? underlineWidth : 0,
            borderColor: underlineColor || buttonColor,
          },
        ]}>
        {!symbols && (
          <Text
            numberOfLines={1}
            style={[ButtonStyles.buttonText, fontStyles, textStyle]}>
            {children}
          </Text>
        )}
        {symbols && (
          <View centerVH style={symbolStyle}>
            {children}
          </View>
        )}
      </View>
    </TouchableOpacity>
  );
};

const ButtonStyles = StyleSheet.create({
  buttonOC: {
    borderRadius: 5,
    marginHorizontal: 5,
    marginVertical: 5,
    alignContent: 'center',
    alignItems: 'center',
    justifyContent: 'center',
  },
  buttonText: {
    fontSize: 16,
    textAlign: 'center',
  },
});

export default __DEV__ ? KQButton : React.memo(KQButton);


--- FILE: src/KQ-UI/KQCamera.jsx ---

//* KQCamera.jsx
import React, {useRef} from 'react';
import {View} from 'react-native';
import {
  Camera,
  useCameraDevice,
  useCodeScanner,
} from 'react-native-vision-camera';
import {Icons} from '../components/IconListRouter';
import {useDeviceInfo} from '../hooks/useHooks';

const KQCamera = props => {
  const {torchEnabled = false, onReadCode = () => {}, cameraStyles} = props;

  const deviceInfo = useDeviceInfo();
  const cameraRef = useRef(null);
  const device = useCameraDevice('back', {
    physicalDevices: [
      'ultra-wide-angle-camera',
      'wide-angle-camera',
      'telephoto-camera',
    ],
  });

  const iconSize = deviceInfo?.dimensions?.width * 0.4;
  const marginWidth = deviceInfo?.dimensions?.width * 0.225;

  const codeScanner = useCodeScanner({
    codeTypes: ['ean-8', 'ean-13', 'upc-a', 'upc-e'],
    onCodeScanned: onReadCode,
  });

  if (!device) return <View style={{flex: 1, backgroundColor: 'black'}} />;

  return (
    <View style={KQStyles.cameraContainer}>
      <View style={KQStyles.scanFrame}>
        <View style={KQStyles.barcode(marginWidth)}>
          <Icons.Barcode color={'#ffffff40'} size={iconSize} />
        </View>
      </View>
      <View style={{height: '100%', width: '100%'}}>
        <Camera
          ref={cameraRef}
          style={[KQStyles.camera, cameraStyles]}
          device={device}
          isActive={true}
          codeScanner={codeScanner}
          torch={torchEnabled ? 'on' : 'off'}
          laserColor="red"
          autoFocus="on"
          frameColor="white"
          zoom={1.5}
          enableZoomGesture={false}
          {...props}
        />
      </View>
    </View>
  );
};

export default __DEV__ ? KQCamera : React.memo(KQCamera);

const KQStyles = {
  cameraContainer: {
    flex: 1,
    paddingBottom: 30,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scanFrame: {
    zIndex: 9999,
    position: 'absolute',
    borderWidth: 2,
    borderColor: '#ffffff70',
    borderRadius: 20,
  },
  barcode: marginWidth => ({
    marginTop: 20,
    marginBottom: 10,
    marginHorizontal: marginWidth,
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  }),
  camera: {
    flex: 1,
    zIndex: 1,
  },
};


--- FILE: src/KQ-UI/KQDropdown.jsx ---

//* KQDropdown.jsx

import React, {useMemo, useState} from 'react';
import {
  View,
  TouchableOpacity,
  Platform,
  KeyboardAvoidingView,
  Keyboard,
} from 'react-native';
import {Modal, Text, ScrollView, Input} from '../KQ-UI/';
import {Icons} from '../components/IconListRouter';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useCoreInfo} from '../utilities/coreInfo';
import {useDeviceInfo} from '../hooks/useHooks';
import {useColors} from './KQUtilities';

const KQDropdown = ({
  label = '',
  customLabel = '',
  labelStyles = {},
  required = false,
  validation = false,
  validationMessage = '',
  value = null,
  setValue = () => {},
  placeholder = '',
  onPress = () => {},
  caption,
  hapticFeedback = 'light',
  mapData,
  onRow = false,
  ...props
}) => {
  const isIOS = Platform.OS === 'ios';
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();
  const devices = useDeviceInfo();
  const [showDropModal, setShowDropModal] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);
  const [customValue, setCustomValue] = useState('');

  const handleOnPress = () => {
    Keyboard.dismiss();
    useHaptics(core?.userSettings?.hapticStrength || hapticFeedback);
    setSelectedItem(value);
    setShowDropModal(true);
    onPress();
  };

  const renderStyles = useMemo(() => {
    if (isIOS && value === null) {
      return {
        color: '#373d4360',
        padding: 0,
      };
    }
    if (!isIOS && value === null) {
      return {
        color: '#373d4360',
        padding: 0,
        opacity: 0.8,
      };
    }
  }, [value, placeholder]);

  const handleCancel = () => {
    setShowDropModal(false);
    setSelectedItem(null);
    setCustomValue('');
  };

  const handleSave = item => {
    setShowDropModal(false);

    if (item?.key === 'custom') {
      const cleaned = customValue.trim();
      const newItem = {
        index: -1,
        key: cleaned.toLowerCase().replace(/\s+/g, '-'),
        label: cleaned,
      };
      setValue(newItem);
    } else {
      setValue(item);
    }
  };

  const handleClear = () => {
    setSelectedItem(null);
    setValue(null);
    setCustomValue('');
  };

  return (
    <View style={styles.dropContainer}>
      {label && (
        <View style={styles.labelContainer}>
          <Text
            size="xSmall"
            font="open-6"
            style={[styles.label(validation, props.disabled), labelStyles]}>
            {label} {required && '*'}
          </Text>
        </View>
      )}
      <View style={styles.dropWrapper}>
        <TouchableOpacity
          disabled={props.disabled}
          onPress={handleOnPress}
          style={styles.textInputContainer(isIOS, onRow)}>
          <Text
            style={renderStyles}
            numberOfLines={1}
            kqColor={props.disabled ? 'dark50' : 'dark90'}>
            {value?.label || placeholder}
          </Text>
        </TouchableOpacity>

        {value && (
          <TouchableOpacity
            disabled={props.disabled}
            onPress={handleClear}
            style={styles.textInputAccessory(isIOS, onRow)}>
            <Icons.Close
              color={props.disabled ? useColors('dark50') : useColors('black')}
            />
          </TouchableOpacity>
        )}

        <TouchableOpacity
          disabled={props.disabled}
          onPress={handleOnPress}
          style={styles.textInputAccessory(isIOS, onRow)}>
          <Icons.ChevronDown
            color={props.disabled ? useColors('dark50') : useColors('black')}
          />
        </TouchableOpacity>
      </View>
      {caption && (
        <View style={styles.captionContainer}>
          <View style={{flex: 1}}>
            <Text
              size="xSmall"
              kqColor={props.disabled ? 'dark50' : 'dark90'}
              font="open-5"
              numberOfLines={1}>
              ({caption})
            </Text>
          </View>
        </View>
      )}
      <Modal
        visible={showDropModal}
        fullScreen
        hideHeader
        onClose={() => setShowDropModal(false)}>
        <View style={styles.modalContainer}>
          <View style={styles.headerContainer}>
            <TouchableOpacity
              style={styles.headerButtonContainer}
              onPress={handleCancel}>
              <View style={styles.headerButtonIconLeft}>
                <View style={{position: 'relative', left: 4}}>
                  <Icons.Back />
                </View>
              </View>
              <View style={styles.headerButtonTextLeft}>
                <Text>Cancel</Text>
              </View>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.headerButtonContainer}
              onPress={() => handleSave(selectedItem)}>
              <View style={styles.headerButtonTextRight}>
                <Text>Select</Text>
              </View>
              <View style={styles.headerButtonIconRight}>
                <Icons.Check size={20} />
              </View>
            </TouchableOpacity>
          </View>
          <View style={{flex: 1}}>
            <ScrollView>
              <View
                style={{flex: 1, borderTopWidth: 1.5, borderColor: '#c4c4c4'}}>
                {mapData?.map((item, index) => {
                  if (item.isHeader) {
                    return (
                      <View
                        key={index}
                        style={{
                          paddingVertical: 10,
                          paddingHorizontal: 10,
                          borderBottomWidth: 1,
                          borderColor: '#373d4380',
                          backgroundColor: '#f2f2f2',
                        }}>
                        <Text
                          size="xSmall"
                          font="open-5"
                          kqColor="dark90"
                          centered>
                          {item.label}
                        </Text>
                      </View>
                    );
                  }

                  const isCustomField = item.key === 'custom';

                  return (
                    <View
                      key={index}
                      style={{
                        borderBottomWidth: 1,
                        borderColor: '#373d4380',
                      }}>
                      {isCustomField ? (
                        <View
                          style={{
                            paddingHorizontal: 5,
                            paddingVertical: 8,
                          }}>
                          {customLabel && (
                            <Text size="xSmall" font="open-5">
                              {customLabel}
                            </Text>
                          )}
                          <KeyboardAvoidingView>
                            <Input
                              value={customValue}
                              onChangeText={text => {
                                setCustomValue(text);
                                setSelectedItem({
                                  index: 0,
                                  key: 'custom',
                                  label: 'Custom (Enter Your Own)',
                                });
                              }}
                              placeholder="Type here..."
                              containerStyles={{
                                marginHorizontal: 0,
                                marginVertical: 0,
                                paddingHorizontal: 0,
                                marginTop: 5,
                              }}
                              wrapperStyles={{borderBottomWidth: 0}}
                            />
                          </KeyboardAvoidingView>
                        </View>
                      ) : (
                        <TouchableOpacity
                          style={{
                            height: 48,
                            alignItems: 'flex-start',
                            justifyContent: 'center',
                            paddingHorizontal: 5,
                          }}
                          onPress={() => {
                            setSelectedItem(item);
                            handleSave(item);
                          }}>
                          <View style={{flexDirection: 'row'}}>
                            <View style={{flex: 1}}>
                              <Text
                                size={
                                  selectedItem?.index === item.index
                                    ? 'small'
                                    : 'xSmall'
                                }
                                font={
                                  selectedItem?.index === item.index
                                    ? 'open-7'
                                    : 'open-5'
                                }>
                                {item.label}
                              </Text>
                            </View>
                            {selectedItem?.index === item.index && (
                              <View>
                                <Icons.Check color={'#63B76C'} size={20} />
                              </View>
                            )}
                          </View>
                        </TouchableOpacity>
                      )}
                    </View>
                  );
                })}
              </View>
            </ScrollView>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = {
  dropContainer: {
    marginHorizontal: 5,
    marginVertical: 5,
    paddingHorizontal: 2,
  },
  labelContainer: {position: 'relative', left: 0},
  label: (validation, disabled) => ({
    color: validation ? '#DA2C43' : disabled ? '#373d4390' : '#373d43',
  }),
  dropWrapper: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
    // paddingTop: 2,
    paddingBottom: 0,
  },
  captionContainer: {
    flexDirection: 'row',
    paddingHorizontal: 2,
    marginTop: 2,
  },
  textInputContainer: (isIOS, onRow) => ({
    flex: 1,
    height: isIOS ? 28 : onRow ? 34 : 28,
    paddingHorizontal: 1,
    paddingVertical: 3,
    position: 'relative',
    top: isIOS ? 0 : onRow ? 7 : 0,
  }),
  textInputAccessory: (isIOS, onRow) => ({
    paddingHorizontal: 2,
    position: 'relative',
    top: isIOS ? 4 : onRow ? 11 : 4,
  }),
  modalContainer: {flex: 1, flexDirection: 'column'},
  headerContainer: {
    height: 50,
    marginHorizontal: 5,
    marginBottom: 5,
    flexDirection: 'row',
  },
  headerButtonContainer: {
    flex: 1,
    flexDirection: 'row',
  },
  headerButtonIconRight: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 5,
  },
  headerButtonIconLeft: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerButtonTextLeft: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    paddingHorizontal: 5,
  },
  headerButtonTextRight: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingHorizontal: 5,
    marginRight: 5,
  },
};

export default __DEV__ ? KQDropdown : React.memo(KQDropdown);


--- FILE: src/KQ-UI/KQImage.jsx ---

//* KQImage.jsx

import React from 'react';
import FastImage from 'react-native-fast-image';

const KQImage = ({image, ...props}) => {
  const isFullUrl = image?.startsWith('http');

  const uri = isFullUrl
    ? image
    : `https://firebasestorage.googleapis.com/v0/b/kitchen-queue-fe2fe.firebasestorage.app/o/recipes%2F${encodeURIComponent(
        image,
      )}?alt=media`;

  return (
    <FastImage
      source={{
        uri,
        priority: FastImage.priority.normal,
        cache: FastImage.cacheControl.web,
      }}
      resizeMode={FastImage.resizeMode.cover}
      {...props}
    />
  );
};

export default __DEV__ ? KQImage : React.memo(KQImage);


--- FILE: src/KQ-UI/KQInput.jsx ---

//* KQInput.jsx
import React, {use, useMemo} from 'react';
import {View, TextInput, StyleSheet, Keyboard} from 'react-native';
import {Text} from '../KQ-UI/';
import {useColors, useFontSizes, useFontStyles} from './KQUtilities';

const KQInput = ({
  label = '',
  labelStyles = {},
  required = false,
  validation = false,
  validationMessage = '',
  value = '',
  onChangeText = () => {},
  capitalize = false,
  capitalMode = 'none', // 'none' | 'sentences' | 'words' | 'characters' |
  multiline = false,
  multiHeight = 'medium',
  scrollEnabled = true,
  caption = '',
  accessoryRight = null,
  counter = false,
  maxCount = 1000,
  containerStyles = {},
  textInputStyles = {},
  wrapperStyles = {},
  textSize = 'small',
  labelTextSize = 'xSmall',
  ...props
}) => {
  const fontStyles = useFontStyles('open-6', 'small', 'black');
  const showCount = value?.length || 0;

  const multiMode = useMemo(() => {
    if (!multiline) return {};

    const heightMap = {
      small: {minHeight: 20, maxHeight: 40},
      medium: {minHeight: 20, maxHeight: 75},
      large: {minHeight: 20, maxHeight: 150},
      xLarge: {minHeight: 20, maxHeight: 250},
      full: {minHeight: 20},
    };

    return {...(heightMap[multiHeight] || heightMap.medium)};
  }, [multiline, multiHeight]);

  const capMode = useMemo(
    () => (multiline ? 'sentences' : capitalize ? capitalMode : 'none'),
    [capitalize, capitalMode, multiline],
  );

  const InputInfoContainer = ({children}) => {
    if (caption || counter || validationMessage) {
      return (
        <View
          style={{
            flexDirection: 'row',
            paddingHorizontal: 2,
            marginTop: 2,
          }}>
          {children}
        </View>
      );
    }
    return null;
  };

  const handleTextChange = text => {
    if (text.length > maxCount) {
      text = text.substring(0, maxCount); // Trim excess characters
    }
    onChangeText(text); // Update state
  };

  return (
    <View style={[styles.inputContainer, {...containerStyles}]}>
      {label && (
        <View style={styles.labelContainer}>
          <Text
            size={labelTextSize || 'xSmall'}
            font="open-6"
            style={[styles.label(validation, props.disabled), labelStyles]}>
            {label} {required && '*'}
          </Text>
        </View>
      )}
      <View style={[styles.inputWrapper, {...wrapperStyles}]}>
        <View style={[styles.textInputContainer, {...textInputStyles}]}>
          {props.disabled ? (
            <Text style={[fontStyles, {padding: 0, color: '#c4c4c4'}]}>
              {value}
            </Text>
          ) : (
            <TextInput
              value={value}
              onChangeText={handleTextChange}
              autoCapitalize={capMode}
              multiline={multiline}
              allowFontScaling={false}
              style={[
                fontStyles,
                multiMode,
                {padding: 0},
                {...textInputStyles},
              ]}
              fontSize={useFontSizes()[textSize]}
              // fontSize={useFontSizes(textSize).fontSize}
              onSubmitEditing={Keyboard.dismiss}
              placeholderTextColor={useColors('dark60')}
              {...props}
            />
          )}
        </View>
        {accessoryRight && (
          <View style={styles.accessoriesContainer}>
            {typeof accessoryRight === 'function'
              ? accessoryRight()
              : accessoryRight}
          </View>
        )}
      </View>
      <InputInfoContainer>
        {caption && (
          <View style={{flex: 1}}>
            <Text
              size="xSmall"
              kqColor="dark90"
              font="open-5"
              numberOfLines={1}>
              ({caption})
            </Text>
          </View>
        )}
        {validation && (
          <View style={{flex: 1}}>
            <Text
              size="xSmall"
              kqColor="danger"
              font="open-5"
              numberOfLines={1}>
              ({validationMessage})
            </Text>
          </View>
        )}
        {counter && (
          <View style={{flex: caption ? 0 : 1, alignItems: 'flex-end'}}>
            <Text
              size="xSmall"
              kqColor={showCount >= maxCount ? 'danger' : 'dark90'}
              font="open-5"
              numberOfLines={1}
              style={{color: useColors('dark60')}}>
              ({showCount} / {maxCount})
            </Text>
          </View>
        )}
      </InputInfoContainer>
    </View>
  );
};

const styles = {
  inputContainer: {
    marginHorizontal: 5,
    marginVertical: 5,
    paddingHorizontal: 2,
  },
  labelContainer: {position: 'relative', left: 0},
  label: (validation, disabled) => ({
    color: validation ? '#DA2C43' : disabled ? '#373d4390' : '#373d43',
  }),
  inputWrapper: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
  },
  textInputContainer: {
    flex: 1,
    // height: 40,
    paddingHorizontal: 1,
    paddingVertical: 3,
  },
  accessoriesContainer: {
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
};

export default __DEV__ ? KQInput : React.memo(KQInput);


--- FILE: src/KQ-UI/KQLayout.jsx ---

//* KQLayout.jsx
import React, {useMemo} from 'react';
import {
  TouchableWithoutFeedback,
  Keyboard,
  KeyboardAvoidingView,
  Platform,
  Modal,
  ActivityIndicator,
} from 'react-native';
import NavHeader from '../components/NavHeader';
import KQScrollView from './KQScrollView';
import {useColors} from './KQUtilities';
import {Text, View} from '../KQ-UI';

const KQLayout = ({
  children,
  mode = '',
  bgColor = '#ffffff',
  headerTitle = '',
  headerColor = '#29856c',
  textColor = '#ffffff',
  LeftButton = '',
  RightButton = '',
  LeftAction = null,
  RightAction = null,
  sheetOpen = false,
  useHeader = true,
  innerViewStyles = {},
  outerViewStyles = {},
  noBar = false,
  hideBar = false,
  loading = false,
  loadingHeight = 100,
  loadingWidth = '50%',
  loadingText = '',
}) => {
  const baseStyle = {
    flex: 1,
    backgroundColor: bgColor,
    paddingBottom: 25,
  };

  // Render Loading Overlay
  const loadingOverlay = useMemo(() => {
    if (!loading) return null;
    return (
      <Modal transparent={true} animationType="fade" visible={loading}>
        <View style={overlayStyles.wrapper}>
          <View
            p20
            style={overlayStyles.container(loadingHeight, loadingWidth)}>
            <ActivityIndicator size="large" color="#29856c" />
            <View mt5>
              <Text>{loadingText || `Loading`}</Text>
            </View>
          </View>
        </View>
      </Modal>
    );
  }, [loading, loadingHeight, loadingWidth, loadingText]);

  const renderHeader = () =>
    useHeader && (
      <NavHeader
        title={headerTitle}
        headerColor={headerColor}
        textColor={textColor}
        LeftButton={LeftButton}
        RightButton={RightButton}
        LeftAction={LeftAction}
        RightAction={RightAction}
        sheetOpen={sheetOpen}
      />
    );

  switch (mode) {
    case 'keyboard-scroll':
      return (
        <View style={[baseStyle, outerViewStyles]}>
          {loadingOverlay}
          <TouchableWithoutFeedback
            onPress={Keyboard.dismiss}
            accessible={false}>
            <View style={{flex: 1}}>
              {renderHeader()}
              <KeyboardAvoidingView
                style={{flex: 1}}
                behavior={Platform.OS === 'ios' ? 'padding' : undefined}
                keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}>
                <KQScrollView
                  noBar={noBar}
                  hideBar={hideBar}
                  onScrollBeginDrag={Keyboard.dismiss}
                  contentContainerStyle={{flexGrow: 1}}
                  keyboardShouldPersistTaps="handled">
                  <View style={[{flex: 1}, innerViewStyles]}>{children}</View>
                </KQScrollView>
              </KeyboardAvoidingView>
            </View>
          </TouchableWithoutFeedback>
        </View>
      );

    case 'keyboard-static':
      return (
        <View style={[baseStyle, outerViewStyles]}>
          {loadingOverlay}
          <TouchableWithoutFeedback
            onPress={Keyboard.dismiss}
            accessible={false}>
            <View style={{flex: 1}}>
              {renderHeader()}
              <KeyboardAvoidingView
                style={{flex: 1}}
                behavior={Platform.OS === 'ios' ? 'padding' : undefined}
                keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}>
                <View style={[{flex: 1}, innerViewStyles]}>{children}</View>
              </KeyboardAvoidingView>
            </View>
          </TouchableWithoutFeedback>
        </View>
      );

    case 'scroll-only':
      return (
        <View style={[baseStyle, outerViewStyles]}>
          {loadingOverlay}
          {renderHeader()}
          <KQScrollView noBar={noBar} hideBar={hideBar}>
            <View style={[{flex: 1}, innerViewStyles]}>{children}</View>
          </KQScrollView>
        </View>
      );

    default:
      return (
        <View style={[baseStyle, outerViewStyles]}>
          {loadingOverlay}
          {renderHeader()}
          <View style={[{flex: 1}, innerViewStyles]}>{children}</View>
        </View>
      );
  }
};

const overlayStyles = {
  wrapper: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.2)',
  },
  container: (loadingWidth, loadingHeight) => ({
    minWidth: loadingWidth,
    minHeight: loadingHeight,
    backgroundColor: 'white',
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1.5,
    borderColor: useColors('dark50'),
    shadowColor: '#000',
    shadowOffset: {width: 1, height: 2},
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  }),
};

export default KQLayout;


--- FILE: src/KQ-UI/KQModal.jsx ---

//* KQModal.jsx
import React, {useEffect, useMemo, useRef, useState} from 'react';
import {
  View,
  Keyboard,
  TouchableOpacity,
  Modal,
  StatusBar,
  Pressable,
  Dimensions,
} from 'react-native';
import {Icons} from '../components/IconListRouter';
import {Text} from '../KQ-UI';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import {useColors} from './KQUtilities';
import {useCoreInfo} from '../utilities/coreInfo';
import NavigationMode from 'react-native-navigation-mode';

const KQModal = ({
  visible,
  title = '',
  children,
  height = '90%',
  width = '90%',
  headerFont = 'open-6',
  headerSize = 'small',
  headerTextColor = 'white',
  headerColor = 'primary',
  buttonColor = 'primary',
  hideHeader = false,
  hideTitle = false,
  hideClose = false,
  fullScreen = false,
  hapticFeedback = 'light',
  barStyle = 'default',
  onClose,
}) => {
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();
  const insets = useSafeAreaInsets();
  const isClosingRef = useRef(false);
  const [mode, setMode] = useState(null);

  const handleClose = (event = null) => {
    const isBackdropTap = event?.target === event?.currentTarget;
    const isManualCall = !event;

    if ((isBackdropTap || isManualCall) && !isClosingRef.current) {
      isClosingRef.current = true;

      useHaptics(core?.userSettings?.hapticStrength || hapticFeedback);
      Keyboard.dismiss();

      setTimeout(() => {
        onClose?.();
        isClosingRef.current = false;
      }, 100);
    }
  };

  useEffect(() => {
    let isMounted = true;

    NavigationMode.getNavigationMode()
      .then(result => {
        if (isMounted) {
          setMode(result);
        }
      })
      .catch(err => {});

    return () => {
      isMounted = false;
    };
  }, []);

  const hasButtons = mode?.type !== 'gesture';

  const setBarStyle = useMemo(() => {
    if (barStyle === 'light') {
      return 'light-content';
    }
    if (barStyle === 'dark') {
      return 'dark-content';
    }
    if (barStyle === 'default') {
      if (fullScreen) {
        return 'dark-content';
      } else {
        return 'light-content';
      }
    }
  }, [barStyle, fullScreen]);

  const Header = () => {
    if (hideHeader) {
      return null;
    }
    return (
      <View style={[styles.headerWrapper(fullScreen, headerColor)]}>
        <View style={styles.headerContainer(hideClose)}>
          {!hideTitle && (
            <Text
              kqColor={useColors(headerTextColor)}
              font={headerFont}
              size={headerSize}
              numberOfLines={1}>
              {title}
            </Text>
          )}
        </View>
        {!hideClose && (
          <TouchableOpacity
            style={styles.closeButton(buttonColor)}
            onPress={() => handleClose()}>
            <Icons.Close size={25} color={'white'} />
          </TouchableOpacity>
        )}
      </View>
    );
  };

  const [screenSize, setScreenSize] = useState({
    height: Dimensions.get('window').height,
    width: Dimensions.get('window').width,
  });

  useEffect(() => {
    const updateScreenSize = () => {
      setScreenSize({
        height: Dimensions.get('window').height,
        width: Dimensions.get('window').width,
      });
    };

    const subscription = Dimensions.addEventListener(
      'change',
      updateScreenSize,
    );

    return () => subscription?.remove();
  }, []);

  const prsHeight = Math.min(Math.max(parseFloat(height), 75), 100);
  const prsWidth = Math.min(Math.max(parseFloat(width), 75), 100);

  const topHeight = fullScreen
    ? 0
    : insets.top + (screenSize.height - (screenSize.height * prsHeight) / 100);

  const btmHeight = fullScreen
    ? 0
    : insets.bottom +
      (screenSize.height - (screenSize.height * prsHeight) / 100);

  const midHeight = screenSize.height - topHeight - btmHeight;

  const midLeftWidth = fullScreen
    ? 0
    : insets.left + (screenSize.width - (screenSize.width * prsWidth) / 100);
  const midRightWidth = fullScreen
    ? 0
    : insets.right + (screenSize.width - (screenSize.width * prsWidth) / 100);

  if (!visible) {
    return null;
  }

  return (
    <Modal
      visible={visible}
      animationType="fade"
      transparent={true}
      statusBarTranslucent
      onRequestClose={handleClose}>
      <StatusBar
        barStyle={setBarStyle}
        backgroundColor={'rgba(0,0,0,0.5)'}
        translucent
      />
      <View style={styles.wrapper}>
        <Pressable
          style={styles.pressTop(topHeight, screenSize)}
          onPress={handleClose}
        />
        <View style={styles.container}>
          <Pressable
            style={styles.pressLeft(midLeftWidth, midHeight)}
            onPress={handleClose}
          />
          <View
            style={styles.subContainer(
              fullScreen,
              midHeight,
              hasButtons,
              insets,
            )}>
            <Header />
            {children}
          </View>
          <Pressable
            style={styles.pressRight(midRightWidth, midHeight)}
            onPress={handleClose}
          />
        </View>
        <Pressable
          style={styles.pressBtm(btmHeight, screenSize)}
          onPress={handleClose}
        />
      </View>
    </Modal>
  );
};

export default __DEV__ ? KQModal : React.memo(KQModal);

const styles = {
  wrapper: {
    flex: 1,
    flexDirection: 'column',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  pressTop: (topHeight, screenSize) => ({
    height: topHeight,
    width: screenSize.width,
    backgroundColor: 'transparent',
  }),
  pressBtm: (btmHeight, screenSize) => ({
    height: btmHeight,
    width: screenSize.width,
    backgroundColor: 'transparent',
  }),
  pressLeft: (midLeftWidth, midHeight) => ({
    width: midLeftWidth,
    height: midHeight,
    backgroundColor: 'transparent',
  }),
  pressRight: (midRightWidth, midHeight) => ({
    width: midRightWidth,
    height: midHeight,
    backgroundColor: 'transparent',
  }),
  container: {flex: 1, flexDirection: 'row'},
  subContainer: (fullScreen, midHeight, hasButtons, insets) => ({
    flex: 1,
    height: midHeight
      ? hasButtons
        ? midHeight + insets.top
        : midHeight
      : '100%',
    // height: midHeight,
    borderColor: '#29856c',
    backgroundColor: '#fff',
    paddingTop: fullScreen ? insets.top : 0,
    paddingBottom: fullScreen ? insets.bottom : 0,
    borderRadius: fullScreen ? 0 : 15,
    shadowColor: fullScreen ? '' : 'black',
    shadowOffset: fullScreen ? {} : {width: 3, height: 4},
    shadowOpacity: fullScreen ? 0 : 0.5,
    elevation: fullScreen ? 0 : 7,
  }),

  headerWrapper: (fullScreen, headerColor) => ({
    flexDirection: 'row',
    backgroundColor: useColors(headerColor),
    borderTopRightRadius: fullScreen ? 0 : 15,
    borderTopLeftRadius: fullScreen ? 0 : 15,
  }),
  headerContainer: hideClose => ({
    flex: 1,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginHorizontal: hideClose ? 10 : 40,
  }),
  closeButton: buttonColor => ({
    position: 'absolute',
    zIndex: 999,
    top: 1,
    right: 2,
    borderWidth: 1.5,
    backgroundColor: useColors(buttonColor || 'primary'),
    justifyContent: 'center',
    alignItems: 'center',
    margin: 5,
    width: 28,
    height: 28,
    borderRadius: 8,
    borderColor: 'white',
  }),
};


--- FILE: src/KQ-UI/KQMultiDropDown.jsx ---

//* KQMultiDropdown.jsx

import React, {useState, useMemo} from 'react';
import {
  View,
  TouchableOpacity,
  Keyboard,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import {Modal, Text, ScrollView, Input} from '../KQ-UI/';
import {Icons} from '../components/IconListRouter';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useCoreInfo} from '../utilities/coreInfo';

const KQMultiDropdown = ({
  label = '',
  customLabel = '',
  labelStyles = {},
  required = false,
  validation = false,
  validationMessage = '',
  value = [],
  setValue = () => {},
  placeholder = '',
  onPress = () => {},
  caption,
  hapticFeedback = 'light',
  mapData,
  onRow = false,
  ...props
}) => {
  const isIOS = Platform.OS === 'ios';
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();
  const [showDropModal, setShowDropModal] = useState(false);
  const [selectedItems, setSelectedItems] = useState([]);
  const [customValue, setCustomValue] = useState('');

  const handleOnPress = () => {
    Keyboard.dismiss();
    useHaptics(core?.userSettings?.hapticStrength || hapticFeedback);
    const initial = Array.isArray(value) ? value.filter(v => !v.isHeader) : [];
    setSelectedItems(initial);
    setShowDropModal(true);
    onPress();
  };

  const renderStyles = useMemo(() => {
    if (isIOS && (value === null || value.length === 0)) {
      return {
        color: '#373d4360',
        padding: 0,
      };
    }
    if (!isIOS && (value === null || value.length === 0)) {
      return {
        color: '#373d4360',
        padding: 0,
        opacity: 0.8,
      };
    }
  }, [value, placeholder]);

  const handleCancel = () => {
    setShowDropModal(false);
    setSelectedItems([]);
    setCustomValue('');
  };

  const handleSave = () => {
    const filtered = selectedItems.filter(
      i =>
        (!i?.isHeader && i?.key !== 'custom') ||
        (!!customValue.trim() && i?.key === 'custom'),
    );

    const final = filtered.map(item => {
      if (item.key === 'custom') {
        const cleaned = customValue.trim();
        return {
          index: -1,
          key: cleaned.toLowerCase().replace(/\s+/g, '-'),
          label: cleaned,
          value: cleaned.toLowerCase().replace(/\s+/g, '-'),
        };
      }
      return item;
    });

    setValue(final);
    setShowDropModal(false);
  };

  const handleClear = () => {
    setSelectedItems([]);
    setValue([]);
    setCustomValue('');
  };

  const toggleSelection = item => {
    if (item?.isHeader) return;

    const exists = selectedItems.some(i => i.label === item.label);
    if (exists) {
      setSelectedItems(prev => prev.filter(i => i.label !== item.label));
    } else {
      setSelectedItems(prev => [...prev, item]);
    }
  };

  const isItemSelected = item => {
    if (!item || item.isHeader) return false;
    return selectedItems.some(i => i.label === item.label);
  };

  return (
    <View style={styles.dropContainer}>
      {label && (
        <View style={styles.labelContainer}>
          <Text
            size="xSmall"
            font="open-6"
            style={[styles.label(validation, props.disabled), labelStyles]}>
            {label} {required && '*'}
          </Text>
        </View>
      )}
      <View style={styles.dropWrapper}>
        <TouchableOpacity
          onPress={handleOnPress}
          style={styles.textInputContainer(isIOS, onRow)}>
          <Text style={renderStyles} numberOfLines={1}>
            {Array.isArray(value) && value.length > 0
              ? value.map(v => v.label).join(', ')
              : placeholder}
          </Text>
        </TouchableOpacity>

        {value?.length > 0 && (
          <TouchableOpacity
            onPress={handleClear}
            style={styles.textInputAccessory(isIOS, onRow)}>
            <Icons.Close />
          </TouchableOpacity>
        )}

        <TouchableOpacity
          onPress={handleOnPress}
          style={styles.textInputAccessory(isIOS, onRow)}>
          <Icons.ChevronDown />
        </TouchableOpacity>
      </View>

      {caption && (
        <View style={styles.captionContainer}>
          <Text size="xSmall" kqColor="dark90" font="open-5" numberOfLines={1}>
            ({caption})
          </Text>
        </View>
      )}

      <Modal
        visible={showDropModal}
        fullScreen
        hideHeader
        onClose={() => setShowDropModal(false)}>
        <View style={styles.modalContainer}>
          <View style={styles.headerContainer}>
            <TouchableOpacity
              style={styles.headerButtonContainer}
              onPress={handleCancel}>
              <View style={styles.headerButtonIconLeft}>
                <View style={{position: 'relative', left: 4}}>
                  <Icons.Back />
                </View>
              </View>
              <View style={styles.headerButtonTextLeft}>
                <Text>Cancel</Text>
              </View>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.headerButtonContainer}
              onPress={handleSave}>
              <View style={styles.headerButtonTextRight}>
                <Text>Select</Text>
              </View>
              <View style={styles.headerButtonIconRight}>
                <Icons.Check size={20} />
              </View>
            </TouchableOpacity>
          </View>

          <ScrollView>
            <View
              style={{flex: 1, borderTopWidth: 1.5, borderColor: '#c4c4c4'}}>
              {mapData?.map((item, index) => {
                const isCustomField = item.key === 'custom';
                const isHeader = item.isHeader;
                const selected = isItemSelected(item);

                if (isHeader) {
                  return (
                    <View
                      key={`header-${index}`}
                      style={{
                        paddingVertical: 10,
                        paddingHorizontal: 10,
                        borderBottomWidth: 1,
                        borderColor: '#373d4380',
                        backgroundColor: '#f2f2f2',
                      }}>
                      <Text
                        size="xSmall"
                        font="open-5"
                        kqColor="dark90"
                        centered>
                        {item.label}
                      </Text>
                    </View>
                  );
                }

                if (isCustomField) {
                  return (
                    <View
                      key={`custom-${index}`}
                      style={{
                        borderBottomWidth: 1,
                        borderColor: '#373d4380',
                        paddingHorizontal: 5,
                        paddingVertical: 8,
                      }}>
                      {customLabel && (
                        <Text size="xSmall" font="open-5">
                          {customLabel}
                        </Text>
                      )}
                      <KeyboardAvoidingView>
                        <Input
                          value={customValue}
                          onChangeText={text => {
                            setCustomValue(text);
                            const cleanedKey = text
                              .trim()
                              .toLowerCase()
                              .replace(/\s+/g, '-');
                            const customItem = {
                              index: -1,
                              key: 'custom',
                              label: text,
                              value: cleanedKey,
                            };
                            const exists = selectedItems.some(
                              i => i.key === 'custom',
                            );
                            if (!exists) {
                              setSelectedItems(prev => [...prev, customItem]);
                            } else {
                              setSelectedItems(prev =>
                                prev.map(i =>
                                  i.key === 'custom' ? customItem : i,
                                ),
                              );
                            }
                          }}
                          placeholder="Type here..."
                          containerStyles={{marginTop: 5}}
                          wrapperStyles={{borderBottomWidth: 0}}
                        />
                      </KeyboardAvoidingView>
                    </View>
                  );
                }

                return (
                  <TouchableOpacity
                    key={`item-${item.key || index}`}
                    style={{
                      height: 48,
                      alignItems: 'flex-start',
                      justifyContent: 'center',
                      paddingHorizontal: 5,
                      borderBottomWidth: 1,
                      borderColor: '#373d4380',
                    }}
                    onPress={() => toggleSelection(item)}>
                    <View style={{flexDirection: 'row'}}>
                      <View style={{flex: 1}}>
                        <Text
                          size={selected ? 'small' : 'xSmall'}
                          font={selected ? 'open-7' : 'open-5'}>
                          {item.label}
                        </Text>
                      </View>
                      {selected && (
                        <View>
                          <Icons.Check color={'#63B76C'} size={20} />
                        </View>
                      )}
                    </View>
                  </TouchableOpacity>
                );
              })}
            </View>
          </ScrollView>
        </View>
      </Modal>
    </View>
  );
};

const styles = {
  dropContainer: {
    // borderWidth: 1,
    marginHorizontal: 5,
    marginVertical: 5,
    paddingHorizontal: 2,
  },
  labelContainer: {position: 'relative', left: 0},
  label: (validation, disabled) => ({
    color: validation ? '#fE4949' : disabled ? '#373d4390' : '#373d43',
  }),
  dropWrapper: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
    paddingTop: 2,
    paddingBottom: 4,
  },
  captionContainer: {
    flexDirection: 'row',
    paddingHorizontal: 2,
    marginTop: 2,
  },
  textInputContainer: (isIOS, onRow) => ({
    flex: 1,
    height: isIOS ? 28 : onRow ? 34 : 28,
    paddingHorizontal: 1,
    paddingVertical: 3,
    position: 'relative',
    top: isIOS ? 3 : onRow ? 10 : 3,
  }),
  textInputAccessory: (isIOS, onRow) => ({
    paddingHorizontal: 2,
    position: 'relative',
    top: isIOS ? 6 : onRow ? 13 : 6,
  }),
  modalContainer: {flex: 1, flexDirection: 'column'},
  headerContainer: {
    height: 50,
    marginHorizontal: 5,
    marginBottom: 5,
    flexDirection: 'row',
  },
  headerButtonContainer: {
    flex: 1,
    flexDirection: 'row',
  },
  headerButtonIconRight: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 5,
  },
  headerButtonIconLeft: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerButtonTextLeft: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    paddingHorizontal: 5,
  },
  headerButtonTextRight: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingHorizontal: 5,
    marginRight: 5,
  },
};
export default __DEV__ ? KQMultiDropdown : React.memo(KQMultiDropdown);


--- FILE: src/KQ-UI/KQScrollView.jsx ---

//* KQScrollView.jsx
import React, {useState, useRef, useEffect} from 'react';
import {ScrollView, View, StyleSheet} from 'react-native';

const KQScrollView = ({children, style, noBar = false, hideBar = false}) => {
  const [scrollBarHeight, setScrollBarHeight] = useState(0);
  const [scrollBarTop, setScrollBarTop] = useState(0);
  const [layoutHeight, setLayoutHeight] = useState(0);
  const [contentHeight, setContentHeight] = useState(0);

  const scrollViewRef = useRef();

  useEffect(() => {
    if (layoutHeight > 0 && contentHeight > layoutHeight) {
      const visibleRatio = layoutHeight / contentHeight;
      const calculatedHeight = layoutHeight * visibleRatio;
      const minHeight = 30;
      setScrollBarHeight(Math.max(calculatedHeight, minHeight));
      setScrollBarTop(0);
    } else {
      setScrollBarHeight(0);
      setScrollBarTop(0);
    }
  }, [layoutHeight, contentHeight]);

  const handleLayout = event => {
    const {height} = event.nativeEvent.layout;
    setLayoutHeight(height);
  };

  const handleContentSizeChange = (width, height) => {
    setContentHeight(height);
  };

  const handleScroll = event => {
    const {layoutMeasurement, contentOffset, contentSize} = event.nativeEvent;
    const scrollRatio =
      contentOffset.y / (contentSize.height - layoutMeasurement.height);
    const calculatedTop =
      scrollRatio * (layoutMeasurement.height - scrollBarHeight);
    setScrollBarTop(calculatedTop);
  };

  return (
    <View style={[styles.container(hideBar), style]}>
      <ScrollView
        ref={scrollViewRef}
        onScroll={handleScroll}
        onLayout={handleLayout}
        onContentSizeChange={handleContentSizeChange}
        scrollEventThrottle={16}
        contentContainerStyle={
          noBar ? {flex: 1} : styles.scrollContent(hideBar)
        }
        showsVerticalScrollIndicator={false}>
        {children}
      </ScrollView>
      {scrollBarHeight > 0 && (
        <View style={styles.scrollBar}>
          <View
            style={[
              styles.scrollBarThumb,
              {
                height: scrollBarHeight,
                top: scrollBarTop,
              },
            ]}
          />
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: hideBar => ({
    flex: 1,
    position: 'relative',
    marginHorizontal: hideBar ? 0 : 3,
    paddingHorizontal: hideBar ? 0 : 5,
  }),
  scrollContent: hideBar => ({
    flexGrow: 1,
    paddingRight: hideBar ? 0 : 10,
    paddingTop: hideBar ? 0 : 5,
    paddingBottom: hideBar ? 0 : 5,
  }),
  scrollBar: {
    position: 'absolute',
    right: 2,
    top: 2,
    bottom: 2,
    width: 4,
    backgroundColor: 'transparent',
    borderRadius: 2,
  },
  scrollBarThumb: {
    position: 'absolute',
    left: 0,
    right: 0,
    backgroundColor: '#373d4380',
    borderRadius: 3,
  },
});

export default KQScrollView;


--- FILE: src/KQ-UI/KQText.jsx ---

//* KQText.jsx
import React from 'react';
import {Text} from 'react-native';
import {useFontStyles} from './KQUtilities';

const KQText = ({
  children,
  italic = false,
  centered = false,
  justified = false,
  rightAlign = false,
  style,
  size = 'small',
  kqColor = 'black',
  font = 'open-6',
  ...props
}) => {
  const fontStyles = useFontStyles(font, size, kqColor, italic);

  return (
    <Text
      allowFontScaling={false}
      style={[
        fontStyles,
        {
          textAlign: justified
            ? 'justify'
            : rightAlign
            ? 'right'
            : centered
            ? 'center'
            : 'left',
        },
        style,
      ]}
      {...props}>
      {children}
    </Text>
  );
};

export default __DEV__ ? KQText : React.memo(KQText);


--- FILE: src/KQ-UI/KQToast.jsx ---

//* KQToast.jsx
import Toast, {BaseToast} from 'react-native-toast-message';

const DEFAULT_VISIBILITY_TIME = 1500;

// ✅ Patch Toast.show to use default visibilityTime if not provided
const originalShow = Toast.show;
Toast.show = (options = {}) => {
  if (!options.visibilityTime) {
    options.visibilityTime = DEFAULT_VISIBILITY_TIME;
  }
  originalShow(options);
};

const toastStyles = (fontSize1, fontSize2) => ({
  baseStyle: {
    top: 60,
    minHeight: 75,
    paddingVertical: 10,
    height: 'auto',
  },
  primary: {borderLeftColor: '#29856c'},
  success: {borderLeftColor: '#63b76C'},
  info: {borderLeftColor: '#009DC4'},
  warning: {borderLeftColor: '#dda44b'},
  danger: {borderLeftColor: '#da2c43'},
  error: {borderLeftColor: '#da2c43'},
  dark: {borderLeftColor: '#373d43'},
  basic: {borderLeftColor: '#C4C4C4'},
  textStyle1: {
    fontSize: fontSize1 || 16,
    color: '#000',
    fontFamily: 'OpenSans-Bold',
    fontWeight: '700',
  },
  textStyle2: {
    fontSize: fontSize2 || 14,
    color: '#000',
    fontFamily: 'OpenSans-SemiBold',
    fontWeight: '600',
  },
});

const toastConfig = {
  primary: props => {
    const {fontSize1, fontSize2} = props.props || {};
    const styles = toastStyles(fontSize1, fontSize2);

    return (
      <BaseToast
        {...props}
        style={[styles.baseStyle, styles.primary]}
        text1Style={styles.textStyle1}
        text2Style={styles.textStyle2}
        text1NumberOfLines={2}
        text2NumberOfLines={10}
        topOffset={100}
      />
    );
  },
  success: props => {
    const {fontSize1, fontSize2} = props.props || {};
    const styles = toastStyles(fontSize1, fontSize2);
    return (
      <BaseToast
        {...props}
        style={[styles.baseStyle, styles.success]}
        text1Style={styles.textStyle1}
        text2Style={styles.textStyle2}
        text1NumberOfLines={2}
        text2NumberOfLines={10}
        topOffset={100}
      />
    );
  },
  info: props => {
    const {fontSize1, fontSize2} = props.props || {};
    const styles = toastStyles(fontSize1, fontSize2);
    return (
      <BaseToast
        {...props}
        style={[styles.baseStyle, styles.info]}
        text1Style={styles.textStyle1}
        text2Style={styles.textStyle2}
        text1NumberOfLines={2}
        text2NumberOfLines={10}
        topOffset={100}
      />
    );
  },
  warning: props => {
    const {fontSize1, fontSize2} = props.props || {};
    const styles = toastStyles(fontSize1, fontSize2);
    return (
      <BaseToast
        {...props}
        style={[styles.baseStyle, styles.warning]}
        text1Style={styles.textStyle1}
        text2Style={styles.textStyle2}
        text1NumberOfLines={2}
        text2NumberOfLines={10}
        topOffset={100}
      />
    );
  },
  danger: props => {
    const {fontSize1, fontSize2} = props.props || {};
    const styles = toastStyles(fontSize1, fontSize2);
    return (
      <BaseToast
        {...props}
        style={[styles.baseStyle, styles.danger]}
        text1Style={styles.textStyle1}
        text2Style={styles.textStyle2}
        text1NumberOfLines={2}
        text2NumberOfLines={10}
        topOffset={100}
      />
    );
  },
  error: props => {
    const {fontSize1, fontSize2} = props.props || {};
    const styles = toastStyles(fontSize1, fontSize2);
    return (
      <BaseToast
        {...props}
        style={[styles.baseStyle, styles.error]}
        text1Style={styles.textStyle1}
        text2Style={styles.textStyle2}
        text1NumberOfLines={2}
        text2NumberOfLines={10}
        topOffset={100}
      />
    );
  },
  dark: props => {
    const {fontSize1, fontSize2} = props.props || {};
    const styles = toastStyles(fontSize1, fontSize2);
    return (
      <BaseToast
        {...props}
        style={[styles.baseStyle, styles.dark]}
        text1Style={styles.textStyle1}
        text2Style={styles.textStyle2}
        text1NumberOfLines={2}
        text2NumberOfLines={10}
        topOffset={100}
      />
    );
  },
  basic: props => {
    const {fontSize1, fontSize2} = props.props || {};
    const styles = toastStyles(fontSize1, fontSize2);
    return (
      <BaseToast
        {...props}
        style={[styles.baseStyle, styles.basic]}
        text1Style={styles.textStyle1}
        text2Style={styles.textStyle2}
        text1NumberOfLines={2}
        text2NumberOfLines={10}
        topOffset={100}
      />
    );
  },
};

export default toastConfig;


--- FILE: src/KQ-UI/KQUtilities.jsx ---

//* KQUtilities.jsx
import {Platform} from 'react-native';
import {useDeviceInfo} from '../hooks/useHooks';

export const useColors = color => {
  if (!color || typeof color !== 'string') return '#000000'; // Default to black

  const colors = {
    black: '#000000',
    white: '#ffffff',
    //---
    primary10: '#8dd1bd',
    primary30: '#4ea68e',
    primary: '#29856c',
    primary70: '#198064',
    primary90: '#0a654c',
    //---
    success10: '#bae6c0',
    success30: '#91d299',
    success: '#63b76C',
    success70: '#3b9846',
    success90: '#1e7b29',
    //---
    info10: '#91daee',
    info30: '#02cfff',
    info: '#009DC4',
    info70: '#007590',
    info90: '#005b71',
    //---
    warning10: '#ffd29a',
    warning30: '#fdca78',
    warning: '#dda44b',
    warning70: '#c48726',
    warning90: '#9b6510',
    //---
    danger10: '#f596a5',
    danger30: '#ec5267',
    danger: '#da2c43',
    danger70: '#b51128',
    danger90: '#900014',
    //---
    orange10: '#ffc58d',
    orange30: '#f89656',
    orange: '#e5762e',
    orange70: '#bf5612',
    orange90: '#8c3b00',
    //---
    lilac10: '#dbd1ea',
    lilac30: '#beb2d5',
    lilac: '#9483b6',
    lilac70: '#6d5798',
    lilac90: '#4e3c75',
    //---
    dark10: '#373d431A',
    dark20: '#373d4333',
    dark30: '#373d434D',
    dark40: '#373d4366',
    dark50: '#373d4380',
    dark60: '#373d4399',
    dark70: '#373d43B3',
    dark80: '#373d43CC',
    dark90: '#373d43E6',
    dark: '#373d43',
    //---
    basic: '#C4C4C4',
    gold: '#FFAE42',
    transparent: 'transparent',
  };

  const normalizedColor = color.trim().toLowerCase();

  // If it's a predefined color, return it
  if (colors[normalizedColor]) {
    return colors[normalizedColor];
  }

  // If it's a valid hex or RGB(A) color, return it as is
  if (/^#([0-9A-F]{3}){1,2}$/i.test(color) || color.startsWith('rgb')) {
    return color;
  }

  return '#000000'; // Default fallback
};

const fontLookup = {
  // NotoSans mappings
  'noto-1': {
    ios: 'NotoSans',
    android: 'NotoSans-Thin',
    androidItalic: 'NotoSans-ThinItalic',
    weight: 100,
  },
  'noto-2': {
    ios: 'NotoSans',
    android: 'NotoSans-ExtraLight',
    androidItalic: 'NotoSans-ExtraLightItalic',
    weight: 200,
  },
  'noto-3': {
    ios: 'NotoSans',
    android: 'NotoSans-Light',
    androidItalic: 'NotoSans-LightItalic',
    weight: 300,
  },
  'noto-4': {
    ios: 'NotoSans',
    android: 'NotoSans-Regular',
    androidItalic: 'NotoSans-Italic',
    weight: 400,
  },
  'noto-5': {
    ios: 'NotoSans',
    android: 'NotoSans-Medium',
    androidItalic: 'NotoSans-MediumItalic',
    weight: 500,
  },
  'noto-6': {
    ios: 'NotoSans',
    android: 'NotoSans-SemiBold',
    androidItalic: 'NotoSans-SemiBoldItalic',
    weight: 600,
  },
  'noto-7': {
    ios: 'NotoSans',
    android: 'NotoSans-Bold',
    androidItalic: 'NotoSans-BoldItalic',
    weight: 700,
  },
  'noto-8': {
    ios: 'NotoSans',
    android: 'NotoSans-ExtraBold',
    androidItalic: 'NotoSans-ExtraBoldItalic',
    weight: 800,
  },
  'noto-9': {
    ios: 'NotoSans',
    android: 'NotoSans-Black',
    androidItalic: 'NotoSans-BlackItalic',
    weight: 900,
  },

  // Montserrat mappings
  'mont-1': {
    ios: 'Montserrat',
    android: 'Montserrat-Thin',
    androidItalic: 'Montserrat-ThinItalic',
    weight: 100,
  },
  'mont-2': {
    ios: 'Montserrat',
    android: 'Montserrat-ExtraLight',
    androidItalic: 'Montserrat-ExtraLightItalic',
    weight: 200,
  },
  'mont-3': {
    ios: 'Montserrat',
    android: 'Montserrat-Light',
    androidItalic: 'Montserrat-LightItalic',
    weight: 300,
  },
  'mont-4': {
    ios: 'Montserrat',
    android: 'Montserrat-Regular',
    androidItalic: 'Montserrat-Italic',
    weight: 400,
  },
  'mont-5': {
    ios: 'Montserrat',
    android: 'Montserrat-Medium',
    androidItalic: 'Montserrat-MediumItalic',
    weight: 500,
  },
  'mont-6': {
    ios: 'Montserrat',
    android: 'Montserrat-SemiBold',
    androidItalic: 'Montserrat-SemiBoldItalic',
    weight: 600,
  },
  'mont-7': {
    ios: 'Montserrat',
    android: 'Montserrat-Bold',
    androidItalic: 'Montserrat-BoldItalic',
    weight: 700,
  },
  'mont-8': {
    ios: 'Montserrat',
    android: 'Montserrat-ExtraBold',
    androidItalic: 'Montserrat-ExtraBoldItalic',
    weight: 800,
  },
  'mont-9': {
    ios: 'Montserrat',
    android: 'Montserrat-Black',
    androidItalic: 'Montserrat-BlackItalic',
    weight: 900,
  },

  // OpenSans mappings
  'open-3': {
    ios: 'OpenSans-Light',
    android: 'OpenSans-Light',
    androidItalic: 'OpenSans-LightItalic',
    weight: 300,
  },
  'open-4': {
    ios: 'OpenSans-Regular',
    android: 'OpenSans-Regular',
    androidItalic: 'OpenSans-Italic',
    weight: 400,
  },
  'open-5': {
    ios: 'OpenSans-Medium',
    android: 'OpenSans-Medium',
    androidItalic: 'OpenSans-MediumItalic',
    weight: 500,
  },
  'open-6': {
    ios: 'OpenSans-SemiBold',
    android: 'OpenSans-SemiBold',
    androidItalic: 'OpenSans-SemiBoldItalic',
    weight: 600,
  },
  'open-7': {
    ios: 'OpenSans-Bold',
    android: 'OpenSans-Bold',
    androidItalic: 'OpenSans-BoldItalic',
    weight: 700,
  },
  'open-8': {
    ios: 'OpenSans-ExtraBold',
    android: 'OpenSans-ExtraBold',
    androidItalic: 'OpenSans-ExtraBoldItalic',
    weight: 800,
  },

  // Special cases
  cherry: {
    ios: 'CherryBlossom',
    android: 'Cherry-Blossom',
    weight: 500,
  },
  banana: {
    ios: 'BananaChips-Regular',
    android: 'BananaChips-Regular',
    weight: 500,
    lineHeightFactor: 0.8,
  },
};

const DEFAULT_FONT = 'open-5';

export const useFonts = (font = DEFAULT_FONT, italic = false) => {
  const normalizedFont = font.trim().toLowerCase();
  const fontData = fontLookup[normalizedFont] || fontLookup[DEFAULT_FONT];

  if (Platform.OS === 'ios') {
    return {
      fontFamily: fontData.ios,
      fontWeight: fontData.weight,
      fontStyle: italic ? 'italic' : 'normal',
    };
  }

  return {
    fontFamily:
      italic && fontData.androidItalic
        ? fontData.androidItalic
        : fontData.android,
  };
};

export const useFontSizes = (size = 'medium', font = 'OpenSans') => {
  const device = useDeviceInfo();

  const getSizes = deviceSize => {
    const factorMap = {
      xSmall: 0.875,
      small: 0.9,
      medium: 0.925,
      large: 0.975,
      xLarge: 1,
    };

    const factor = factorMap[deviceSize] || 1;

    return {
      micro: 8 * factor,
      xTiny: 10 * factor,
      tiny: 12 * factor,
      xSmall: 14 * factor,
      small: 16 * factor,
      medium: 18 * factor,
      large: 20 * factor,
      xLarge: 24 * factor,
      giant: 28 * factor,
      massive: 36 * factor,
      gargantuan: 48 * factor,
    };
  };

  const deviceSize = device?.system?.deviceSize || 'xLarge';
  const sizes = getSizes(deviceSize);

  const fontScale = {
    cherry: 1.1,
    banana: 2,
  };

  const baseSize = sizes[size] || sizes.medium;
  const scaleFactor = fontScale[font.toLowerCase()] || 1;

  return {fontSize: baseSize * scaleFactor};
};

export const useFontStyles = (
  font = 'open-5',
  size = 'medium',
  color = 'black',
  italic = false,
) => {
  return {
    ...useFonts(font, italic),
    ...useFontSizes(size, font),
    color: useColors(color),
  };
};

export const useButtonStyles = (type = 'filled', color = 'primary') => {
  const statusColor = useColors(color);

  const styles = {
    filled: {
      backgroundColor: statusColor,
      elevation: 4,
      shadowColor: '#373d43',
      shadowOffset: {width: 2, height: 3},
      shadowOpacity: 0.3,
    },
    outline: {
      backgroundColor: 'transparent',
      borderColor: statusColor,
      borderWidth: 2,
    },
    ghost: {
      backgroundColor: 'transparent',
    },
  };

  return styles[type] || styles.filled;
};

export const useButtonSizes = (size = 'medium') => {
  const sizes = {
    macro: 15,
    micro: 20,
    xTiny: 25,
    tiny: 30,
    small: 35,
    medium: 40,
    large: 50,
    xLarge: 60,
    giant: 70,
    massive: 80,
    gargantuan: 90,
  };

  return {
    height: sizes[size] ?? sizes.medium,
    paddingHorizontal: 12,
  };
};


--- FILE: src/KQ-UI/KQView.jsx ---

//* KQView.jsx
import React, {useMemo} from 'react';
import {View} from 'react-native';

const spacingKeys = [
  'm',
  'ml',
  'mr',
  'mt',
  'mb',
  'mh',
  'mv',
  'p',
  'pl',
  'pr',
  'pt',
  'pb',
  'ph',
  'pv',
];
const spacingValues = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];

const getSpacingProps = props => {
  const result = {};

  spacingKeys.forEach(key => {
    spacingValues.forEach(val => {
      const propName = `${key}${val}`;
      if (props[propName]) {
        result[key] = val;
      }
    });
  });

  return result;
};

const parseSpacing = prop => {
  if (typeof prop === 'number') return prop;
  const valid = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
  return valid.includes(prop) ? prop : undefined;
};

const KQView = ({
  row,
  column,
  flex,
  centerV = false,
  centerH = false,
  centerVH = false,
  rightAlign = false,
  bottomAlign = false,
  topAlign = false,
  border = false,
  borderWidth = 1,
  borderColor = 'black',

  // Margin and padding (numeric or shorthand)
  m,
  ml,
  mr,
  mt,
  mb,
  mh,
  mv,
  p,
  pl,
  pr,
  pt,
  pb,
  ph,
  pv,

  style = {},
  children,
  ...props
}) => {
  const shorthand = getSpacingProps(props);

  const computedStyle = useMemo(() => {
    const s = {};

    if (row) s.flexDirection = 'row';
    if (column) s.flexDirection = 'column';
    if (flex !== undefined) s.flex = flex === true ? 1 : flex;
    if (border) s.borderWidth = borderWidth;
    if (borderColor) s.borderColor = borderColor;

    if (centerVH) {
      s.justifyContent = 'center';
      s.alignItems = 'center';
    } else {
      if (centerV) s.justifyContent = 'center';
      if (centerH) {
        s.alignItems = 'center';
        s.alignContent = 'center';
      }
    }

    if (rightAlign) {
      s.alignItems = 'flex-end';
      s.alignContent = 'flex-end';
    }

    if (bottomAlign) {
      s.justifyContent = 'flex-end';
    }

    if (topAlign) {
      s.justifyContent = 'flex-start';
    }

    // Merge explicit + shorthand spacing
    const final = {
      m: m ?? shorthand.m,
      ml: ml ?? shorthand.ml,
      mr: mr ?? shorthand.mr,
      mt: mt ?? shorthand.mt,
      mb: mb ?? shorthand.mb,
      mh: mh ?? shorthand.mh,
      mv: mv ?? shorthand.mv,
      p: p ?? shorthand.p,
      pl: pl ?? shorthand.pl,
      pr: pr ?? shorthand.pr,
      pt: pt ?? shorthand.pt,
      pb: pb ?? shorthand.pb,
      ph: ph ?? shorthand.ph,
      pv: pv ?? shorthand.pv,
    };

    // Margin
    if (final.m !== undefined) s.margin = parseSpacing(final.m);
    if (final.ml !== undefined) s.marginLeft = parseSpacing(final.ml);
    if (final.mr !== undefined) s.marginRight = parseSpacing(final.mr);
    if (final.mt !== undefined) s.marginTop = parseSpacing(final.mt);
    if (final.mb !== undefined) s.marginBottom = parseSpacing(final.mb);
    if (final.mh !== undefined) {
      s.marginLeft = parseSpacing(final.mh);
      s.marginRight = parseSpacing(final.mh);
    }
    if (final.mv !== undefined) {
      s.marginTop = parseSpacing(final.mv);
      s.marginBottom = parseSpacing(final.mv);
    }

    // Padding
    if (final.p !== undefined) s.padding = parseSpacing(final.p);
    if (final.pl !== undefined) s.paddingLeft = parseSpacing(final.pl);
    if (final.pr !== undefined) s.paddingRight = parseSpacing(final.pr);
    if (final.pt !== undefined) s.paddingTop = parseSpacing(final.pt);
    if (final.pb !== undefined) s.paddingBottom = parseSpacing(final.pb);
    if (final.ph !== undefined) {
      s.paddingLeft = parseSpacing(final.ph);
      s.paddingRight = parseSpacing(final.ph);
    }
    if (final.pv !== undefined) {
      s.paddingTop = parseSpacing(final.pv);
      s.paddingBottom = parseSpacing(final.pv);
    }

    return s;
  }, [
    row,
    column,
    flex,
    centerV,
    centerH,
    centerVH,
    rightAlign,
    m,
    ml,
    mr,
    mt,
    mb,
    mh,
    mv,
    p,
    pl,
    pr,
    pt,
    pb,
    ph,
    pv,
    props,
  ]);

  return (
    <View style={[computedStyle, style]} {...props}>
      {children}
    </View>
  );
};

export default KQView;


--- FILE: src/KQ-UI/index.js ---

//* index.js (KQ-UI)
export {default as View} from './KQView';
export {default as Text} from './KQText';
export {default as BottomSheet} from './KQBottomSheet';
export {default as Toast} from './KQToast';
export {default as Layout} from './KQLayout';
export {default as Modal} from './KQModal';
export {default as Button} from './KQButton';
export {default as Input} from './KQInput';
export {default as Dropdown} from './KQDropdown';
export {default as MultiDropdown} from './KQMultiDropDown';
export {default as ScrollView} from './KQScrollView';
export {default as Image} from './KQImage';
export {default as Camera} from './KQCamera';


--- FILE: src/components/Avatar.jsx ---

//* Avatar.jsx
import React, {useMemo} from 'react';
import {SvgXml} from 'react-native-svg';
import {createAvatar} from '@dicebear/core';
import {avataaars} from '@dicebear/collection';
import {View} from 'react-native';
import {
  bgColorOptions,
  colorOptions,
  facialHairOptions,
  glassesOptions,
  graphicOptions,
  hairColorOptions,
  hairStyleOptions,
  shirtOptions,
  skinColorOptions,
} from '../utilities/avatarOptions';

function Avatar({
  profilePicture = {},
  avatarOptions,
  isEditing,
  cardStyles,
  viewStyles,
}) {
  const mapToString = useMemo(() => {
    const source = isEditing ? avatarOptions : profilePicture;

    return {
      backgroundColor:
        bgColorOptions[source?.bgColor] || source?.backgroundColor || '009DC4',
      accessories: glassesOptions[source?.glasses] || source?.accessories || '',
      accessoriesColor:
        colorOptions[source?.glassesColor] ||
        source?.accessoriesColor ||
        '373D43',
      clothesColor:
        colorOptions[source?.shirtColor] || source?.clothesColor || '373D43',
      clothing:
        shirtOptions[source?.shirtStyle] || source?.clothing || 'graphicShirt',
      clothingGraphic: graphicOptions[source?.clothingGraphic] || '',
      facialHair: isEditing
        ? facialHairOptions[source?.facialHair]
        : source?.facialHair || '',
      facialHairColor: isEditing
        ? hairColorOptions[source?.hairColor]
        : source?.facialHairColor || '1C1C1C',
      hairColor: isEditing
        ? hairColorOptions[source?.hairColor]
        : source?.hairColor || '6B4B31',
      skinColor: isEditing
        ? skinColorOptions[source?.skinColor]
        : source?.skinColor || 'F3B28C',
      top: hairStyleOptions[source?.hairStyle] || source?.top || 'shortFlat',
    };
  }, [avatarOptions, profilePicture, isEditing]);

  const buildAvatar = useMemo(() => {
    return createAvatar(avataaars, {
      scale: 90,
      translateY: 9,
      randomizeIds: true,
      backgroundColor: [mapToString.backgroundColor],
      accessories: [mapToString.accessories],
      accessoriesColor: [mapToString.accessoriesColor],
      accessoriesProbability: 100,
      clothesColor: [mapToString.clothesColor],
      clothing: [mapToString.clothing],
      clothingGraphic: [mapToString.clothingGraphic],
      eyebrows: ['default'],
      eyes: ['default'],
      facialHair: [mapToString.facialHair],
      facialHairColor: [mapToString.facialHairColor],
      facialHairProbability: 100,
      hairColor: [mapToString.hairColor],
      mouth: ['smile'],
      skinColor: [mapToString.skinColor],
      top: [mapToString.top],
    }).toString();
  }, [mapToString]);

  return (
    <View style={[AvatarStyles.avatarCard, cardStyles]}>
      <View style={[AvatarStyles.avatarView, viewStyles]}>
        <SvgXml xml={buildAvatar} />
      </View>
    </View>
  );
}

const AvatarStyles = {
  avatarCard: {
    // width: 80,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'transparent',
  },
  avatarView: {
    width: 80,
    height: 80,
    borderWidth: 1,
    borderRadius: 50,
    overflow: 'hidden',
  },
};

export default __DEV__ ? Avatar : React.memo(Avatar);


--- FILE: src/components/BuildAvatar.jsx ---

//* BuildAvatar.jsx
import React, {useMemo} from 'react';
import {createAvatar} from '@dicebear/core';
import {avataaars} from '@dicebear/collection';
import {useAllowedProfiles, useDeviceInfo, useProfile} from '../hooks/useHooks';
import Avatar from './Avatar';
import {View} from 'react-native';
import {Text} from '../KQ-UI';
import {TouchableOpacity} from 'react-native';
import {SvgXml} from 'react-native-svg';

const BuildAvatar = props => {
  const {setShowModal} = props;
  const device = useDeviceInfo();
  const profile = useProfile();
  const isOwner = profile?.role === 'owner';
  const allowedProfiles = useAllowedProfiles();

  const blankAvatar = createAvatar(avataaars, {
    scale: 90,
    translateY: 9,
    randomizeIds: true,
    backgroundColor: ['eeeeee'],
    accessories: [''],
    accessoriesColor: [''],
    accessoriesProbability: 100,
    clothesColor: ['666666'],
    clothing: ['graphicShirt'],
    clothingGraphic: [''],
    eyebrows: [''],
    eyes: [''],
    facialHair: [''],
    facialHairColor: [''],
    facialHairProbability: 100,
    hairColor: [''],
    mouth: [''],
    skinColor: ['c4c4c4'],
    top: [''],
  }).toString();

  const customAvatarWidth = useMemo(() => {
    switch (device?.system?.deviceSize) {
      case 'small':
        return {height: 70, width: 70};
      case 'medium':
        return {height: 75, width: 75};
      case 'large':
        return {height: 80, width: 80};
      case 'xLarge':
        return {height: 85, width: 85};
      default:
        return {height: 85, width: 85};
    }
  }, [device?.system?.deviceSize]);

  const showAddAvatar = isOwner && allowedProfiles?.length < 4;

  const avatars = allowedProfiles?.map((profile, index) => (
    <View key={`profile-${index}`} style={AvatarStyles.avatarCard}>
      {/* <TouchableOpacity onPress={() => kqconsole.log('View Profile')}> */}
      <Avatar
        profilePicture={profile?.pictureURL}
        viewStyles={customAvatarWidth}
      />
      {/* </TouchableOpacity> */}
      <View style={AvatarStyles.avatarTitle}>
        <Text size="xSmall" font="open-7">
          {profile?.firstName}
        </Text>
        <Text size="tiny">({profile?.role})</Text>
      </View>
    </View>
  ));

  const addAvatar = (
    <View key="add-avatar" style={AvatarStyles.avatarCard}>
      <TouchableOpacity onPress={() => setShowModal(true)}>
        <View style={[AvatarStyles.avatarView, customAvatarWidth]}>
          <SvgXml xml={blankAvatar} />
        </View>
      </TouchableOpacity>
      <View style={AvatarStyles.avatarTitle}>
        <Text size="xSmall">Add</Text>
        <Text size="tiny">User</Text>
      </View>
    </View>
  );

  return [...avatars, ...(showAddAvatar ? [addAvatar] : [])];
};

const AvatarStyles = {
  avatarCard: {
    paddingTop: 15,
    paddingBottom: 10,
    paddingHorizontal: 5,
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatarTitle: {
    paddingTop: 2,
    alignItems: 'center',
  },
  avatarView: {
    width: 100,
    height: 100,
    borderWidth: 1,
    borderRadius: 50,
    overflow: 'hidden',
  },
};

export default React.memo(BuildAvatar);


--- FILE: src/components/CurvedBottomBar.jsx ---

//*CurvedBottomBar.jsx
import React from 'react';
import Svg, {
  Path,
  Defs,
  Filter,
  FeOffset,
  FeGaussianBlur,
  FeMerge,
  FeMergeNode,
} from 'react-native-svg';

const CurvedBottomBar = props => {
  const {
    width = width || 500,
    height = height || 60,
    fill = fill || '#fff',
    stroke = stroke || '#373d4370',
    strokeWidth = strokeWidth || 1,
    shadowStroke = shadowStroke || '#373d4360',
    shadowStrokeWidth = shadowStrokeWidth || 2,
  } = props;

  const startX = 0;
  const endX = width - 0;
  const topY = 2;
  const bottomY = height;

  const leftCurveStartX = width / 2 - 65;
  const leftCurveEndX = width / 2 - 30;
  const rightCurveStartX = width / 2 + 30;
  const rightCurveEndX = width / 2 + 65;

  const d = `
  M ${startX},${bottomY}
  L ${startX},20
  C ${startX},20 ${topY},${topY} 25,${topY}
  L ${leftCurveStartX},${topY}
  C ${leftCurveStartX},${topY} ${width / 2 - 40},${topY} ${leftCurveEndX},25
  C ${width / 2 - 25},38 ${width / 2 - 15},44 ${width / 2},44
  C ${width / 2 + 15},44 ${width / 2 + 25},38 ${rightCurveStartX},25
  C ${width / 2 + 40},${topY} ${rightCurveEndX},${topY} ${rightCurveEndX},${topY}
  L ${endX - 20},${topY}
  C ${endX - 25},${topY} ${endX - 2},${topY} ${endX},20
  L ${endX},${bottomY}`;

  return (
    <Svg width={width} height={height}>
      <Defs>
        <Filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
          <FeOffset dx="0" dy="3" />
          <FeGaussianBlur stdDeviation="3" result="blurred" />
          <FeMerge>
            <FeMergeNode in="blurred" />
            <FeMergeNode in="SourceGraphic" />
          </FeMerge>
        </Filter>
      </Defs>

      <Path
        d={d}
        fill="none"
        stroke={shadowStroke}
        strokeWidth={shadowStrokeWidth}
        filter="url(#shadow)"
      />

      <Path d={d} fill={fill} stroke={stroke} strokeWidth={strokeWidth} />
    </Svg>
  );
};

export default CurvedBottomBar;


--- FILE: src/components/EdamanBadge.jsx ---

//* EdamamBadge.jsx

import React from 'react';
import Svg, {Path, G, Ellipse, Style} from 'react-native-svg';

const EdamamAttribution = ({width = 400, height = 80}) => {
  const path1 = `M224.9,42.5h-12.3c-0.8,0-1.4,0.1-1.4,0.9v7.5c0,0.8,0.6,1.4,1.4,1.4H225c0.8,0,1.4,0.6,1.4,1.4V54
			c0,0.8-0.6,1.4-1.4,1.4h-16.3c-0.8,0-1.4-0.6-1.4-0.9V28.4c0-1.3,0.6-1.9,1.4-1.9h16.1c0.8,0,1.4,0.6,1.4,1.4v0.2
			c0,0.8-0.6,1.4-1.4,1.4h-12.2c-0.8,0-1.4,0.6-1.4,1.4v7c0,0.8,0.6,1.4,1.4,1.4h12.3c0.8,0,1.4,0.6,1.4,1.4v0.2
			C226.3,41.8,225.7,42.5,224.9,42.5z`;
  const path2 = `M232.3,54V27.9c0-0.8,0.6-1.4,1.4-1.4h7.4c3.8,0,6.8,1.2,9.1,3.5c2.3,2.3,3.4,5.3,3.4,9v4
			c0,3.7-1.1,6.7-3.4,9c-2.3,2.3-5.3,3.5-9.1,3.5h-7.4C232.9,55.4,232.3,54.8,232.3,54z M236.2,31v19.9c0,0.8,0.6,1.4,1.4,1.4h3.5
			c2.7,0,4.8-0.9,6.3-2.6c1.5-1.8,2.3-4,2.3-6.8v-4c0-2.7-0.8-5-2.3-6.7c-1.5-1.8-3.7-2.6-6.3-2.6h-3.5
			C236.9,29.5,236.2,30.2,236.2,31z`;
  const path3 = `M274.6,48h-10.1c-0.6,0-1.1,0.4-1.4,0.9l-2,5.6c-0.2,0.6-0.7,0.9-1.4,0.9h-0.9c-1,0-1.7-1-1.3-2l10.1-26.1
			c0.2-0.6,0.7-0.9,1.3-0.9h1.4c0.6,0,1.1,0.4,1.3,0.9l9.9,26.1c0.4,0.9-0.3,2-1.3,2h-0.9c-0.6,0-1.1-0.4-1.4-1l-2-5.6
			C275.7,48.3,275.2,48,274.6,48z M266.7,44.7h5.6c1,0,1.7-1,1.4-1.9l-4.1-11.2h-0.1l-4.1,11.2C265,43.7,265.7,44.7,266.7,44.7z`;
  const path4 = `M291.5,26.5c0.6,0,1.1,0.4,1.3,0.9l8.9,22.6h0.1l8.9-22.6c0.2-0.6,0.7-0.9,1.3-0.9h2.6c0.8,0,1.4,0.6,1.4,1.4
			V54c0,0.8-0.6,1.4-1.4,1.4h-1c-0.8,0-1.4-0.6-1.4-1.4V44l0.4-11.8l-0.1,0l-9,22.3c-0.2,0.5-0.7,0.9-1.3,0.9h-0.7
			c-0.6,0-1.1-0.4-1.3-0.9l-9-22.3l-0.1,0l0.4,11.7v10c0,0.8-0.6,1.4-1.4,1.4h-1c-0.8,0-1.4-0.6-1.4-1.4V27.9c0-0.8,0.6-1.4,1.4-1.4
			H291.5z`;
  const path5 = `M339.5,48h-10.1c-0.6,0-1.1,0.4-1.4,0.9l-2,5.6c-0.2,0.6-0.7,0.9-1.4,0.9h-0.9c-1,0-1.7-1-1.3-2l10.1-26.1
			c0.2-0.6,0.7-0.9,1.3-0.9h1.4c0.6,0,1.1,0.4,1.3,0.9l9.9,26.1c0.4,0.9-0.3,2-1.3,2h-0.9c-0.6,0-1.1-0.4-1.4-1l-2-5.6
			C340.7,48.3,340.1,48,339.5,48z M331.7,44.7h5.6c1,0,1.7-1,1.4-1.9l-4.1-11.2h-0.1l-4.1,11.2C330,43.7,330.7,44.7,331.7,44.7z`;
  const path6 = `M356.4,26.5c0.6,0,1.1,0.4,1.3,0.9l8.9,22.6h0.1l8.9-22.6c0.2-0.6,0.7-0.9,1.3-0.9h2.6c0.8,0,1.4,0.6,1.4,1.4
			V54c0,0.8-0.6,1.4-1.4,1.4h-1c-0.8,0-1.4-0.6-1.4-1.4V44l0.4-11.8l-0.1,0l-9,22.3c-0.2,0.5-0.7,0.9-1.3,0.9h-0.7
			c-0.6,0-1.1-0.4-1.3-0.9l-9-22.3l-0.1,0l0.4,11.7v10c0,0.8-0.6,1.4-1.4,1.4h-1c-0.8,0-1.4-0.6-1.4-1.4V27.9c0-0.8,0.6-1.4,1.4-1.4
			H356.4z`;
  const path7 = `M178.7,29.5h-22.3c-0.7,0-1.3-0.6-1.3-1.3v-0.6c0-0.7,0.6-1.3,1.3-1.3h22.3c0.7,0,1.3,0.6,1.3,1.3v0.6
			C180,29,179.4,29.5,178.7,29.5z`;
  const path8 = `M178.7,42.5h-22.3c-0.7,0-1.3-0.6-1.3-1.3v-0.5c0-0.7,0.6-1.3,1.3-1.3h22.3c0.7,0,1.3,0.6,1.3,1.3v0.5
			C180,41.9,179.4,42.5,178.7,42.5z`;
  const path9 = `M178.7,55.4h-22.3c-0.7,0-1.3-0.6-1.3-1.3v-0.6c0-0.7,0.6-1.3,1.3-1.3h22.3c0.7,0,1.3,0.6,1.3,1.3v0.6
			C180,54.9,179.4,55.4,178.7,55.4z`;
  const path10 = `M162.9,36h-6.4c-0.7,0-1.3-0.6-1.3-1.3v-0.5c0-0.7,0.6-1.3,1.3-1.3h6.4c0.7,0,1.3,0.6,1.3,1.3v0.5
			C164.2,35.4,163.6,36,162.9,36z`;
  const path11 = `M163.1,49h-6.5c-0.7,0-1.3-0.6-1.3-1.3v-0.6c0-0.7,0.6-1.3,1.3-1.3h6.5c0.7,0,1.3,0.6,1.3,1.3v0.6
			C164.3,48.4,163.8,49,163.1,49z`;
  const path12 = `M23.5,50.4v4.2h-2V43.2h4.4c1.3,0,2.3,0.3,3,1c0.7,0.7,1.1,1.5,1.1,2.6c0,1.1-0.4,2-1.1,2.6
			c-0.7,0.6-1.8,0.9-3.1,0.9H23.5z M23.5,48.8h2.4c0.7,0,1.2-0.2,1.6-0.5c0.4-0.3,0.6-0.8,0.6-1.4c0-0.6-0.2-1.1-0.6-1.5
			s-0.9-0.6-1.5-0.6h-2.4V48.8z`;
  const path13 = `M42,49.2c0,1.1-0.2,2.1-0.6,2.9c-0.4,0.8-0.9,1.5-1.7,1.9c-0.7,0.5-1.5,0.7-2.5,0.7c-0.9,0-1.7-0.2-2.5-0.7
			c-0.7-0.5-1.3-1.1-1.7-1.9c-0.4-0.8-0.6-1.8-0.6-2.9v-0.6c0-1.1,0.2-2.1,0.6-2.9c0.4-0.8,0.9-1.5,1.7-1.9c0.7-0.5,1.5-0.7,2.5-0.7
			c0.9,0,1.7,0.2,2.5,0.7c0.7,0.4,1.3,1.1,1.7,1.9s0.6,1.8,0.6,2.9V49.2z M40,48.6c0-1.3-0.2-2.2-0.7-2.9s-1.2-1-2-1
			c-0.9,0-1.5,0.3-2,1c-0.5,0.7-0.7,1.6-0.7,2.8v0.7c0,1.2,0.2,2.2,0.7,2.9c0.5,0.7,1.2,1,2,1c0.9,0,1.5-0.3,2-1
			c0.5-0.7,0.7-1.6,0.7-2.9V48.6z`;
  const path14 = `M54.1,51.8l1.8-8.6h2l-2.6,11.4h-1.9l-2.2-8.3l-2.2,8.3H47l-2.6-11.4h2l1.8,8.5l2.2-8.5h1.7L54.1,51.8z`;
  const path15 = `M67.1,49.5h-4.7V53h5.5v1.6h-7.4V43.2h7.4v1.6h-5.4V48h4.7V49.5z`;
  const path16 = `M74.9,50.2h-2.2v4.4h-2V43.2h4c1.3,0,2.3,0.3,3,0.9c0.7,0.6,1.1,1.4,1.1,2.6c0,0.8-0.2,1.4-0.6,1.9
			c-0.4,0.5-0.9,0.9-1.5,1.2l2.6,4.7v0.1h-2.1L74.9,50.2z M72.7,48.6h2c0.7,0,1.2-0.2,1.6-0.5s0.6-0.8,0.6-1.4
			c0-0.6-0.2-1.1-0.5-1.4c-0.3-0.3-0.9-0.5-1.6-0.5h-2.1V48.6z`;
  const path17 = `M88.5,49.5h-4.7V53h5.5v1.6h-7.4V43.2h7.4v1.6h-5.4V48h4.7V49.5z`;
  const path18 = `M92.1,54.6V43.2h3.4c1,0,1.9,0.2,2.7,0.7c0.8,0.4,1.4,1.1,1.8,1.9c0.4,0.8,0.6,1.8,0.6,2.8v0.6
			c0,1.1-0.2,2-0.6,2.8s-1,1.4-1.8,1.9c-0.8,0.4-1.7,0.7-2.7,0.7H92.1z M94.1,44.8V53h1.3c1,0,1.8-0.3,2.4-1s0.8-1.6,0.8-2.8v-0.6
			c0-1.2-0.3-2.2-0.8-2.8c-0.5-0.7-1.3-1-2.3-1H94.1z`;
  const path19 = `M108.9,54.6V43.2h3.9c1.3,0,2.3,0.3,2.9,0.8s1,1.3,1,2.3c0,0.5-0.1,1-0.4,1.4s-0.7,0.7-1.2,1
			c0.6,0.2,1.1,0.5,1.4,0.9s0.5,1,0.5,1.7c0,1.1-0.3,1.9-1,2.5c-0.7,0.6-1.7,0.9-2.9,0.9H108.9z M110.9,48h1.9
			c0.6,0,1.1-0.1,1.4-0.4c0.3-0.3,0.5-0.7,0.5-1.2c0-0.6-0.2-1-0.5-1.2s-0.8-0.4-1.5-0.4h-1.9V48z M110.9,49.5V53h2.2
			c0.6,0,1.1-0.2,1.5-0.5c0.3-0.3,0.5-0.7,0.5-1.3c0-1.2-0.6-1.8-1.8-1.8H110.9z`;
  const path20 = `M123.5,48.6l2.6-5.4h2.2l-3.8,7.2v4.2h-2v-4.2l-3.8-7.2h2.2L123.5,48.6z`;

  return (
    <Svg
      xmlns="http://www.w3.org/2000/svg"
      xmlnsXlink="http://www.w3.org/1999/xlink"
      viewBox="0 0 400 80"
      width={width}
      height={height}>
      <G id="Layer_1"></G>
      <G id="Layer_2">
        <G>
          <Path d={path1} fill="#77CC00" />
          <Path d={path2} fill="#77CC00" />
          <Path d={path3} fill="#77CC00" />
          <Path d={path4} fill="#77CC00" />
          <Path d={path5} fill="#77CC00" />
          <Path d={path6} fill="#77CC00" />
        </G>
        <Ellipse cx="167.6" cy="40.9" rx="28.6" ry="28.6" fill="#77CC00" />
        <G>
          <Path d={path7} fill="#F4F7FA" />
          <Path d={path8} fill="#F4F7FA" />
          <Path d={path9} fill="#F4F7FA" />
          <Path d={path10} fill="#F4F7FA" />
          <Path d={path11} fill="#F4F7FA" />
        </G>
      </G>
      <G id="Layer_3">
        <G>
          <Path d={path12} fill="#929497" />
          <Path d={path13} fill="#929497" />
          <Path d={path14} fill="#929497" />
          <Path d={path15} fill="#929497" />
          <Path d={path16} fill="#929497" />
          <Path d={path17} fill="#929497" />
          <Path d={path18} fill="#929497" />
          <Path d={path19} fill="#929497" />
          <Path d={path20} fill="#929497" />
        </G>
      </G>
    </Svg>
  );
};

export default EdamamAttribution;


--- FILE: src/components/FlashCell.jsx ---

//* FlashCell.jsx
import React from 'react';
import {Pressable, View} from 'react-native';
import {Text} from '../KQ-UI';
import {
  displayMeasurements,
  formatMeasurement,
} from '../utilities/measurements';
import pluralize from 'pluralize';
import {Icons} from './IconListRouter';
import {useColors} from '../KQ-UI/KQUtilities';
import {formatMeasurementWithPlural} from '../utilities/helpers';

const FlashCell = props => {
  const {
    item,
    core,
    setShowItemInfo,
    setSelectedItem,
    favoritesView,
    groupedView,
    noQuantity,
  } = props;

  const defaultFlashCellOrder = [
    {index: 0, key: 'brandName', label: 'Brand Name'},
    {index: 1, key: 'description', label: 'Description'},
    {index: 2, key: 'itemName', label: 'Item Name'},
  ];

  const renderDisplayText = item => {
    const flashCellOrder =
      core?.userSettings?.flashCellOrder || defaultFlashCellOrder;
    const displayText = flashCellOrder
      .map(field => item[field.key])
      .filter(Boolean)
      .join(' ');

    return displayText || item.itemName;
  };

  const displayRemaining = (packageSize, remainingAmount) => {
    let percent = (remainingAmount / packageSize) * 100;
    return ` (${percent.toFixed(0)}% left)`;
  };

  const LeftDataDisplay = () => {
    if (noQuantity && !favoritesView && !groupedView) return null;

    if (favoritesView && !groupedView) {
      return (
        <View style={styles.favWrapper}>
          <View style={styles.favContainer}>
            <Icons.Favorite size={30} color={useColors('gold')} />
          </View>
        </View>
      );
    }

    if (!favoritesView && (groupedView || !noQuantity)) {
      return (
        <View style={styles.dataWrapper}>
          <View style={styles.qtyContainer}>
            <View style={styles.qtyTop}>
              <Text size="tiny">Qty</Text>
            </View>
            <View style={styles.qtyBottom}>
              <Text size="medium" numberOfLines={1}>
                {item.quantity || item.count}
              </Text>
            </View>
          </View>
        </View>
      );
    }
    return null;
  };

  const InfoDisplay = () => {
    return (
      <View style={styles.display}>
        <Text numberOfLines={1} size="small" font="open-7">
          {renderDisplayText(item)}
        </Text>
        <Text size="xSmall" numberOfLines={1}>
          {formatMeasurementWithPlural(
            item.packageSize,
            item.quantity,
            item.measurement,
            item.itemName,
          )}
          {item?.remainingAmount &&
            displayRemaining(item.packageSize, item.remainingAmount)}
        </Text>
      </View>
    );
  };

  const SlideDisplay = () => {
    if (groupedView) {
      return null;
    }
    return (
      <View style={styles.slideWrapper}>
        <View style={styles.slideLeft}>
          <Icons.ChevronLeft color="#373d4390" />
        </View>
        <View style={styles.slideRight}>
          <Icons.ChevronLeft color="#373d4390" />
        </View>
      </View>
    );
  };

  return (
    <Pressable
      onPress={() => {
        setSelectedItem(item);
        setShowItemInfo(true);
      }}>
      <View style={styles.cellContainer}>
        <LeftDataDisplay />
        <InfoDisplay />
        <SlideDisplay />
      </View>
    </Pressable>
  );
};

const styles = {
  cellContainer: {
    borderBottomWidth: 1,
    borderColor: '#373d4380',
    flexDirection: 'row',
    marginLeft: 10,
    marginRight: 10,
    height: 65,
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  dataWrapper: {
    height: 60,
    width: 60,
    justifyContent: 'center',
    alignItems: 'center',
  },
  favWrapper: {
    height: 45,
    width: 45,
    justifyContent: 'center',
    alignItems: 'center',
  },
  favContainer: {
    // borderWidth: 2,
    // borderColor: '#373d4380',
    // borderRadius: 50,
    // elevation: 4,
    // shadowColor: '#373d4380',
    // shadowOffset: {width: 0, height: 1},
    // shadowOpacity: 0.2,
    backgroundColor: '#fff',
    justifyContent: 'center',
    alignItems: 'center',
  },
  qtyContainer: {
    width: 50,
    height: 50,
    borderWidth: 1.25,
    borderColor: '#373d4380',
    borderRadius: 8,
    flexDirection: 'column',
    elevation: 4,
    shadowColor: '#373d4380',
    shadowOffset: {width: 0, height: 1},
    shadowOpacity: 0.2,
    backgroundColor: '#fff',
  },
  qtyTop: {
    alignItems: 'center',
    paddingTop: 2,
  },
  qtyBottom: {
    flex: 1,
    alignItems: 'center',
    paddingBottom: 1,
  },
  display: {flex: 1, justifyContent: 'center', marginLeft: 5},
  slideWrapper: {
    width: 35,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
  },
  slideLeft: {position: 'absolute', left: 6},
  slideRight: {position: 'absolute', left: 12},
};

export default __DEV__ ? FlashCell : React.memo(FlashCell);


--- FILE: src/components/IconListRouter.jsx ---

//*IconListRouter.jsx
import ADIcons from 'react-native-vector-icons/AntDesign';
import FAIcons from 'react-native-vector-icons/FontAwesome';
import FA5Icons from 'react-native-vector-icons/FontAwesome5';
import MCIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import MIIcons from 'react-native-vector-icons/MaterialIcons';
import IIcons from 'react-native-vector-icons/Ionicons';
import EIcons from 'react-native-vector-icons/Entypo';
import FIcons from 'react-native-vector-icons/Fontisto';
import FEIcons from 'react-native-vector-icons/Feather';
import SIIcons from 'react-native-vector-icons/SimpleLineIcons';
import OctIcons from 'react-native-vector-icons/Octicons';
import ZOIcons from 'react-native-vector-icons/Zocial';
import {Keyboard} from 'react-native';

export const Icons = {
  Account: props => (
    <MCIcons name="account-circle" size={20} color="#000" {...props} />
  ),
  AdminEdit: props => (
    <MCIcons name="shield-lock-outline" size={20} color="#000" {...props} />
  ),
  AddList: props => (
    <MCIcons name="playlist-plus" size={20} color="#000" {...props} />
  ),
  Back: props => (
    <MIIcons name="arrow-back-ios" size={20} color="#000" {...props} />
  ),
  Barcode: props => (
    <FAIcons name="barcode" size={20} color="#000" {...props} />
  ),

  BookmarkPlus: props => (
    <MCIcons name="bookmark-plus-outline" size={20} color="#000" {...props} />
  ),
  BookmarkMinus: props => (
    <MCIcons name="bookmark-remove-outline" size={20} color="#000" {...props} />
  ),
  Camera: props => <FEIcons name="camera" size={20} color="#000" {...props} />,
  Check: props => <FA5Icons name="check" size={20} color="#000" {...props} />,
  CheckFilledCircle: props => (
    <OctIcons name="check-circle-fill" size={20} color="#000" {...props} />
  ),
  Dot: props => <MCIcons name="circle" size={20} color="#000" {...props} />,
  EmptyCircle: props => (
    <OctIcons name="circle" size={20} color="#000" {...props} />
  ),
  XCircle: props => (
    <OctIcons name="x-circle-fill" size={20} color="#000" {...props} />
  ),
  XCircleOutline: props => (
    <OctIcons name="x-circle" size={20} color="#000" {...props} />
  ),
  Chest: props => (
    <MCIcons name="treasure-chest" size={20} color="#000" {...props} />
  ),
  ChevronDown: props => (
    <FEIcons name="chevron-down" size={20} color="#000" {...props} />
  ),

  ChevronUp: props => (
    <FEIcons name="chevron-up" size={20} color="#000" {...props} />
  ),
  ChevronLeft: props => (
    <FEIcons name="chevron-left" size={20} color="#000" {...props} />
  ),
  CirclePlus: props => (
    <ADIcons name="pluscircleo" size={20} color="#000" {...props} />
  ),
  Close: props => <MCIcons name="close" size={20} color="#000" {...props} />,
  Cupboards: props => (
    <MCIcons name="wardrobe" size={20} color="#000" {...props} />
  ),
  Dev: props => <MCIcons name="dev-to" size={20} color="#000" {...props} />,
  Edit: props => <MIIcons name="edit-note" size={20} color="#000" {...props} />,
  EyeOn: props => <MCIcons name="eye" size={20} color="#000" {...props} />,
  EyeOff: props => <MCIcons name="eye-off" size={20} color="#000" {...props} />,
  Favorite: props => (
    <OctIcons name="star-fill" size={20} color="#000" {...props} />
  ),
  Filter: props => (
    <IIcons name="filter-outline" size={20} color="#000" {...props} />
  ),
  Frame: props => <SIIcons name="frame" size={20} color="#000" {...props} />,
  Forward: props => (
    <MIIcons name="arrow-forward-ios" size={20} color="#000" {...props} />
  ),
  Home: props => <MCIcons name="home" size={20} color="#000" {...props} />,
  Help: props => (
    <MCIcons name="help-circle" size={20} color="#000" {...props} />
  ),
  Keyboard: props => (
    <MCIcons name="keyboard-variant" size={20} color="#000" {...props} />
  ),
  Menu: props => <FEIcons name="menu" size={20} color="#000" {...props} />,
  MenuList: props => <MCIcons name="menu" size={20} color="#000" {...props} />,
  LightOn: props => (
    <MIIcons name="flashlight-on" size={20} color="#000" {...props} />
  ),
  LightOff: props => (
    <MIIcons name="flashlight-off" size={20} color="#000" {...props} />
  ),
  Logout: props => <MIIcons name="logout" size={20} color="#000" {...props} />,
  Merge: props => (
    <MCIcons name="set-merge" size={20} color="#000" {...props} />
  ),
  Minus: props => <MCIcons name="minus" size={20} color="#000" {...props} />,
  Options: props => (
    <MCIcons name="dots-horizontal" size={20} color="#000" {...props} />
  ),
  Plus: props => <MCIcons name="plus" size={20} color="#000" {...props} />,
  Profile: props => (
    <ADIcons name="profile" size={20} color="#000" {...props} />
  ),
  Recipe: props => (
    <MCIcons name="treasure-chest" size={20} color="#000" {...props} />
  ),
  Save: props => (
    <MCIcons name="content-save" size={20} color="#000" {...props} />
  ),
  Search: props => <MIIcons name="search" size={20} color="#000" {...props} />,
  Settings: props => (
    <FA5Icons name="wrench" size={20} color="#000" {...props} />
  ),
  Share: props => <MCIcons name="share" size={20} color="#000" {...props} />,
  Shopping: props => (
    <FAIcons name="shopping-cart" size={20} color="#000" {...props} />
  ),
  Split: props => (
    <MCIcons name="set-split" size={20} color="#000" {...props} />
  ),
  Star: props => <MCIcons name="star" size={20} color="#000" {...props} />,
  Upload: props => <FEIcons name="upload" size={20} color="#000" {...props} />,
  Wave: props => <MCIcons name="wave" size={20} color="#000" {...props} />,
  Waves: props => <MCIcons name="waves" size={20} color="#000" {...props} />,
};


--- FILE: src/components/NavHeader.jsx ---

//*NavHeader.jsx
import React, {useCallback} from 'react';
import {Alert, TouchableOpacity, View} from 'react-native';
import {useNavigation} from '@react-navigation/native';
import {Text} from '../KQ-UI';
import {Icons} from './IconListRouter';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useDispatch} from 'react-redux';
import {useShoppingCart} from '../hooks/useHooks';
import {NavHeaderStyles} from '../styles/Styles';
import {useCoreInfo} from '../utilities/coreInfo';

const NavHeader = ({
  title = '',
  headerColor = '#29856c',
  textColor = '#000',
  LeftButton = 'None',
  RightButton = 'None',
  LeftAction,
  RightAction,
  sheetOpen,
}) => {
  const navigation = useNavigation();
  const useHaptics = setHapticFeedback();
  const dispatch = useDispatch();
  const shopping = useShoppingCart();
  const core = useCoreInfo();
  let fadeText = '#ffffff60';

  const cartList =
    shopping?.items?.filter(item => item.status === 'shopping-cart') ?? [];

  const handleSignOut = useCallback(() => {
    Alert.alert('Logging Out', 'Are you sure you want to logout?', [
      {text: 'Cancel', style: 'destructive'},
      {
        text: 'Confirm',
        onPress: () => {
          useHaptics(core?.userSettings?.hapticStrength || 'light');
          dispatch({type: 'LOGOUT_AND_CLEAR'});
        },
      },
    ]);
  }, [core?.userSettings?.hapticStrength, dispatch]);

  const NavButtonComponent = ({
    position,
    action,
    navigate,
    goBack,
    title,
    icon,
  }) => {
    const handlePress = useCallback(() => {
      if (navigate) navigation.navigate(navigate);
      if (goBack) navigation.goBack();
      if (action) action();
      useHaptics(core?.userSettings?.hapticStrength || 'light');
    }, [navigate, goBack, action, core?.userSettings?.hapticStrength]);

    const isLeft = position === 'Left';

    if (sheetOpen) {
      return (
        <View
          style={[
            isLeft ? NavHeaderStyles.leftWrapper : NavHeaderStyles.rightWrapper,
            {flex: 1},
          ]}>
          {isLeft && icon && (
            <View style={NavHeaderStyles.iconPosition}>{icon}</View>
          )}
          <View
            style={
              isLeft
                ? NavHeaderStyles.leftContainer
                : NavHeaderStyles.rightContainerAlt
            }>
            {title && (
              <Text style={{color: sheetOpen ? fadeText : textColor}}>
                {title}
              </Text>
            )}
          </View>
          {!isLeft && icon && (
            <View style={NavHeaderStyles.iconPosition}>{icon}</View>
          )}
        </View>
      );
    } else {
      return (
        <TouchableOpacity onPress={handlePress}>
          <View
            style={
              isLeft
                ? NavHeaderStyles.leftWrapper
                : NavHeaderStyles.rightWrapper
            }>
            {isLeft && icon && (
              <View style={NavHeaderStyles.iconPosition}>{icon}</View>
            )}
            <View
              style={
                isLeft
                  ? NavHeaderStyles.leftContainer
                  : NavHeaderStyles.rightContainerAlt
              }>
              {title && <Text style={{color: textColor}}>{title}</Text>}
            </View>
            {!isLeft && icon && (
              <View style={NavHeaderStyles.iconPosition}>{icon}</View>
            )}
          </View>
        </TouchableOpacity>
      );
    }
  };

  // ✅ Toggle memo for NavButton
  const NavButton = __DEV__
    ? NavButtonComponent
    : React.memo(NavButtonComponent);

  const renderButton = (buttonType, position) => {
    if (!buttonType || buttonType === 'None') return null;

    const allowedLeftButtons = [
      'Back',
      'Cancel',
      'Cancel-WA',
      'Cancel-Scan',
      'Close',
      'Merge',
      'Split',
      'To-List',
    ];
    const allowedRightButtons = [
      'Add',
      'Checkout',
      'Create',
      'Edit',
      'Logout',
      'Save',
      'Scan',
      'Submit',
      'To-Cart',
      'Torch-On',
      'Torch-Off',
      'Update',
    ];

    if (
      (position === 'Left' && !allowedLeftButtons.includes(buttonType)) ||
      (position === 'Right' && !allowedRightButtons.includes(buttonType))
    ) {
      console.warn(
        `Invalid placement: Button "${buttonType}" is not allowed on the ${position} side.`,
      );
      return null;
    }

    const buttonProps = {
      position,
      title: '',
      icon: null,
      action: null,
      navigate: null,
      goBack: false,
      showCondition: true,
    };

    switch (buttonType) {
      case 'Add':
        buttonProps.title = 'Add';
        buttonProps.icon = (
          <Icons.AddList size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Back':
        buttonProps.title = 'Back';
        buttonProps.icon = (
          <Icons.Back size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.goBack = true;
        break;

      case 'Cancel':
        buttonProps.title = 'Cancel';
        buttonProps.goBack = true;
        break;

      case 'Cancel-WA':
        buttonProps.title = 'Cancel';
        buttonProps.action = () => LeftAction();
        break;

      case 'Cancel-Scan':
        buttonProps.title = 'Cancel';
        buttonProps.action = () => LeftAction();
        break;

      case 'Checkout':
        buttonProps.title = 'Checkout';
        buttonProps.showCondition = cartList?.length > 0;
        buttonProps.icon = (
          <Icons.Forward size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Close':
        buttonProps.title = 'Close';
        buttonProps.action = () => LeftAction();
        break;

      case 'Create':
        buttonProps.title = 'Create';
        buttonProps.icon = (
          <Icons.AddList size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Edit':
        buttonProps.title = 'Edit';
        buttonProps.icon = (
          <Icons.Edit size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Logout':
        buttonProps.title = 'Logout';
        buttonProps.icon = (
          <Icons.Logout size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = handleSignOut;
        break;

      case 'Merge':
        buttonProps.title = 'Grouped';
        buttonProps.navigate = 'CupboardList-Single';
        buttonProps.icon = (
          <View style={{marginRight: 5}}>
            <Icons.Merge size={25} color={sheetOpen ? fadeText : textColor} />
          </View>
        );
        break;

      case 'Save':
        buttonProps.title = 'Save';
        buttonProps.icon = (
          <Icons.Save size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Scan':
        buttonProps.title = 'Scan';
        buttonProps.icon = (
          <Icons.Barcode size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Split':
        buttonProps.title = 'Single';
        buttonProps.navigate = 'CupboardList-Group';
        buttonProps.icon = (
          <View style={{marginRight: 5}}>
            <Icons.Split size={25} color={sheetOpen ? fadeText : textColor} />
          </View>
        );
        break;

      case 'To-Cart':
        buttonProps.title = 'Cart';
        buttonProps.navigate = 'ShoppingCart';
        buttonProps.icon = <Icons.Forward size={20} color={textColor} />;
        buttonProps.showCondition = cartList?.length > 0;
        break;

      case 'To-List':
        buttonProps.title = 'List';
        buttonProps.navigate = 'ShoppingList';
        buttonProps.icon = (
          <Icons.Back size={20} color={sheetOpen ? fadeText : textColor} />
        );
        break;
      case 'Torch-On':
        buttonProps.title = 'Light On';
        buttonProps.icon = (
          <Icons.LightOn size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;
      case 'Torch-Off':
        buttonProps.title = 'Light Off';
        buttonProps.icon = (
          <Icons.LightOff size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      default:
        console.warn(`Unknown buttonType: "${buttonType}"`);
        return null;
    }

    if (!buttonProps.showCondition) return null;

    return <NavButton {...buttonProps} />;
  };

  return (
    <View
      style={[
        NavHeaderStyles.header,
        {backgroundColor: headerColor ?? '#fff', height: 50},
      ]}>
      <View style={NavHeaderStyles.titleContainer}>
        <Text style={{color: textColor}}>{title}</Text>
      </View>
      <View style={NavHeaderStyles.buttonContainer}>
        <View style={NavHeaderStyles.buttonRows}>
          <View style={NavHeaderStyles.sideContainers}>
            {renderButton(LeftButton, 'Left')}
          </View>
          <View style={NavHeaderStyles.sideContainers}>
            {renderButton(RightButton, 'Right')}
          </View>
        </View>
      </View>
    </View>
  );
};

export default __DEV__ ? NavHeader : React.memo(NavHeader);


--- FILE: src/components/NavMenu.jsx ---

//*NavMenu.jsx
import React, {useMemo} from 'react';
import {Alert, TouchableOpacity, View} from 'react-native';
import CurvedBottomBar from './CurvedBottomBar';
import {Icons} from '../components/IconListRouter';
import {useNavigation} from '@react-navigation/native';
import {getMenuButtonHeight, getNavBarHeight} from '../utilities/deviceUtils';
import {
  CurvedBarStyles,
  MenuButtonStyles,
  NavMenuStyles,
} from '../styles/Styles';
import {Text} from '../KQ-UI';
import {useCoreInfo} from '../utilities/coreInfo';
import {setHapticFeedback} from '../hooks/setHapticFeedback';

const NavMenu = props => {
  const {
    bottomHeight,
    bottomWidth,
    toggleMenu,
    device,
    setIsSheetOpen,
    navMode,
  } = props;
  const core = useCoreInfo();
  const useHaptics = setHapticFeedback();
  const navigation = useNavigation();

  const menuButtonHeight = useMemo(
    () => getMenuButtonHeight(device, bottomHeight, navMode),
    [device, bottomHeight],
  );

  const navHeight = useMemo(
    () => getNavBarHeight(device, bottomHeight, navMode),
    [device, bottomHeight],
  );

  const userItems = [
    {
      id: 'shopping',
      title: 'Shopping',
      icon: <Icons.Shopping size={25} color={'#000'} />,
      screen: 'ShoppingList',
    },
    {
      id: 'cupboard',
      title: 'Cupboard',
      icon: <Icons.Cupboards size={25} color={'#000'} />,
      screen: 'CupboardList-Single',
    },
  ];

  const getNavBarLayout = (items = []) => {
    const requiredItems = [
      {
        id: 'home',
        title: 'Home',
        icon: <Icons.Home size={27} color={'#000'} />,
        screen: 'Home',
      },
      {
        id: 'account',
        title: 'Account',
        icon: <Icons.Account size={25} color={'#000'} />,
        screen: 'Account',
      },
    ];

    // Combine required and user items, Home first, Account last
    let allItems = [requiredItems[0], ...items, requiredItems[1]];

    // Ensure odd number of slots (to keep center slot open)
    if (allItems.length % 2 === 0) {
      allItems.splice(Math.floor(allItems.length / 2), 0, {id: 'spacer'}); // Center spacer
    }

    return allItems;
  };

  const navItems = getNavBarLayout(userItems);

  const handleNavPress = item => {
    useHaptics(core?.userSettings?.hapticStrength || 'light');
    setIsSheetOpen(false);
    const allowedScreens = [
      'Home',
      'ShoppingList',
      'CupboardList-Single',
      'Account',
    ];

    if (allowedScreens.includes(item.screen)) {
      navigation.navigate(item.screen);
    } else {
      Alert.alert('Coming Soon', `${item.title} screen not yet available.`);
    }
  };

  return (
    <View style={NavMenuStyles.container}>
      <View style={{height: navHeight}}>
        <CurvedBottomBar
          height={bottomHeight}
          width={bottomWidth}
          fill={CurvedBarStyles.fillColor}
          stroke={CurvedBarStyles.strokeColor}
          strokeWidth={CurvedBarStyles.strokeWidth}
          shadowStroke={CurvedBarStyles.shadowStroke}
          shadowStrokeWidth={CurvedBarStyles.shadowStrokeWidth}
        />
        <View style={MenuButtonStyles.wrapper}>
          {navItems.map((item, index) => {
            if (item.id === 'spacer') {
              return (
                <View key={index} style={MenuButtonStyles.container}>
                  <TouchableOpacity
                    style={MenuButtonStyles.button}
                    onPress={toggleMenu}>
                    <Icons.Menu size={30} color={'#fff'} />
                  </TouchableOpacity>
                </View>
              );
            }
            return (
              <TouchableOpacity
                key={index}
                onPress={() => handleNavPress(item)}
                style={[
                  MenuButtonStyles.menuButton,
                  {
                    height: menuButtonHeight,
                    // borderWidth: 1
                  },
                ]}>
                {item.icon}
                <Text size="tiny" font="open-6">
                  {item.title}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>
      </View>
    </View>
  );
};

export default NavMenu;


--- FILE: src/components/SelectedItemInfo.jsx ---

//* SelectedItemInfo.jsx
import {useNavigation} from '@react-navigation/native';
import React, {useState} from 'react';
import {View} from 'react-native';
import {SelectItemStyles} from '../styles/Styles';
import {categoryColors, formatCategories} from '../utilities/categories';
import {formatMeasurement} from '../utilities/measurements';
import {Button, Text, ScrollView} from '../KQ-UI';
import {Icons} from './IconListRouter';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../utilities/coreInfo';
import {useColors} from '../KQ-UI/KQUtilities';

const SelectedItemInfo = props => {
  const {
    selectedItem,
    setShowItemInfo,
    navigate,
    groupedView = false,
    cupboardView = false,
    addToList = false,
  } = props;

  const navigation = useNavigation();
  const dispatch = useDispatch();
  const core = useCoreInfo();

  const [quantity, setQuantity] = useState(1);

  const handleAddToFavorites = () => {
    const newItem = {
      itemName: selectedItem?.itemName || '',
      brandName: selectedItem?.brandName || '',
      description: selectedItem?.description || '',
      packageSize: Number(selectedItem?.packageSize),
      measurement: selectedItem?.measurement || '',
      category: selectedItem?.category || '',
      notes: selectedItem?.notes || '',
    };

    dispatch({
      type: 'ADD_ITEM_TO_FAVORITES',
      payload: {
        favoriteItemsID: core.favoriteItemsID,
        newItem: newItem,
        profileID: core.profileID,
      },
    });
    setShowItemInfo(false);
  };

  const handleAddFavToShopList = item => {
    const newItem = {
      itemName: item?.itemName || '',
      brandName: item?.brandName || '',
      description: item?.description || '',
      packageSize:
        Number(item?.packageSize) > 0 ? Number(item?.packageSize) : 1,
      quantity: Number(quantity) > 0 ? Number(quantity) : 1,
      measurement: item?.measurement || '',
      category: item?.category || '',
      notes: item?.notes || '',
      status: 'shopping-list',
    };

    dispatch({
      type: 'ADD_ITEM_TO_SHOP_CART',
      payload: {
        shoppingCartID: core.shoppingCartID,
        newItem: newItem,
        profileID: core.profileID,
      },
    });
    navigation.navigate(navigate?.backTo);
    setShowItemInfo(false);
  };

  const handleAddToShopList = item => {
    const newItem = {
      itemName: item?.itemName || '',
      brandName: item?.brandName || '',
      description: item?.description || '',
      packageSize: item?.packageSize || 1,
      quantity: 1,
      measurement: item?.measurement || '',
      category: item?.category || '',
      notes: item?.notes || '',
      status: 'shopping-list',
    };

    dispatch({
      type: 'ADD_ITEM_TO_SHOP_CART',
      payload: {
        shoppingCartID: core.shoppingCartID,
        newItem: newItem,
        profileID: core.profileID,
      },
    });
    navigation.navigate(navigate?.backTo);
    setShowItemInfo(false);
  };

  const handleUpdateItem = itemId => {
    navigation.navigate(navigate?.to, {
      itemId,
      navigateBackTo: navigate?.backTo,
      statusTo: navigate?.statusTo,
    });
    setShowItemInfo(false);
  };

  const ItemRow = ({title, info, info2}) => {
    const asNote = title === 'Notes';
    const remain = title === 'Remaining Amount' || title === 'Total Remaining';

    if (!info) {
      return null;
    } else {
      return (
        <View
          style={
            asNote
              ? SelectItemStyles.itemNoteContainer
              : SelectItemStyles.itemContainer
          }>
          <View style={SelectItemStyles.titleWrap}>
            <Text size="small">{title}:</Text>
          </View>
          <View
            style={[
              asNote
                ? SelectItemStyles.infoNoteWrap
                : SelectItemStyles.infoWrap,
            ]}>
            <Text
              size="small"
              style={[
                asNote
                  ? SelectItemStyles.textNoteStyles
                  : SelectItemStyles?.textStyles,
              ]}
              numberOfLines={asNote ? 0 : 1}>
              {info}
            </Text>
          </View>
          {remain && (
            <View>
              <Text size="small" style={{paddingTop: 3, paddingHorizontal: 1}}>
                ({((info / info2) * 100).toFixed(0)}% left)
              </Text>
            </View>
          )}
        </View>
      );
    }
  };

  const BannerField = ({children, backgroundColor}) => {
    return (
      <View style={SelectItemStyles.bannerFieldWrapper(backgroundColor)}>
        <Text
          font="banana"
          centered
          style={{
            fontSize: 65,
            color: 'white',
            position: 'relative',
            top: -9,
          }}
          numberOfLines={1}>
          {children}
        </Text>
      </View>
    );
  };

  return (
    <View style={{flex: 1}}>
      {selectedItem && (
        <View style={SelectItemStyles.container}>
          <BannerField backgroundColor={categoryColors(selectedItem?.category)}>
            {formatCategories(selectedItem?.category)}
          </BannerField>
          {groupedView ? (
            <View
              style={{
                marginHorizontal: 5,
                padding: 5,
              }}>
              <Text centered size="xSmall">
                Can't update grouped items.
              </Text>
              <Text centered size="xSmall">
                Please close and select single view.
              </Text>
            </View>
          ) : (
            <View style={SelectItemStyles.updateContainer}>
              <Button
                color="info"
                type="outline"
                size="small"
                onPress={() => handleUpdateItem(selectedItem?.itemId)}>
                Update Item
              </Button>
            </View>
          )}
          <ScrollView contentContainerStyle={SelectItemStyles.infoContainer}>
            <ItemRow title="Item Name" info={selectedItem?.itemName} />
            <ItemRow title="Brand" info={selectedItem?.brandName} />
            <ItemRow title="Description" info={selectedItem?.description} />
            {!cupboardView && (
              <ItemRow title="Quantity" info={selectedItem?.quantity} />
            )}
            <ItemRow
              title={groupedView ? 'Total Remaining' : 'Remaining Amount'}
              info={selectedItem?.remainingAmount}
              info2={selectedItem?.packageSize}
            />
            <ItemRow
              title={groupedView ? 'Total Package Size' : 'Package Size'}
              info={selectedItem?.packageSize}
            />
            <ItemRow
              title="Measurement"
              info={formatMeasurement(selectedItem?.measurement)}
            />
            {selectedItem?.notes && (
              <ItemRow title="Notes" info={selectedItem?.notes} />
            )}
            {cupboardView && !groupedView && (
              <View style={{marginLeft: 5, marginTop: 15}}>
                <Button
                  size="large"
                  // color={useColors('gold')}
                  onPress={() => handleAddToShopList(selectedItem)}>
                  <View style={{flexDirection: 'row'}}>
                    <View style={{marginRight: 10}}>
                      <Icons.AddList color={useColors('white')} />
                    </View>
                    <View>
                      <Text kqColor="white" font="open-6">
                        Add to Shopping List
                      </Text>
                    </View>
                  </View>
                </Button>
              </View>
            )}
            {!addToList && !groupedView && (
              <View
                style={{
                  marginLeft: 5,
                  marginTop: cupboardView && !groupedView ? 5 : 15,
                }}>
                <Button
                  size="large"
                  color={useColors('gold')}
                  onPress={() => handleAddToFavorites()}>
                  <View style={{flexDirection: 'row'}}>
                    <View style={{marginRight: 10}}>
                      <Icons.Star color={useColors('dark')} />
                    </View>
                    <View>
                      <Text font="open-6">Add to Favorites</Text>
                    </View>
                  </View>
                </Button>
              </View>
            )}

            {addToList && (
              <View style={SelectItemStyles.addToContainer}>
                <View style={SelectItemStyles.quantityWrapper}>
                  <View style={SelectItemStyles.quantityContainer}>
                    <Button
                      type="ghost"
                      symbols
                      symbolStyle={{width: 35, height: '100%'}}
                      style={{flex: 1}}
                      onPress={() => {
                        setQuantity(prev => Math.max(1, prev - 1));
                      }}>
                      <Icons.Minus size={20} />
                    </Button>
                  </View>

                  <View style={SelectItemStyles.quantityText}>
                    <Text size="small">{quantity}</Text>
                  </View>
                  <View style={SelectItemStyles.quantityContainer}>
                    <Button
                      type="ghost"
                      symbols
                      symbolStyle={{width: 35, height: '100%'}}
                      style={{flex: 1}}
                      onPress={() => {
                        setQuantity(prev => prev + 1);
                      }}>
                      <Icons.Plus size={20} />
                    </Button>
                  </View>
                </View>

                <View style={{flex: 3, marginLeft: 10}}>
                  <Button
                    size="medium"
                    style={{flex: 1}}
                    onPress={() => handleAddFavToShopList(selectedItem)}>
                    Add to Shopping List
                  </Button>
                </View>
              </View>
            )}
          </ScrollView>
        </View>
      )}
    </View>
  );
};

export default SelectedItemInfo;


--- FILE: src/components/SplashScreen.jsx ---

//*SplashScreen.jsx
import React from 'react';
import {View, Text, StyleSheet, ActivityIndicator, Image} from 'react-native';

const SplashScreen = () => {
  const logo = require('../images/AppLogo_350.png');
  return (
    <View style={styles.container}>
      <View style={{marginBottom: -24}}>
        <Image source={logo} style={styles.image} />
      </View>
      <View style={{position: 'absolute', top: '44%', left: '50%'}}>
        <ActivityIndicator size="large" color="#29856c" />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 36,
    padding: 5,
    fontFamily: 'Montserrat-Bold',
  },
  indicator: {
    marginVertical: 5,
    paddingTop: 8,
    paddingBottom: 5,
    paddingLeft: 8,
    paddingRight: 6,
  },
  image: {},
});

export default SplashScreen;


--- FILE: src/components/SwipeableItem.jsx ---

//* SwipeableItem.jsx
import {FlashList} from '@shopify/flash-list';
import React, {useCallback, useEffect, useRef} from 'react';
import FlashCell from './FlashCell';
import Swipeable from 'react-native-gesture-handler/ReanimatedSwipeable';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {ListStyles} from '../styles/Styles';
import {Animated, TouchableOpacity, View} from 'react-native';
import {Text} from '../KQ-UI';
import {Icons} from './IconListRouter';
import {useColors} from '../KQ-UI/KQUtilities';

const SwipeableItem = props => {
  const {
    list,
    core,
    showItemInfo,
    setSelectedItem,
    setShowItemInfo,
    leftButtons = [],
    rightButtons = [],
    favoritesView = false,
    groupedView = false,
    noQuantity = false,
  } = props;

  const swipeableRefs = useRef(new Map());
  const currentlyOpenRef = useRef(null);
  const useHaptics = setHapticFeedback();

  const closeSwipeable = itemId => {
    const swipeableRef = swipeableRefs.current.get(itemId);
    if (swipeableRef) {
      swipeableRef.close();
    }
  };

  const handleSwipeableOpen = itemId => {
    if (currentlyOpenRef.current && currentlyOpenRef.current !== itemId) {
      closeSwipeable(currentlyOpenRef.current);
    }
    currentlyOpenRef.current = itemId;
  };

  useEffect(() => {
    if (showItemInfo && currentlyOpenRef.current) {
      const ref = swipeableRefs.current.get(currentlyOpenRef.current);
      if (ref) {
        ref.close();
        currentlyOpenRef.current = null;
      }
    }
  }, [showItemInfo]);

  useEffect(() => {
    return () => {
      swipeableRefs.current.clear();
      currentlyOpenRef.current = null;
    };
  }, []);

  const closeAllSwipeables = () => {
    swipeableRefs.current.forEach(ref => {
      if (ref && typeof ref.close === 'function') {
        ref.close();
      }
    });
    currentlyOpenRef.current = null;
  };

  const renderRightActions = itemId => {
    if (rightButtons.length === 0) return null;

    return (
      <View style={ListStyles.rightActionsContainer}>
        {rightButtons.map((button, index) => (
          <Animated.View
            key={index}
            style={[ListStyles.rightActionButton, button.style]}>
            <TouchableOpacity
              onPress={() => {
                button.action(itemId);
                closeSwipeable(itemId);
                useHaptics(core?.userSettings?.hapticStrength || 'light');
              }}>
              <View style={ListStyles.buttonContainer}>
                {button.text1 && (
                  <Text size="xSmall" font="open-7" kqColor="white">
                    {button.text1}
                  </Text>
                )}
                {button.text2 && (
                  <Text size="xSmall" font="open-7" kqColor="white">
                    {button.text2}
                  </Text>
                )}
                {button.starIcon === true && (
                  <Icons.Favorite size={30} color={useColors('white')} />
                )}
              </View>
            </TouchableOpacity>
          </Animated.View>
        ))}
      </View>
    );
  };

  const renderSwipeableItem = useCallback(
    ({item}) => (
      <Swipeable
        ref={ref => swipeableRefs.current.set(item.itemId, ref)}
        onSwipeableOpen={() => handleSwipeableOpen(item.itemId)}
        renderRightActions={() => renderRightActions(item.itemId)}
        rightThreshold={100}
        friction={1}
        overshootFriction={8}>
        <FlashCell
          item={item}
          core={core}
          setSelectedItem={setSelectedItem}
          setShowItemInfo={setShowItemInfo}
          showItemInfo={showItemInfo}
          closeAllSwipeables={closeAllSwipeables}
          favoritesView={favoritesView}
          groupedView={groupedView}
          noQuantity={noQuantity}
        />
      </Swipeable>
    ),
    [setSelectedItem, setShowItemInfo],
  );

  return (
    <FlashList
      data={list}
      renderItem={renderSwipeableItem}
      keyExtractor={item => item.itemId}
      estimatedItemSize={70}
    />
  );
};

export default SwipeableItem;


--- FILE: src/components/TellMeButton.jsx ---

//* TellMeButton.jsx
import React from 'react';
import {View, TouchableOpacity} from 'react-native';
import {Text} from '../KQ-UI';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {Icons} from './IconListRouter';

const TellMeButton = ({action, tt1, tt2, profile}) => {
  const useHaptics = setHapticFeedback();

  const handlePress = () => {
    useHaptics(profile || 'light');
    action();
  };
  return (
    <TouchableOpacity style={{height: 60}} onPress={() => handlePress()}>
      <View
        style={{
          flex: 1,
          flexDirection: 'row',
          alignItems: 'center',
        }}>
        <View
          style={{
            flex: 1,
            height: '100%',
            justifyContent: 'center',
            paddingLeft: 5,
          }}>
          <View style={{marginVertical: 1.5}}>
            <Text size="small" font="open-7">
              {tt1}
            </Text>
          </View>
          <View style={{marginVertical: 1.5}}>
            <Text size="xSmall" font="open-5">
              {tt2}
            </Text>
          </View>
        </View>
        <View
          style={{
            width: 40,
            height: '100%',
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Icons.Forward color={'#373d43'} />
        </View>
      </View>
    </TouchableOpacity>
  );
};

export default React.memo(TellMeButton);


--- FILE: src/hooks/setHapticFeedback.jsx ---

//*setHapticFeedback.jsx
import HapticFeedback from 'react-native-haptic-feedback';

export const setHapticFeedback = () => {
  const triggerHaptic = props => {
    const options = {
      enableVibrateFallback: true,
      ignoreAndroidSystemSettings: false,
    };
    switch (props) {
      case 'off':
        break;
      case 'light':
        HapticFeedback.trigger('impactLight', options);
        break;
      case 'medium':
        HapticFeedback.trigger('impactMedium', options);
        break;
      case 'heavy':
        HapticFeedback.trigger('impactHeavy', options);
        break;
      case 'success':
        HapticFeedback.trigger('notificationSuccess', options);
        break;
      case 'warning':
        HapticFeedback.trigger('notificationWarning', options);
        break;
      case 'error':
        HapticFeedback.trigger('notificationError', options);
        break;
      default:
        HapticFeedback.trigger('impactLight', options);
        break;
    }
  };

  return triggerHaptic;
};


--- FILE: src/hooks/useBarcodeScanner.jsx ---

//* useBarcodeScanner.jsx
import {useState, useRef} from 'react';
import {dailyCheckLimit} from '../utilities/checkLimit';
import {useDispatch} from 'react-redux';

const useBarcodeScanner = core => {
  const dispatch = useDispatch();
  const [showScanner, setShowScanner] = useState(false);
  const [torchEnabled, setTorchEnabled] = useState(false);
  const [scannedData, setScannedData] = useState(null);
  const lastScannedCode = useRef(null);

  const toggleTorch = () => setTorchEnabled(prev => !prev);

  const debounceRef = useRef(false);
  const count = core?.dailyUPCCounter || 0;
  const limit = core?.maxUPCSearchLimit || 0;

  const onReadCode = (codes = []) => {
    if (count < limit) {
      if (debounceRef.current) return;

      const supportedCodeFormats = ['ean-8', 'ean-13', 'upc-a', 'upc-e'];
      for (const code of codes) {
        const codeFormat = code.type?.toLowerCase();
        const codeValue = code.value;
        if (supportedCodeFormats.includes(codeFormat)) {
          if (lastScannedCode.current === codeValue) return;

          debounceRef.current = true;
          lastScannedCode.current = codeValue;

          const scannedCode = {format: codeFormat, value: codeValue};
          setScannedData(scannedCode);
          setShowScanner(false);

          setTimeout(() => {
            debounceRef.current = false;
          }, 1500);
          break;
        }
      }
    }
  };

  const resetScanner = () => {
    setScannedData(null);
    lastScannedCode.current = null;
  };

  return {
    showScanner,
    setShowScanner,
    torchEnabled,
    toggleTorch,
    scannedData,
    onReadCode,
    resetScanner,
  };
};

export default useBarcodeScanner;


--- FILE: src/hooks/useHooks.jsx ---

//*useHooks.jsx
import {useSelector, shallowEqual} from 'react-redux';

export const useDeviceInfo = () => {
  return useSelector(state => state.deviceInfo?.deviceInfo);
};

export const useAuth = () => {
  return useSelector(state => state.user?.isAuthenticated);
};

export const useUser = () => {
  return useSelector(state => state.user?.data);
};

export const useLoginError = () => {
  return useSelector(state => state.user?.error);
};

export const useProfile = () => {
  return useSelector(state => state.profile?.profile);
};

export const useProfileError = () => {
  return useSelector(state => state.profile?.error);
};

export const useAccount = () => {
  return useSelector(state => state.account?.account);
};

export const useAccountError = () => {
  return useSelector(state => state.account?.error);
};

export const useShoppingCart = () => {
  return useSelector(state => state.shopping?.shopping);
};

export const useShoppingCartError = () => {
  return useSelector(state => state.shopping?.error);
};

export const useCupboard = () => {
  return useSelector(state => state.cupboard?.cupboard);
};

export const useCupboardError = () => {
  return useSelector(state => state.cupboard?.error);
};

export const useAllowedProfiles = () => {
  return useSelector(state => state.account?.allowedProfiles);
};

export const useExistingInvite = () => {
  return useSelector(state => state.invites?.existingInvite || null);
};

export const useFoodData = () => {
  return useSelector(state => state.edamam?.foodData);
};

export const useFoodDataError = () => {
  return useSelector(state => state.edamam?.error);
};

export const useFoodDataLoading = () => {
  return useSelector(state => state.edamam?.loading);
};

export const useRecipesData = () => {
  return useSelector(
    state => state.recipe?.communityRecipes || [],
    shallowEqual,
  );
};

export const useRecipeRawData = () => {
  return useSelector(state => state.recipe);
};

export const useRecipeDataError = () => {
  return useSelector(state => state.recipe?.error);
};

export const useRecipeDataLoading = () => {
  return useSelector(state => state.recipe?.loading);
};

export const useFoundInvite = () => {
  const {inviteFound, inviteData, error, errorMsg1, errorMsg2} = useSelector(
    state => state.joinInvite || {},
  );
  return {
    inviteFound: inviteFound || false,
    inviteData: inviteData || null,
    error: error || false,
    errorMsg1: errorMsg1 || '',
    errorMsg2: errorMsg2 || '',
  };
};

export const useFoundAccount = () => {
  const {accountFound, accountData, error} = useSelector(
    state => state.joinInvite || {},
  );
  return {
    accountFound: accountFound || false,
    accountData: accountData || null,
    error: error || false,
  };
};

export const useFavorites = () => {
  return useSelector(state => state.favorites?.favorites);
};

export const useRecipeBox = () => {
  return useSelector(state => state.recipe?.recipeBox);
};


--- FILE: src/hooks/useRequestPermissions.js ---

// useRequestPermissions.js
import {useState} from 'react';
import {Alert, Platform} from 'react-native';
import {
  check,
  openSettings,
  PERMISSIONS,
  request,
  RESULTS,
} from 'react-native-permissions';
import {useCameraDevice} from 'react-native-vision-camera';

export function useRequestPermissions(renderDisplay) {
  const device = useCameraDevice('back', {
    physicalDevices: [
      'ultra-wide-angle-camera',
      'wide-angle-camera',
      'telephoto-camera',
    ],
  });
  const [permissionStatuses, setPermissionStatuses] = useState({});

  const permissionTypes = Platform.select({
    ios: [PERMISSIONS.IOS.CAMERA, PERMISSIONS.IOS.PHOTO_LIBRARY],
    android: [
      PERMISSIONS.ANDROID.CAMERA,
      PERMISSIONS.ANDROID.READ_MEDIA_IMAGES,
    ],
  });

  const checkPermissions = async () => {
    if (!permissionTypes) return;

    const results = {};
    for (const p of permissionTypes) {
      const status = await check(p);
      results[p] = status;
      handlePermissionStatus(p, status);
    }
    setPermissionStatuses(results);
  };

  const requestPermissions = async () => {
    if (!permissionTypes) return;

    const results = {};
    for (const p of permissionTypes) {
      const status = await request(p);
      results[p] = status;
      handlePermissionStatus(p, status);
    }
    setPermissionStatuses(results);
  };

  const handlePermissionStatus = (permission, status) => {
    switch (status) {
      case RESULTS.UNAVAILABLE:
        Alert.alert(`${permission} not available on this device.`);
        break;
      case RESULTS.DENIED:
        Alert.alert(
          'Permission Denied',
          `${permission} access is required. Would you like to allow it?`,
          [
            {text: 'Cancel', style: 'cancel'},
            {text: 'Allow', onPress: () => request(permission)},
          ],
        );
        break;
      case RESULTS.BLOCKED:
        Alert.alert(
          'Permission Blocked',
          `${permission} access is blocked. Please enable it manually in Settings.`,
          [
            {text: 'Cancel', style: 'cancel'},
            {text: 'Open Settings', onPress: openSettings},
          ],
        );
        break;
      case RESULTS.GRANTED:
        // console.log(`${permission} granted`);
        break;
      default:
      // console.log(`Unknown status for ${permission}`);
    }
  };

  return {
    device,
    permissionStatuses,
    checkPermissions,
    requestPermissions,
  };
}


--- FILE: src/redux/reducers/_root.reducer.jsx ---

//*_root.reducer.jsx
import {combineReducers} from 'redux';
import userReducer from './user.reducer';
import profileReducer from './profile.reducer';
import accountReducer from './account.reducer';
import shoppingReducer from './shopCart.reducer';
import cupboardReducer from './cupboard.reducer';
import deviceReducer from './device.reducer';
import invitesReducer from './invites.reducer';
import joinInviteReducer from './join.reducer';
import edamamReducer from './edamam.reducer';
import recipeReducer from './recipe.reducer';
import favoriteReducer from './favorites.reducer';

const rootReducer = combineReducers({
  user: userReducer,
  profile: profileReducer,
  account: accountReducer,
  shopping: shoppingReducer,
  cupboard: cupboardReducer,
  deviceInfo: deviceReducer,
  invites: invitesReducer,
  joinInvite: joinInviteReducer,
  edamam: edamamReducer,
  recipe: recipeReducer,
  favorites: favoriteReducer,
});

export default rootReducer;


--- FILE: src/redux/reducers/account.reducer.jsx ---

//* account.reducer.jsx
const initialState = {
  account: null,
  allowedProfiles: [],
  error: null,
};

const accountReducer = (state = initialState, action) => {
  switch (action.type) {
    // ✅ Account set or created
    case 'SET_ACCOUNT':
    case 'ACCOUNT_CREATE_SUCCESS':
      return {...state, account: action.payload, error: null};
    case 'DAILY_COUNTUP_SUCCESS':
      return state;
    case 'RESET_DAILY_COUNTERS_SUCCESS':
      return {
        ...state,
        account: {
          ...state.account, // 🟢 Preserve existing data
          ...action.payload, // 🟢 Overwrite with updated fields
        },
        error: null,
      };

    case 'ACCOUNT_CREATE_FAILURE':
    case 'ACCOUNT_FETCH_FAILED':
    case 'RESET_DAILY_COUNTERS_FAILED':
      return {...state, error: action.payload};

    // ✅ Allowed profiles
    case 'SET_ALLOWED_PROFILES':
      return {...state, allowedProfiles: action.payload};
    case 'FETCH_ALLOWED_PROFILES_FAILED':
      return {...state, error: action.payload};

    // 🔄 Reset
    case 'RESET_ACCOUNT_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default accountReducer;


--- FILE: src/redux/reducers/cupboard.reducer.jsx ---

//* cupboard.reducer.jsx
const initialState = {
  cupboard: null,
  loading: false,
  error: null,
};

const cupboardReducer = (state = initialState, action) => {
  switch (action.type) {
    // 🔄 Fetching
    case 'FETCH_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'SET_CUPBOARD':
      return {...state, cupboard: action.payload, loading: false, error: null};
    case 'CUPBOARD_SET_FAILED': // ✅ fixed name
      return {...state, loading: false, error: action.payload};
    // ➕ Add Item
    case 'ADD_ITEM_TO_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_ADD_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ✏️ Update Item
    case 'UPDATE_ITEM_IN_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_UPDATE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ❌ Delete Item
    case 'DELETE_ITEM_FROM_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_DELETE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ❌ Delete List
    case 'DELETE_LIST_FROM_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_DELETE_LIST_FAILED':
      return {...state, loading: false, error: action.payload};

    // 📦 Batch Add
    case 'BATCH_TO_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_BATCH_ADD_START':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_BATCH_ADD_SUCCESS':
      return {...state, loading: false, error: null};
    case 'CUPBOARD_BATCH_ADD_FAILED':
      return {...state, loading: false, error: action.payload};

    // ♻️ Reset
    case 'RESET_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_RESET_FAILED':
      return {...state, loading: false, error: action.payload};

    case 'RESET_CUPBOARD_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default cupboardReducer;


--- FILE: src/redux/reducers/device.reducer.jsx ---

//*device.reducer.jsx
const initialState = {
  deviceInfo: null,
  error: null,
};

const deviceReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'SET_DEVICE_INFO':
      return {...state, deviceInfo: action.payload, error: null};
    case 'DEVICE_INFO_FETCH_FAILED':
      return {...state, error: action.payload};
    case 'RESET_DEVICE_INFO_STATE':
      return initialState;
    default:
      return state;
  }
};

export default deviceReducer;


--- FILE: src/redux/reducers/edamam.reducer.jsx ---

//* edamam.reducer.jsx
const initialState = {
  foodData: null,
  error: null,
  loading: false,
};

const edamamReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'FETCH_FOOD_DATA':
      return {...state, loading: true, error: null};

    case 'SET_FOOD_DATA':
      return {...state, foodData: action.payload, loading: false};

    case 'FOOD_API_FETCH_FAILED':
      return {...state, error: action.payload, loading: false};

    case 'RESET_FOOD_DATA':
      return {...initialState};
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default edamamReducer;


--- FILE: src/redux/reducers/favorites.reducer.jsx ---

//*shopCart.reducer.jsx
const initialState = {
  favorites: null,
  loading: false,
  error: null,
};

const favoriteReducer = (state = initialState, action) => {
  switch (action.type) {
    // 🔄 Fetching
    case 'FETCH_FAVORITES':
      return {...state, loading: true, error: null};
    case 'SET_FAVORITES':
      return {...state, favorites: action.payload, loading: false, error: null};
    case 'FAVORITES_SET_FAILED':
      return {...state, loading: false, error: action.payload};

    // ➕ Add Item
    case 'ADD_ITEM_TO_FAVORITES':
      return {...state, loading: true, error: null};
    case 'FAVORITES_ADD_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ✏️ Update Item
    case 'UPDATE_ITEM_IN_FAVORITES':
      return {...state, loading: true, error: null};
    case 'FAVORITES_UPDATE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ❌ Delete Item
    case 'DELETE_ITEM_FROM_FAVORITES':
      return {...state, loading: true, error: null};
    case 'FAVORITES_DELETE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ❌ Delete List
    case 'DELETE_LIST_FROM_FAVORITES':
      return {...state, loading: true, error: null};
    case 'FAVORITES_DELETE_LIST_FAILED':
      return {...state, loading: false, error: action.payload};

    // ♻️ Reset
    case 'RESET_FAVORITES':
      return {...state, loading: true, error: null};
    case 'FAVORITES_RESET_FAILED':
      return {...state, loading: false, error: action.payload};

    case 'RESET_FAVORITES_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default favoriteReducer;


--- FILE: src/redux/reducers/invites.reducer.jsx ---

//* invites.reducer.jsx
const initialState = {
  existingInvite: null,
  limitExceeded: false,
  error: null,
};

const invitesReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'SET_EXISTING_INVITE':
      return {
        ...state,
        existingInvite: action.payload,
        error: null,
      };
    case 'SET_EXCEEDING_LIMITS':
      return {
        ...state,
        limitExceeded: true,
        existingInvite: null,
        error: null, // no error needed for form field now
      };
    case 'ADD_INVITE':
      return {
        ...state,
        existingInvite: action.payload,
        error: null,
      };
    case 'UPDATE_INVITE':
      return {
        ...state,
        existingInvite: {
          ...state.existingInvite,
          ...action.payload,
        },
        error: null,
      };
    case 'DELETE_INVITE':
      return {
        ...state,
        existingInvite: null,
        error: null,
      };
    case 'CLEAR_EXISTING_INVITE':
      return {
        ...state,
        existingInvite: null,
        limitExceeded: false,
        error: null,
      };
    case 'INVITE_ACTION_FAILED':
      return {
        ...state,
        error: action.payload,
      };
    case 'RESET_ALL_STATE':
      initialState;
    default:
      return state;
  }
};

export default invitesReducer;


--- FILE: src/redux/reducers/join.reducer.jsx ---

//* join.reducer.jsx

const initialInviteState = {
  inviteFound: false,
  inviteData: null,
  accountFound: false,
  accountData: null,
  error: false,
  errorMsg1: '',
  errorMsg2: '',
};

const joinInviteReducer = (state = initialInviteState, action) => {
  switch (action.type) {
    case 'SET_INVITE_DATA':
      return {
        ...state,
        inviteFound: true,
        inviteData: action.payload,
        error: false,
        errorMsg1: '',
        errorMsg2: '',
      };

    case 'INVITE_EXPIRED':
    case 'INVITE_NOT_FOUND':
    case 'INVITE_LOOKUP_FAILED':
      return {
        ...state,
        inviteFound: false,
        inviteData: null,
        error: true,
        errorMsg1: action.payload.msg1,
        errorMsg2: action.payload.msg2,
      };

    case 'SET_TEMP_ACCOUNT_DATA':
      return {
        ...state,
        accountFound: true,
        accountData: action.payload,
        error: false,
      };
    case 'TEMP_ACCOUNT_DATA_FAILED':
      return {
        ...state,
        accountFound: false,
        accountData: null,
        error: true,
      };
    case 'RESET_ALL_STATE':
    case 'CLEAR_TEMP_ACCOUNT_DATA':
    case 'CLEAR_INVITE_DATA':
      return initialInviteState;

    default:
      return state;
  }
};

export default joinInviteReducer;


--- FILE: src/redux/reducers/profile.reducer.jsx ---

//* profile.reducer.jsx
const initialState = {
  profile: null,
  error: null,
};

const profileReducer = (state = initialState, action) => {
  switch (action.type) {
    // ✅ Fetched and set
    case 'SET_PROFILE':
      return {...state, profile: action.payload};

    // ✅ New profile created
    case 'PROFILE_CREATE_SUCCESS':
      return {...state, profile: action.payload, error: null};
    case 'PROFILE_CREATE_FAILURE':
      return {...state, error: action.payload};

    // ✅ Profile updated
    case 'UPDATE_PROFILE_SUCCESS':
      return {
        ...state,
        profile: {
          ...state.profile,
          ...action.payload,
        },
      };
    case 'UPDATE_PROFILE_FAILED':
    case 'PROFILE_FETCH_FAILED':
      return {...state, error: action.payload};

    // 🔄 Reset cases
    case 'RESET_PROFILE_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default profileReducer;


--- FILE: src/redux/reducers/recipe.reducer.jsx ---

// recipe.reducer.jsx
const initialState = {
  communityRecipes: [],
  recipeBox: [],
  loading: false,
  error: null,
};

export default function recipeReducer(state = initialState, action) {
  switch (action.type) {
    // 🔄 Fetching
    case 'FETCH_RECIPE_BOX':
      return {...state, loading: true, error: null};
    case 'SET_RECIPE_BOX':
      return {...state, recipeBox: action.payload, loading: false, error: null};
    case 'RECIPE_BOX_SET_FAILED':
      return {...state, loading: false, error: action.payload};

    case 'FETCH_COMMUNITY_RECIPES':
      return {
        ...state,
        loading: true,
        error: null,
      };
    case 'SET_COMMUNITY_RECIPES':
      return {
        ...state,
        communityRecipes: action.payload,
        loading: false,
        error: null,
      };
    case 'SET_COMMUNITY_RECIPES_ERROR':
      return {
        ...state,
        loading: false,
        error: action.payload,
      };
    case 'RESET_COMMUNITY_RECIPES':
      return {
        ...state,
        communityRecipes: [],
        loading: false,
        error: null,
      };

    // ➕ Add Item
    case 'ADD_ITEM_TO_RECIPE_BOX':
      return {...state, loading: true, error: null};
    case 'BOOKMARK_TO_RECIPE_BOX':
      return {...state, loading: true, error: null};
    case 'ADD_TO_COMMUNITY_RECIPES':
      return {...state, loading: true, error: null};
    case 'RECIPE_BOX_ADD_FAILED':
      return {...state, loading: false, error: action.payload};
    case 'COMMUNITY_ADD_FAILED':
      return {...state, loading: false, error: action.payload};
    case 'RECIPE_BOX_UPDATE_FAILED':
      return {...state, loading: false, error: action.payload};
    case 'BOOKMARK_ADD_FAILED':
      return {...state, loading: false, error: action.payload};

    // ✏️ Update Item
    case 'UPDATE_ITEM_IN_RECIPE_BOX':
      return {...state, loading: true, error: null};
    case 'RECIPE_BOX_UPDATE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};
    case 'UPDATE_TO_COMMUNITY_RECIPES':
      return {...state, loading: true, error: null};
    case 'UPDATE_TO_COMMUNITY_RECIPES_FAILED':
      return {...state, loading: false, error: action.payload};

    // ❌ Delete Item
    case 'DELETE_ITEM_FROM_RECIPE_BOX':
      return {...state, loading: true, error: null};
    case 'RECIPE_BOX_DELETE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};
    case 'DELETE_FROM_COMMUNITY_RECIPES':
      return {...state, loading: true, error: null};
    case 'DELETE_FROM_COMMUNITY_RECIPES_FAILED':
      return {...state, loading: false, error: action.payload};

    // ❌ Delete List
    case 'DELETE_LIST_FROM_RECIPE_BOX':
      return {...state, loading: true, error: null};
    case 'RECIPE_BOX_DELETE_LIST_FAILED':
      return {...state, loading: false, error: action.payload};

    // ♻️ Reset
    case 'RESET_RECIPE_BOX':
      return {...state, loading: true, error: null};
    case 'RECIPE_BOX_RESET_FAILED':
      return {...state, loading: false, error: action.payload};

    case 'RESET_RECIPE_BOX_STATE':
      return {
        ...state,
        recipeBox: [],
        loading: false,
        error: null,
      };
    case 'RESET_ALL_STATE':
      return {
        ...state,
        recipeBox: [],
        loading: false,
        error: null,
      };

    default:
      return state;
  }
}


--- FILE: src/redux/reducers/shopCart.reducer.jsx ---

//*shopCart.reducer.jsx
const initialState = {
  shopping: null,
  loading: false,
  error: null,
};

const shoppingReducer = (state = initialState, action) => {
  switch (action.type) {
    // 🔄 Fetching
    case 'FETCH_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SET_SHOP_CART':
      return {...state, shopping: action.payload, loading: false, error: null};
    case 'SHOP_CART_SET_FAILED':
      return {...state, loading: false, error: action.payload};

    // ➕ Add Item
    case 'ADD_ITEM_TO_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_ADD_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ✏️ Update Item
    case 'UPDATE_ITEM_IN_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_UPDATE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ❌ Delete Item
    case 'DELETE_ITEM_FROM_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_DELETE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // ❌ Delete List
    case 'DELETE_LIST_FROM_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_DELETE_LIST_FAILED':
      return {...state, loading: false, error: action.payload};

    // 📦 Batch Add
    case 'BATCH_TO_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_BATCH_ADD_START':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_BATCH_ADD_SUCCESS':
      return {...state, loading: false, error: null};
    case 'SHOP_CART_BATCH_ADD_FAILED':
      return {...state, loading: false, error: action.payload};

    // ♻️ Reset
    case 'RESET_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_RESET_FAILED':
      return {...state, loading: false, error: action.payload};

    case 'RESET_SHOP_CART_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default shoppingReducer;


--- FILE: src/redux/reducers/user.reducer.jsx ---

//* user.reducer.jsx
const initialState = {
  data: null,
  loading: false,
  error: null,
  isAuthenticated: false,
};

const userReducer = (state = initialState, action) => {
  switch (action.type) {
    // 🔐 Signup Flow
    case 'USER_SIGNUP_REQUEST':
      return {...state, loading: true, error: null};
    case 'USER_SIGNUP_SUCCESS':
      return {
        ...state,
        data: action.payload,
        loading: false,
        error: null,
        isAuthenticated: true,
      };
    case 'USER_SIGNUP_FAILURE':
      return {
        ...state,
        loading: false,
        error: action.error,
        isAuthenticated: false,
      };

    // 🔓 Login Flow
    case 'LOGIN_REQUEST':
      return {...state, loading: true, error: null};
    case 'SET_USER':
      return {
        ...state,
        data: action.payload,
        loading: false,
        error: null,
        isAuthenticated: true,
      };
    case 'LOGIN_FAILED':
      return {
        ...state,
        loading: false,
        error: action.payload,
        isAuthenticated: false,
      };

    // 🔒 Logout & Reset
    case 'UNSET_USER':
      return {...initialState, loading: false};
    case 'LOGOUT':
      return initialState;
    case 'RESET_USER_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default userReducer;


--- FILE: src/redux/sagas/_root.saga.jsx ---

import {all, fork} from 'redux-saga/effects';
import userSaga from './user.saga';
import profileSaga from './profile.saga';
import accountSaga from './account.saga';
import shoppingSaga from './shopCart.saga';
import cupboardSaga from './cupboard.saga';
import deviceSaga from './device.saga';
import invitesSaga from './invites.saga';
import edamamSaga from './edamam.saga';
import recipeSaga from './recipe.saga';
import loginSaga from './login.saga';
import signupSaga from './signup.saga';
import joinSaga from './join.saga';
import favoriteSaga from './favorites.saga';

export default function* rootSaga() {
  yield all([
    fork(userSaga),
    fork(profileSaga),
    fork(accountSaga),
    fork(shoppingSaga),
    fork(cupboardSaga),
    fork(deviceSaga),
    fork(invitesSaga),
    fork(edamamSaga),
    fork(recipeSaga),
    fork(loginSaga),
    fork(signupSaga),
    fork(joinSaga),
    fork(favoriteSaga),
  ]);
}


--- FILE: src/redux/sagas/account.saga.jsx ---

//*account.saga.jsx
import {put, takeLatest, call, all} from 'redux-saga/effects';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
  serverTimestamp,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';

const db = getFirestore(getApp());

// New Process
function* fetchAccount(action) {
  const {account, id} = action.payload;

  try {
    const accountRef = doc(db, 'accounts', account);
    const accountDoc = yield call(getDoc, accountRef);

    if (accountDoc.exists) {
      const accountData = accountDoc.data();

      const isAllowed = accountData?.allowedUsers?.includes(id);

      if (isAllowed) {
        yield put({
          type: 'SET_ACCOUNT',
          payload: {
            ...accountData,
            lastUpdated:
              accountData?.lastUpdated?.toDate?.().toISOString() ?? null,
            createdOn: accountData?.createdOn?.toDate?.().toISOString() ?? null,
          },
        });
      } else {
        yield put({type: 'SET_ACCOUNT', payload: null});
      }
    } else {
      yield put({type: 'SET_ACCOUNT', payload: null});
    }
  } catch (error) {
    yield put({type: 'ACCOUNT_FETCH_FAILED', payload: error.message});
  }
}

// Needs update
function* fetchAllowedProfiles(action) {
  const {allowedUsers} = action.payload;
  try {
    const profilesPromises = allowedUsers.map(userId =>
      call(getDoc, doc(db, 'profiles', userId)),
    );

    const profilesSnapshots = yield all(profilesPromises);

    const allowedProfiles = profilesSnapshots
      .map(snapshot => {
        if (!snapshot.exists) return null;

        const profileData = snapshot.data();
        return {
          id: snapshot.id,
          firstName: profileData?.firstName || '',
          lastName: profileData?.lastName || '',
          onlineName: profileData?.onlineName || '',
          email: profileData?.email || '',
          role: profileData?.role || 'user',
        };
      })
      .filter(Boolean);

    yield put({type: 'SET_ALLOWED_PROFILES', payload: allowedProfiles});
  } catch (error) {
    // console.error('[Saga] ❌ Fetch Allowed Profiles Error:', error);
    yield put({type: 'FETCH_ALLOWED_PROFILES_FAILED', payload: error.message});
  }
}

function* updateAccount(action) {
  const {profileID, accountID, updatedData} = action.payload;
  try {
    const accountRef = doc(db, 'accounts', accountID);
    const updatedAccount = {
      ...updatedData,
      lastUpdated: serverTimestamp(),
      lastUpdatedBy: profileID,
    };

    yield call(updateDoc, accountRef, updatedAccount);
    yield put({type: 'UPDATE_ACCOUNT_SUCCESS', payload: updatedAccount});
  } catch (error) {
    // console.error('[Saga] ❌ Update Profile Error:', error);
    yield put({type: 'UPDATE_ACCOUNT_FAILED', payload: error.message});
  }
}

function* countUpDaily(action) {
  const {profileID, accountID, updatedData} = action.payload;

  try {
    const accountRef = doc(db, 'accounts', accountID);
    const updatedAccount = {
      ...updatedData,
      lastUpdated: serverTimestamp(),
      lastUpdatedBy: profileID,
    };

    yield call(updateDoc, accountRef, updatedAccount);
    yield put({type: 'DAILY_COUNTUP_SUCCESS', payload: updatedAccount});
  } catch (error) {
    // console.error('[Saga] ❌ Update Profile Error:', error);
    yield put({type: 'DAILY_COUNTUP_FAILED', payload: error.message});
  }
}

export default function* accountSaga() {
  yield takeLatest('FETCH_ACCOUNT', fetchAccount);
  yield takeLatest('FETCH_ALLOWED_PROFILES', fetchAllowedProfiles);
  yield takeLatest('UPDATE_ACCOUNT', updateAccount);
  yield takeLatest('COUNT_UP_DAILY', countUpDaily);
}


--- FILE: src/redux/sagas/cupboard.saga.jsx ---

//*cupboard.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import uuid from 'react-native-uuid';
import Toast from 'react-native-toast-message';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
  writeBatch,
  serverTimestamp,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';
import {select} from 'redux-saga/effects';
import {checkLimit} from '../../utilities/checkLimit';

const db = getFirestore(getApp());

function* fetchCupboard(action) {
  const {cupboardID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      let cupboardData = cupboardDoc.data();

      if (!cupboardData.items) {
        cupboardData = {...cupboardData, items: []};

        yield call(() =>
          updateDoc(cupboardRef, {
            items: [],
            lastUpdated: serverTimestamp(),
          }),
        );
      }

      let cupboard = {
        ...cupboardData,
        createdOn: cupboardData?.createdOn?.toDate?.().toISOString() ?? null,
        lastUpdated: cupboardData?.lastUpdated.toDate?.().toISOString() ?? null,
      };

      yield put({type: 'SET_CUPBOARD', payload: cupboard});
    } else {
      yield put({type: 'SET_CUPBOARD', payload: null});
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_SET_FAILED', payload: error.message});
  }
}

function* addItemToCupboard(action) {
  const {cupboardID, newItem, profileID} = action.payload;
  try {
    const account = yield select(state => state.account.account);
    const cupboard = yield select(state => state.cupboard.cupboard);

    const maxCupboardItems = account?.cupboardLimit || 0;
    const cupboardLength = cupboard?.items?.length || 0;

    const isAllowed = checkLimit({
      current: cupboardLength,
      max: maxCupboardItems,
      label: 'Cupboard',
    });

    if (!isAllowed) return;

    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();

      const updatedItems = [
        ...(cupboardData.items || []),
        {
          ...newItem,
          itemId: uuid.v4(),
          createdBy: profileID,
          itemDate: new Date().toISOString(),
        },
      ];

      yield call(() =>
        updateDoc(cupboardRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Added',
        text2: `${newItem.itemName} added to the cupboard.`,
      });
    } else {
      yield put({
        type: 'CUPBOARD_ADD_ITEM_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Add Item',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_ADD_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Add Item',
      text2: `${newItem.itemName} could not be added. Please try again later.`,
    });
  }
}

function* updateItemInCupboard(action) {
  const {cupboardID, updatedItem, profileID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();
      const updatedItems = cupboardData?.items?.map(item =>
        item.itemId === updatedItem.itemId ? updatedItem : item,
      );

      yield call(() =>
        updateDoc(cupboardRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Updated',
        text2: `${updatedItem.itemName} updated in the cupboard.`,
      });
    } else {
      yield put({
        type: 'CUPBOARD_UPDATE_ITEM_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Update Item',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_UPDATE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Update Item',
      text2: `${updatedItem.itemName} could not be updated. Please try again later.`,
    });
  }
}

function* deleteItemFromCupboard(action) {
  const {cupboardID, itemId, itemName, profileID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();

      const updatedItems = cupboardData?.items?.filter(
        item => item.itemId !== itemId,
      );

      yield call(() =>
        updateDoc(cupboardRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Deleted',
        text2: `${itemName} removed from the cupboard.`,
      });
    } else {
      yield put({
        type: 'CUPBOARD_DELETE_ITEM_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Delete Item',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_DELETE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Delete Item',
      text2: `${itemName} could not be removed. Please try again later.`,
    });
  }
}

function* batchToCupboard(action) {
  // This function is used to add multiple items to the cupboard at once from checkout
  const {cupboardID, items, profileID} = action.payload;

  try {
    const account = yield select(state => state.account.account);
    const cupboard = yield select(state => state.cupboard.cupboard);

    const maxCupboardItems = account?.cupboardLimit || 0;
    const cupboardLength = cupboard?.items?.length || 0;

    const incomingItemCount = items.reduce((total, item) => {
      return total + (item.quantity > 0 ? item.quantity : 1);
    }, 0);

    const isAllowed = checkLimit({
      current: cupboardLength,
      incoming: incomingItemCount,
      max: maxCupboardItems,
      label: 'Cupboard',
    });

    if (!isAllowed) return;

    yield put({type: 'CUPBOARD_BATCH_ADD_START'});

    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();
      const batch = writeBatch(db);
      let updatedItems = [...(cupboardData.items || [])];

      items.forEach(item => {
        const {
          itemName,
          brandName,
          description,
          packageSize,
          measurement,
          category,
          notes,
        } = item;

        for (let i = 0; i < item.quantity; i++) {
          const newItem = {
            itemName: itemName || '',
            brandName: brandName || '',
            description: description || '',
            packageSize: Number(packageSize) || 1,
            remainingAmount: Number(packageSize) || 1,
            measurement: measurement || '',
            category: category || '',
            notes: notes || '',
            itemId: uuid.v4(),
            itemDate: new Date().toISOString(),
            createdBy: profileID,
          };

          updatedItems.push(newItem);
        }
      });

      batch.update(cupboardRef, {
        items: updatedItems,
        lastUpdated: serverTimestamp(),
        lastUpdatedBy: profileID,
      });

      yield call(() => batch.commit());

      Toast.show({
        type: 'success',
        text1: 'Items Added',
        text2: `Items were added to the cupboard.`,
      });

      yield put({type: 'CUPBOARD_BATCH_ADD_SUCCESS'});

      yield put({
        type: 'DELETE_LIST_FROM_SHOP_CART',
        payload: {
          shoppingCartID: account.shoppingCartID,
          items,
          profileID,
        },
      });
    } else {
      yield put({
        type: 'CUPBOARD_BATCH_ADD_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Batch Add Failed',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_BATCH_ADD_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Batch Add Failed',
      text2:
        'Items could not be added to the cupboard. Please try again later.',
    });
  }
}

function* batchAddToCupboard(action) {
  // This is the same as batchToCupboard but for adding a single item multiple times using a quantity
  const {cupboardID, newItem, quantity, profileID} = action.payload;

  try {
    const account = yield select(state => state.account.account);
    const cupboard = yield select(state => state.cupboard.cupboard);

    const maxCupboardItems = account?.cupboardLimit || 0;
    const cupboardLength = cupboard?.items?.length || 0;

    const isAllowed = checkLimit({
      current: cupboardLength,
      incoming: quantity,
      max: maxCupboardItems,
      label: 'Cupboard',
    });

    if (!isAllowed) return;

    yield put({type: 'CUPBOARD_BATCH_ADD_START'});

    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();
      const batch = writeBatch(db);
      let updatedItems = [...(cupboardData.items || [])];

      const {
        itemName,
        brandName,
        description,
        packageSize,
        measurement,
        category,
        notes,
      } = newItem;

      for (let i = 0; i < quantity; i++) {
        const item = {
          itemName: itemName || '',
          brandName: brandName || '',
          description: description || '',
          packageSize: Number(packageSize) || 1,
          remainingAmount: Number(packageSize) || 1,
          measurement: measurement || '',
          category: category || '',
          notes: notes || '',
          itemId: uuid.v4(),
          itemDate: new Date().toISOString(),
          createdBy: profileID,
        };

        updatedItems.push(item);
      }

      batch.update(cupboardRef, {
        items: updatedItems,
        lastUpdated: serverTimestamp(),
        lastUpdatedBy: profileID,
      });

      yield call(() => batch.commit());

      Toast.show({
        type: 'success',
        text1: 'Items Added',
        text2: `${quantity} ${itemName}'s were added to the cupboard.`,
      });

      yield put({type: 'CUPBOARD_BATCH_ADD_SUCCESS'});
    } else {
      yield put({
        type: 'CUPBOARD_BATCH_ADD_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Batch Add Failed',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_BATCH_ADD_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Batch Add Failed',
      text2:
        'Items could not be added to the cupboard. Please try again later.',
    });
  }
}

function* resetCupboard(action) {
  const {cupboardID, profileID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      yield call(() =>
        updateDoc(cupboardRef, {
          items: [],
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Cupboard Reset',
        text2: 'Your cupboard has been cleared.',
      });
    } else {
      Toast.show({
        type: 'warning',
        text1: 'No Cupboard Found',
        text2: 'Could not find a cupboard to reset.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_RESET_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Reset Failed',
      text2: 'Your cupboard could not be reset. Please try again later.',
    });
  }
}

export default function* cupboardSaga() {
  yield takeLatest('FETCH_CUPBOARD', fetchCupboard);
  yield takeLatest('ADD_ITEM_TO_CUPBOARD', addItemToCupboard);
  yield takeLatest('UPDATE_ITEM_IN_CUPBOARD', updateItemInCupboard);
  yield takeLatest('DELETE_ITEM_FROM_CUPBOARD', deleteItemFromCupboard);
  yield takeLatest('BATCH_TO_CUPBOARD', batchToCupboard);
  yield takeLatest('BATCH_ADD_TO_CUPBOARD', batchAddToCupboard);
  yield takeLatest('RESET_CUPBOARD', resetCupboard);
}


--- FILE: src/redux/sagas/device.saga.jsx ---

//* device.saga.jsx
import {put, takeLatest, call, take} from 'redux-saga/effects';
import {
  getBrand,
  getDeviceType,
  isLandscape,
  getModel,
  getSystemName,
  getSystemVersion,
  hasNotch,
} from 'react-native-device-info';
import {Dimensions} from 'react-native';
import {eventChannel} from 'redux-saga';

function createDimensionChannel() {
  return eventChannel(emitter => {
    const updateDimensions = () => emitter(Dimensions.get('window'));
    const subscription = Dimensions.addEventListener(
      'change',
      updateDimensions,
    );
    return () => subscription?.remove();
  });
}

function* watchDeviceDimensions() {
  const channel = createDimensionChannel();
  try {
    while (true) {
      yield take(channel);
      yield call(fetchDeviceInfo);
    }
  } finally {
    channel.close();
  }
}

function* fetchDeviceInfo() {
  try {
    const {width, height} = Dimensions.get('window');
    const ratio = (Math.sqrt(width ** 2 + height ** 2) / 100).toFixed(1);

    const brand = yield call(getBrand);
    const formattedBrand = brand.charAt(0).toUpperCase() + brand.slice(1);

    // device size category
    let sizeForDevice = 'xSmall';
    if (ratio >= 10.5) sizeForDevice = 'xLarge';
    else if (ratio >= 9.7) sizeForDevice = 'large';
    else if (ratio >= 9.4) sizeForDevice = 'medium';
    else if (ratio >= 9.0) sizeForDevice = 'small';

    // ✅ Each call individually resolved
    const deviceType = yield call(getDeviceType);
    const model = yield call(getModel);
    const os = yield call(getSystemName);
    const version = yield call(getSystemVersion);
    const notch = yield call(hasNotch);
    const landscape = yield call(isLandscape);

    const deviceInfo = {
      dimensions: {
        height: Number(height.toFixed(2)),
        width: Number(width.toFixed(2)),
        ratio: Number(ratio),
      },
      system: {
        brand: formattedBrand,
        device: deviceType,
        deviceSize: sizeForDevice,
        model,
        os,
        version,
        notch,
      },
      view: landscape ? 'Landscape' : 'Portrait',
    };

    yield put({type: 'SET_DEVICE_INFO', payload: deviceInfo});
  } catch (error) {
    yield put({type: 'DEVICE_INFO_FETCH_FAILED', payload: error.message});
  }
}

export default function* deviceSaga() {
  yield takeLatest('FETCH_DEVICE_INFO', fetchDeviceInfo);
  yield call(watchDeviceDimensions); // watches for dimension changes
}


--- FILE: src/redux/sagas/edamam.saga.jsx ---

//* edaman.saga.jsx
import {takeLatest, call, put} from 'redux-saga/effects';
import {fetchRemoteKeys} from '../../../firebase.config';

function* fetchFoodData(action) {
  const {barcode, allowance, profileID, accountID} = action.payload;

  const {food} = yield call(fetchRemoteKeys);
  const appId = food.appId;
  const appKey = food.appKey;

  const url = `https://api.edamam.com/api/food-database/v2/parser?app_id=${appId}&app_key=${appKey}&upc=${barcode}`;

  try {
    const response = yield call(fetch, url);

    if (response.ok) {
      const data = yield response.json();

      if (data.hints && data.hints.length > 0) {
        yield put({type: 'SET_FOOD_DATA', payload: data});
        yield put({
          type: 'COUNT_UP_DAILY',
          payload: {
            updatedData: {
              dailyUPCCounter: allowance + 1,
            },
            profileID,
            accountID,
          },
        });
      } else {
        yield put({
          type: 'FOOD_API_FETCH_FAILED',
          payload: `No food found for UPC: ${barcode}`,
        });
      }
    } else {
      yield put({
        type: 'FOOD_API_FETCH_FAILED',
        payload: `API error: ${response.status}`,
      });
    }
  } catch (error) {
    yield put({type: 'FOOD_API_FETCH_FAILED', payload: error.message});
  }
}

// Watcher saga for Edamam API actions
export default function* edamamSaga() {
  yield takeLatest('FETCH_FOOD_DATA', fetchFoodData);
}


--- FILE: src/redux/sagas/favorites.saga.jsx ---

//*favorite.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import uuid from 'react-native-uuid';
import Toast from 'react-native-toast-message';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
  serverTimestamp,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';
import {select} from 'redux-saga/effects';
import {checkLimit} from '../../utilities/checkLimit';

const db = getFirestore(getApp());

function* fetchFavorites(action) {
  const {favoriteItemsID} = action.payload;
  try {
    const favoritesRef = doc(db, 'favoriteItems', favoriteItemsID);
    const favoritesDoc = yield call(getDoc, favoritesRef);

    if (favoritesDoc.exists) {
      let favoritesData = favoritesDoc.data();

      if (!favoritesData.items) {
        favoritesData = {...favoritesData, items: []};

        yield call(() =>
          updateDoc(favoritesRef, {
            items: [],
            lastUpdated: serverTimestamp(),
          }),
        );
      }

      let favorite = {
        ...favoritesData,
        createdOn: favoritesData?.createdOn?.toDate?.().toISOString() ?? null,
        lastUpdated:
          favoritesData?.lastUpdated?.toDate?.().toISOString() ?? null,
      };

      yield put({type: 'SET_FAVORITES', payload: favorite});
    } else {
      yield put({type: 'SET_FAVORITES', payload: null});
    }
  } catch (error) {
    yield put({type: 'FAVORITES_SET_FAILED', payload: error.message});
  }
}

function* addItemToFavorites(action) {
  const {favoriteItemsID, newItem, profileID} = action.payload;
  try {
    const account = yield select(state => state.account.account);
    const favorites = yield select(state => state.favorites.favorites);

    const maxFavoriteItems = account?.favoriteItemsLimit || 0;
    const favoritesLength = favorites?.items?.length || 0;

    const isAllowed = checkLimit({
      current: favoritesLength,
      max: maxFavoriteItems,
      label: 'Favorites',
    });

    if (!isAllowed) return;

    const favoritesRef = doc(db, 'favoriteItems', favoriteItemsID);
    const favoritesDoc = yield call(getDoc, favoritesRef);

    if (favoritesDoc.exists) {
      const favoritesData = favoritesDoc.data();

      const updatedItems = [
        ...(favoritesData.items || []),
        {
          ...newItem,
          itemId: uuid.v4(),
          createdBy: profileID,
          itemDate: new Date().toISOString(),
        },
      ];

      yield call(() =>
        updateDoc(favoritesRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Added',
        text2: `${newItem.itemName} added to the favorites.`,
      });
    } else {
      yield put({
        type: 'FAVORITES_ADD_ITEM_FAILED',
        payload: 'Favorites not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Add Item',
        text2: 'Favorites not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'FAVORITES_ADD_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Add Item',
      text2: `${newItem.itemName} could not be added. Please try again later.`,
    });
  }
}

function* updateItemInFavorites(action) {
  const {favoriteItemsID, updatedItem, updateType, profileID} = action.payload;
  try {
    const favoritesRef = doc(db, 'favoriteItems', favoriteItemsID);
    const favoritesDoc = yield call(getDoc, favoritesRef);

    if (favoritesDoc.exists) {
      const favoritesData = favoritesDoc.data();
      const updatedItems = favoritesData?.items?.map(item =>
        item.itemId === updatedItem.itemId ? updatedItem : item,
      );

      yield call(() =>
        updateDoc(favoritesRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      if (updateType === 'updateList') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} was updated in the favorites.`,
        });
      } else if (updateType === 'updateCart') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} was updated in the favorites.`,
        });
      } else if (updateType === 'toCart') {
        Toast.show({
          type: 'success',
          text1: 'Item Added',
          text2: `${updatedItem.itemName} moved to the favorites.`,
        });
      } else if (updateType === 'toList') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} moved to the favorites.`,
        });
      } else if (updateType === 'toCupboard') {
        // No toast needed, as the cupboard logic handles it
      } else {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} updated to the favorites.`,
        });
      }
    } else {
      yield put({
        type: 'FAVORITES_UPDATE_ITEM_FAILED',
        payload: 'Favorites not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Update Item',
        text2: 'Favorites not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'FAVORITES_UPDATE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Update Item',
      text2: `${updatedItem.itemName} could not be updated. Please try again later.`,
    });
  }
}

function* deleteItemFromFavorites(action) {
  const {favoriteItemsID, itemId, itemName, profileID} = action.payload;
  try {
    const favoritesRef = doc(db, 'favoriteItems', favoriteItemsID);
    const favoritesDoc = yield call(getDoc, favoritesRef);

    if (favoritesDoc.exists) {
      const favoritesData = favoritesDoc.data();

      const updatedItems = favoritesData?.items?.filter(
        item => item.itemId !== itemId,
      );

      yield call(() =>
        updateDoc(favoritesRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Deleted',
        text2: `${itemName} removed from the favorites.`,
      });
    } else {
      yield put({
        type: 'FAVORITES_DELETE_ITEM_FAILED',
        payload: 'Favorites not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Delete Item',
        text2: 'Favorites not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'FAVORITES_DELETE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Delete Item',
      text2: `${itemName} could not be removed. Please try again later.`,
    });
  }
}

function* resetFavorites(action) {
  const {favoriteItemsID, profileID} = action.payload;
  try {
    const favoritesRef = doc(db, 'favoriteItems', favoriteItemsID);
    const favoritesDoc = yield call(getDoc, favoritesRef);

    if (favoritesDoc.exists) {
      yield call(() =>
        updateDoc(favoritesRef, {
          items: [],
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      yield put({type: 'SET_FAVORITES', payload: {favoriteItemsID}});

      Toast.show({
        type: 'success',
        text1: 'Favorites List Reset',
        text2: 'Your favorites has been cleared.',
      });
    } else {
      Toast.show({
        type: 'warning',
        text1: 'No Favorites Found',
        text2: 'Could not find a favorite to reset.',
      });
    }
  } catch (error) {
    yield put({type: 'FAVORITES_RESET_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Reset Failed',
      text2: 'Your favorites could not be reset. Please try again later.',
    });
  }
}

export default function* favoriteSaga() {
  yield takeLatest('FETCH_FAVORITES', fetchFavorites);
  yield takeLatest('ADD_ITEM_TO_FAVORITES', addItemToFavorites);
  yield takeLatest('UPDATE_ITEM_IN_FAVORITES', updateItemInFavorites);
  yield takeLatest('DELETE_ITEM_FROM_FAVORITES', deleteItemFromFavorites);
  yield takeLatest('RESET_FAVORITES', resetFavorites);
}


--- FILE: src/redux/sagas/invites.saga.jsx ---

// invites.saga.jsx
import {put, call, takeLatest} from 'redux-saga/effects';
import {
  getFirestore,
  getDoc,
  setDoc,
  updateDoc,
  deleteDoc,
  doc,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';

const db = getFirestore(getApp());

function* queueInviteSaga(action) {
  const {invite, accountID, resolve, reject} = action.payload;

  try {
    const accountRef = doc(db, 'accounts', accountID);
    const accountSnap = yield call(getDoc, accountRef);
    if (!accountSnap.exists) throw new Error('Account not found.');

    const accountData = accountSnap.data();
    const currentUsers = accountData.allowedUsers?.length || 0;
    const currentInviteCodes = accountData.accountInvites || [];

    const now = Date.now();
    const cutoff = now - 7 * 24 * 60 * 60 * 1000; // 7 days

    let activeInvites = [];
    let reusedInvite = null;
    let expiredCodes = [];

    // 🔍 Check each invite code
    for (let code of currentInviteCodes) {
      const ref = doc(db, 'accountInvites', code);
      const snap = yield call(getDoc, ref);

      if (snap.exists) {
        const data = snap.data();
        const expireTime = new Date(data.toExpire).getTime();

        if (expireTime < cutoff) {
          // expired, delete it
          yield call(deleteDoc, ref);
          expiredCodes.push(code);
        } else {
          // reused email logic
          if (data.email === invite.email) reusedInvite = data;
          activeInvites.push(data);
        }
      } else {
        // dangling ref
        expiredCodes.push(code);
      }
    }

    // 🧹 Clean up account's invite array
    if (expiredCodes.length > 0) {
      const cleanedCodes = currentInviteCodes.filter(
        code => !expiredCodes.includes(code),
      );
      yield call(updateDoc, accountRef, {accountInvites: cleanedCodes});
    }

    // 🔁 Reuse existing invite
    if (reusedInvite) {
      const inviteRef = doc(db, 'accountInvites', reusedInvite.inviteCode);
      const updated = {
        ...reusedInvite,
        toExpire: new Date().toISOString(),
      };
      yield call(setDoc, inviteRef, updated);
      yield put({type: 'SET_EXISTING_INVITE', payload: updated});
      resolve?.({existing: true, invite: updated});
      return;
    }

    // ✅ Now check available slots AFTER cleaning
    const cleanedInviteCodes = currentInviteCodes.filter(
      code => !expiredCodes.includes(code),
    );
    const cleanedInviteCount = activeInvites.length;
    const slotsRemaining = Math.max(0, 4 - (currentUsers + cleanedInviteCount));

    if (slotsRemaining <= 0) {
      yield put({type: 'SET_EXCEEDING_LIMITS'});
      yield put({type: 'SET_EXISTING_INVITE', payload: null});
      resolve?.({existing: false, invite: null, exceeding: true});
      return;
    }

    // ✳️ Create new invite
    const inviteRef = doc(db, 'accountInvites', invite.inviteCode);
    yield call(setDoc, inviteRef, invite);

    const updatedInviteCodes = [...cleanedInviteCodes, invite.inviteCode];
    yield call(updateDoc, accountRef, {
      accountInvites: updatedInviteCodes,
    });

    yield put({type: 'SET_EXISTING_INVITE', payload: invite});
    resolve?.({existing: false, invite});
  } catch (error) {
    console.error('🔥 queueInviteSaga error:', error);
    yield put({type: 'INVITE_ACTION_FAILED', payload: error.message});
    reject?.(error);
  }
}

function* deleteInvite(action) {
  const {inviteCode} = action.payload;
  try {
    const inviteRef = doc(db, 'accountInvites', inviteCode);
    yield call(deleteDoc, inviteRef);
    yield put({type: 'DELETE_INVITE_SUCCESS', payload: inviteCode});
  } catch (error) {
    console.error('🔥 deleteInvite error:', error);
    yield put({type: 'DELETE_INVITE_FAILED', payload: error.message});
  }
}

export default function* invitesSaga() {
  yield takeLatest('QUEUE_INVITE_REQUEST', queueInviteSaga);
  yield takeLatest('DELETE_INVITE_REQUEST', deleteInvite);
}


--- FILE: src/redux/sagas/join.saga.jsx ---

//* join.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import {getFirestore, getDoc, doc} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';
import moment from 'moment';

const db = getFirestore(getApp());

function* checkJoinInvite(action) {
  const {inviteCode} = action.payload;

  try {
    const inviteRef = doc(db, 'accountInvites', inviteCode);
    const inviteSnap = yield call(getDoc, inviteRef);

    if (inviteSnap.exists) {
      const inviteData = inviteSnap.data();

      const expireMoment = moment
        .utc(inviteData.toExpire)
        .add(7, 'days')
        .startOf('day');
      const nowMoment = moment().startOf('day');
      const isExpired = nowMoment.isSameOrAfter(expireMoment);

      if (!isExpired) {
        yield put({
          type: 'SET_INVITE_DATA',
          payload: inviteData,
        });
      } else {
        yield put({
          type: 'INVITE_EXPIRED',
          payload: {
            error: true,
            msg1: 'Invitation Expired',
            msg2: 'Please check with the account owner.',
          },
        });
      }
    } else {
      yield put({
        type: 'INVITE_NOT_FOUND',
        payload: {
          error: true,
          msg1: 'Invitation Not Found',
          msg2: 'Please check the code and try again.',
        },
      });
    }
  } catch (error) {
    yield put({
      type: 'INVITE_LOOKUP_FAILED',
      payload: {
        error: true,
        msg1: 'Something Went Wrong',
        msg2: 'We couldn’t verify your code. Try again later.',
      },
    });
  }
}

function* checkJoinAccount(action) {
  const {accountID} = action.payload;
  try {
    const accountRef = doc(db, 'accounts', accountID);
    const accountSnap = yield call(getDoc, accountRef);
    if (accountSnap.exists) {
      const accountData = accountSnap.data();

      yield put({type: 'SET_TEMP_ACCOUNT_DATA', payload: accountData});
    }
  } catch (error) {
    yield put({type: 'TEMP_ACCOUNT_DATA_FAILED', payload: error.message});
  }
}

export default function* joinSaga() {
  yield takeLatest('CHECK_JOIN_INVITE', checkJoinInvite);
  yield takeLatest('CHECK_JOIN_ACCOUNT', checkJoinAccount);
  // Add other sagas here if needed
}


--- FILE: src/redux/sagas/login.saga.jsx ---

//* login.saga.jsx
import {put, takeLatest, select, call} from 'redux-saga/effects';

// Step 1: Fetch profile using user.uid
function* handleLogin(action) {
  try {
    const uid = action.payload;

    // ✅ Step 1: Fetch Profile
    yield put({type: 'FETCH_PROFILE', payload: {uid}});

    // Wait until profile is set in Redux
    const profile = yield call(waitForProfile);

    // ✅ Step 2: Fetch Account using profile.account & profile.id
    const {account, id} = profile;
    yield put({type: 'FETCH_ACCOUNT', payload: {account, id}});

    // Wait until account is set in Redux
    const accountData = yield call(waitForAccount);

    // ✅ Step 3: Fetch shoppingCart / cupboard / favorites
    const {shoppingCartID, cupboardID, favoriteItemsID, recipeBoxID} =
      accountData;
    yield put({type: 'FETCH_SHOP_CART', payload: {shoppingCartID}});
    yield put({type: 'FETCH_CUPBOARD', payload: {cupboardID}});
    yield put({type: 'FETCH_FAVORITES', payload: {favoriteItemsID}});
    yield put({type: 'FETCH_RECIPE_BOX', payload: {recipeBoxID}});
  } catch (error) {
    yield put({type: 'LOGIN_SEQUENCE_FAILED', payload: error.message});
  }
}

function* waitForProfile() {
  while (true) {
    const profile = yield select(state => state.profile.profile);
    if (profile) return profile;
    yield new Promise(resolve => setTimeout(resolve, 50));
  }
}

function* waitForAccount() {
  while (true) {
    const account = yield select(state => state.account.account);
    if (account) return account;
    yield new Promise(resolve => setTimeout(resolve, 50));
  }
}

export default function* loginSaga() {
  yield takeLatest('START_LOGIN', handleLogin);
}


--- FILE: src/redux/sagas/profile.saga.jsx ---

//*profile.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import Toast from 'react-native-toast-message';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
  serverTimestamp,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';

const db = getFirestore(getApp());

// New Process
function* fetchProfile(action) {
  const {uid} = action.payload;

  try {
    const profileRef = doc(db, 'profiles', uid);
    const profileDoc = yield call(getDoc, profileRef);

    if (profileDoc.exists) {
      const profileData = profileDoc.data();
      yield put({
        type: 'SET_PROFILE',
        payload: {
          ...profileData,
          lastUpdated:
            profileData?.lastUpdated?.toDate?.().toISOString() ?? null,
          createdOn: profileData?.createdOn?.toDate?.().toISOString() ?? null,
        },
      });
    } else {
      yield put({type: 'SET_PROFILE', payload: null});
    }
  } catch (error) {
    yield put({type: 'PROFILE_FETCH_FAILED', payload: error.message});
  }
}

// Needs update
function* updateProfile(action) {
  const {userId, updatedData} = action.payload;
  try {
    const profileRef = doc(db, 'profiles', userId);
    const updatedProfile = {
      ...updatedData,
      lastUpdated: serverTimestamp(),
    };

    yield call(updateDoc, profileRef, updatedProfile);
    yield put({type: 'UPDATE_PROFILE_SUCCESS', payload: updatedProfile});

    Toast.show({
      type: 'success',
      text1: 'Profile Updated',
      text2: 'Your profile has been updated.',
    });
  } catch (error) {
    // console.error('[Saga] ❌ Update Profile Error:', error);
    yield put({type: 'UPDATE_PROFILE_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Profile Update Failed',
      text2: 'Your profile could not be updated.',
    });
  }
}

export default function* profileSaga() {
  yield takeLatest('FETCH_PROFILE', fetchProfile);
  yield takeLatest('UPDATE_PROFILE_REQUEST', updateProfile);
}


--- FILE: src/redux/sagas/recipe.saga.jsx ---

// recipe.saga.jsx
import {put, takeLatest, call, select} from 'redux-saga/effects';
import uuid from 'react-native-uuid';
import Toast from 'react-native-toast-message';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
  writeBatch,
  serverTimestamp,
  setDoc,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';
import algoliasearch from 'algoliasearch';
import {fetchRemoteKeys} from '../../../firebase.config';
import {checkLimit} from '../../utilities/checkLimit';
import {capEachWord, capFirst} from '../../utilities/helpers';
import storage from '@react-native-firebase/storage';

const db = getFirestore(getApp());

function* fetchCommunityRecipes(action) {
  const {keywords, allowance, profileID, accountID} = action.payload;

  try {
    const trimmed = keywords?.trim();

    if (!trimmed || trimmed.length < 2) {
      yield put({type: 'SET_COMMUNITY_RECIPES', payload: []});
      return;
    }

    const keys = yield call(fetchRemoteKeys);
    const appID = keys?.algolia?.appID;
    const searchKey = keys?.algolia?.searchKey;

    if (!appID || !searchKey) {
      throw new Error('Algolia configuration missing from Remote Config!');
    }

    const client = algoliasearch(appID, searchKey);
    const index = client.initIndex('community_recipes');

    const {hits} = yield call([index, index.search], trimmed, {
      hitsPerPage: 20,
      attributesToRetrieve: ['id'],
    });

    const recipeIds = hits.map(hit => hit.id);
    if (recipeIds.length === 0) {
      yield put({type: 'SET_COMMUNITY_RECIPES', payload: []});
      return;
    }

    const fetchedRecipes = [];

    for (const id of recipeIds) {
      const recipeDocRef = doc(db, 'community', id);
      const recipeDocSnapshot = yield call(getDoc, recipeDocRef);

      if (recipeDocSnapshot.exists) {
        const data = recipeDocSnapshot.data();
        fetchedRecipes.push({
          id: recipeDocSnapshot.id,
          ...data,
          imageUri: `https://firebasestorage.googleapis.com/v0/b/kitchen-queue-fe2fe.firebasestorage.app/o/recipes%2F${encodeURIComponent(
            data.image,
          )}?alt=media`,
        });
      } else {
        // console.warn(`[Saga] Firestore doc missing for ID: ${id}`);
      }
    }
    yield put({
      type: 'COUNT_UP_DAILY',
      payload: {
        updatedData: {
          dailyRecipeCounter: allowance + 1,
        },
        profileID,
        accountID,
      },
    });
    yield put({type: 'SET_COMMUNITY_RECIPES', payload: fetchedRecipes});
  } catch (error) {
    // console.error('Algolia/Firestore search error:', error);
    Toast.show({
      type: 'error',
      text1: 'Search Error',
      text2: error.message || 'An unexpected error occurred during search.',
    });
    yield put({type: 'SET_COMMUNITY_RECIPES_ERROR', payload: error.message});
  }
}

function* bookmarkCommunityRecipes(action) {
  const {recipeBoxID, selectedRecipe, profileID} = action.payload;
  // console.log('action', action.payload);
  try {
    const account = yield select(state => state.account.account);
    const recipeBox = yield select(state => state.recipe.recipeBox);

    const maxRecipeBoxItems = account?.recipeBoxLimit || 0;
    const recipeBoxLength = recipeBox?.items?.length || 0;

    const isAllowed = checkLimit({
      current: recipeBoxLength,
      max: maxRecipeBoxItems,
      label: 'Recipe Box',
    });

    if (!isAllowed) return;

    const recipeBoxRef = doc(db, 'recipeBoxes', recipeBoxID);
    const recipeBoxDoc = yield call(getDoc, recipeBoxRef);

    if (recipeBoxDoc.exists) {
      const recipeBoxData = recipeBoxDoc.data();

      const updatedItems = [
        ...(recipeBoxData.items || []),
        {
          ...selectedRecipe,
          id: selectedRecipe.id,
          createdBy: profileID,
          itemDate: new Date().toISOString(),
        },
      ];

      // 🔑 Step 1: Upload image (if any)

      // 🔑 Step 2: Save recipe
      yield call(() =>
        updateDoc(recipeBoxRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      yield put({
        type: 'SET_RECIPE_BOX',
        payload: {
          ...recipeBoxData,
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
        },
      });

      Toast.show({
        type: 'success',
        text1: 'Recipe Added',
        text2: `${capEachWord(selectedRecipe?.title)} added to the recipe box.`,
      });
    } else {
      yield put({
        type: 'BOOKMARK_ADD_FAILED',
        payload: 'Recipe box not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Add Recipe',
        text2: 'Recipe box not found. Please try again later.',
      });
    }
  } catch (error) {
    // console.error(error);
    yield put({type: 'BOOKMARK_ADD_FAILED', payload: error.message});
    Toast.show({
      type: 'danger',
      text1: 'Failed to Add Recipe',
      text2: `${capEachWord(
        selectedRecipe?.title,
      )} could not be added.Please try again later.`,
    });
  }
}

function* addToCommunityRecipes(action) {
  // this comes from someone sharing their recipe
  // let {recipe, admin, recipeBoxID} = action.payload;
  // try {
  //   if (!recipe?.id) return;
  //   let docRef = doc(db, 'community', recipe.id);
  //   // Check if this ID already exists (1 read)
  //   const existing = yield call(getDoc, docRef);
  //   if (existing.exists()) {
  //     const newId = uuid.v4();
  //     recipe = {...recipe, id: newId};
  //     docRef = doc(db, 'community', newId);
  //   }
  //   recipe = {
  //     ...recipe,
  //     recipeShared: true,
  //     userEdit: false,
  //     sharedStatus: admin ? 'approved' : 'pending-review',
  //   };
  //   // Write recipe to community
  //   yield call(setDoc, docRef, recipe);
  //   // Update in recipeBox
  //   const recipeBoxRef = doc(db, 'recipeBoxes', recipeBoxID);
  //   const recipeBoxDoc = yield call(getDoc, recipeBoxRef);
  //   if (recipeBoxDoc.exists()) {
  //     const recipeBoxData = recipeBoxDoc.data();
  //     const updatedItems = (recipeBoxData.items || []).map(item =>
  //       item.id === (action.payload.recipe.id || recipe.id)
  //         ? {
  //             ...item,
  //             recipeShared: true,
  //             userEdit: false,
  //             sharedStatus: admin ? 'approved' : 'pending-review',
  //             ...(action.payload.recipe.id !== recipe.id && {id: recipe.id}),
  //           }
  //         : item,
  //     );
  //     yield call(updateDoc, recipeBoxRef, {
  //       items: updatedItems,
  //       lastUpdated: serverTimestamp(),
  //     });
  //     // ✅ update Redux immediately
  //     yield put({
  //       type: 'SET_RECIPE_BOX',
  //       payload: {
  //         ...recipeBoxData,
  //         items: updatedItems,
  //         lastUpdated: new Date().toISOString(),
  //       },
  //     });
  //   }
  //   Toast.show({
  //     type: 'success',
  //     text1: admin ? 'Recipe Added' : 'Recipe Submitted',
  //     text2: admin
  //       ? `${capEachWord(recipe?.title)} was added to the community recipes.`
  //       : `${capEachWord(
  //           recipe?.title,
  //         )} was submitted for review. You will be notified once it's approved.`,
  //   });
  // } catch (error) {
  //   yield put({type: 'COMMUNITY_ADD_FAILED', payload: error.message});
  //   Toast.show({
  //     type: 'danger',
  //     text1: 'Failed to Add Recipe',
  //     text2: `${capEachWord(
  //       recipe?.title,
  //     )} could not be added. Please try again later.`,
  //   });
  // }
}

function* updateToCommunityRecipes(action) {
  const {editedRecipe, finalImage, profileID, pictureWasChanged, oldImageName} =
    action.payload;

  try {
    const communityRef = doc(db, 'community', editedRecipe?.id);
    const communityDoc = yield call(getDoc, communityRef);

    if (communityDoc.exists()) {
      let imageSuccess = false;
      let imageDeleted = false;

      // 🔑 Step 1: Remove old image
      if (pictureWasChanged && oldImageName) {
        try {
          const oldImageRef = storage().ref(`recipes/${oldImageName}`);
          yield call([oldImageRef, oldImageRef.delete]);
          imageDeleted = true;
        } catch {
          imageDeleted = false;
        }
      }

      // 🔑 Step 2: Upload new image
      if (pictureWasChanged && finalImage) {
        try {
          const reference = storage().ref(`recipes/${finalImage.name}`);
          yield call([reference, reference.putFile], finalImage.uri);
          const downloadURL = yield call([reference, reference.getDownloadURL]);

          editedRecipe.imageUri = downloadURL;
          editedRecipe.image = finalImage.name;
          editedRecipe.imageDate = finalImage.imageDate;

          imageSuccess = true;
        } catch {
          imageSuccess = false;
        }
      }

      // 🔑 Step 3: Update Firestore doc
      yield call(updateDoc, communityRef, {
        ...editedRecipe,
        lastUpdated: serverTimestamp(),
        lastUpdatedBy: profileID,
      });

      // 🔑 Step 4: Get updated snapshot
      const updatedDoc = yield call(getDoc, communityRef);
      const updatedRecipe = {id: updatedDoc.id, ...updatedDoc.data()};

      // 🔑 Step 5: Update Redux state (replace recipe in array)
      const currentRecipes = yield select(
        state => state.recipe.communityRecipes,
      );
      const updatedList = currentRecipes.map(rec =>
        rec.id === updatedRecipe.id ? updatedRecipe : rec,
      );

      yield put({
        type: 'SET_COMMUNITY_RECIPES',
        payload: updatedList,
      });

      // 🔑 Step 6: Toast messages
      if (imageDeleted && imageSuccess && pictureWasChanged) {
        Toast.show({
          type: 'success',
          text1: 'Recipe Updated',
          text2: `${capEachWord(
            editedRecipe?.title,
          )} and its image were updated.`,
        });
      } else if (!imageDeleted && imageSuccess && pictureWasChanged) {
        Toast.show({
          type: 'success',
          text1: 'Recipe Updated',
          text2: `${capEachWord(editedRecipe?.title)} updated and image added.`,
        });
      } else if (pictureWasChanged && !imageSuccess) {
        Toast.show({
          type: 'warning',
          text1: 'Recipe Updated',
          text2: `${capEachWord(
            editedRecipe?.title,
          )} updated, but the new image could not be saved.`,
        });
      } else {
        Toast.show({
          type: 'success',
          text1: 'Recipe Updated',
          text2: `${capEachWord(editedRecipe?.title)} updated successfully.`,
        });
      }
    } else {
      yield put({
        type: 'UPDATE_TO_COMMUNITY_RECIPES_FAILED',
        payload: 'Recipe not found.',
      });
    }
  } catch (error) {
    yield put({
      type: 'UPDATE_TO_COMMUNITY_RECIPES_FAILED',
      payload: error.message,
    });
    Toast.show({
      type: 'danger',
      text1: 'Failed to Update Recipe',
      text2: `${capEachWord(
        editedRecipe?.title,
      )} could not be updated. Please try again later.`,
    });
  }
}

function* deleteFromCommunityRecipes(action) {
  // when admin deletes the community recipe
}

function* updateToCommunityRecipesRequest(action) {
  // when someone sends in a request to edit their recipe
}

function* deleteFromCommunityRecipesRequest(action) {
  // when someone sends in a request to delete their recipe
}

function* fetchPersonalRecipes(action) {
  const {recipeBoxID} = action.payload;
  try {
    const recipeBoxRef = doc(db, 'recipeBoxes', recipeBoxID);
    const recipeBoxDoc = yield call(getDoc, recipeBoxRef);

    if (recipeBoxDoc.exists) {
      let recipeBoxData = recipeBoxDoc.data();

      if (!recipeBoxData.items) {
        recipeBoxData = {...recipeBoxData, items: []};

        yield call(() =>
          updateDoc(recipeBoxRef, {
            items: [],
            lastUpdated: serverTimestamp(),
          }),
        );
      }

      let recipe = {
        ...recipeBoxData,
        createdOn: recipeBoxData?.createdOn?.toDate?.().toISOString() ?? null,
        lastUpdated:
          recipeBoxData?.lastUpdated?.toDate?.().toISOString() ?? null,
      };

      yield put({type: 'SET_RECIPE_BOX', payload: recipe});
    } else {
      yield put({type: 'SET_RECIPE_BOX', payload: null});
    }
  } catch (error) {
    yield put({type: 'RECIPE_BOX_SET_FAILED', payload: error.message});
  }
}

function* addToPersonalRecipes(action) {
  const {recipeBoxID, newRecipe, finalImage, profileID} = action.payload;
  // console.log('action', action.payload);
  try {
    const account = yield select(state => state.account.account);
    const recipeBox = yield select(state => state.recipe.recipeBox);

    const maxRecipeBoxItems = account?.recipeBoxLimit || 0;
    const recipeBoxLength = recipeBox?.items?.length || 0;

    const isAllowed = checkLimit({
      current: recipeBoxLength,
      max: maxRecipeBoxItems,
      label: 'Recipe Box',
    });

    if (!isAllowed) return;

    const recipeBoxRef = doc(db, 'recipeBoxes', recipeBoxID);
    const recipeBoxDoc = yield call(getDoc, recipeBoxRef);

    if (recipeBoxDoc.exists) {
      const recipeBoxData = recipeBoxDoc.data();

      const updatedItems = [
        ...(recipeBoxData.items || []),
        {
          ...newRecipe,
          id: uuid.v4(),
          createdBy: profileID,
          itemDate: new Date().toISOString(),
        },
      ];

      // 🔑 Step 1: Upload image (if any)
      let imageSuccess = false;
      if (finalImage) {
        try {
          const reference = storage().ref(`recipes/${finalImage.name}`);
          yield call([reference, reference.putFile], finalImage.uri);
          yield call([reference, reference.getDownloadURL]); // optional, confirms upload
          imageSuccess = true;
          // console.log('✅ Image uploaded successfully');
        } catch (error) {
          // console.error('❌ Image upload failed:', error);
          imageSuccess = false;
        }
      }

      // 🔑 Step 2: Save recipe
      yield call(() =>
        updateDoc(recipeBoxRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      yield put({
        type: 'SET_RECIPE_BOX',
        payload: {
          ...recipeBoxData,
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
        },
      });

      if (finalImage) {
        if (imageSuccess) {
          Toast.show({
            type: 'success',
            text1: 'Recipe Added',
            text2: `${capEachWord(
              newRecipe?.title,
            )} and image was added to the recipe box.`,
          });
        } else {
          Toast.show({
            type: 'success',
            text1: 'Recipe Added',
            text2: `${capEachWord(
              newRecipe?.title,
            )} added to the recipe box, but the image failed. You can try to add the image again using recipe update.`,
          });
        }
      } else {
        Toast.show({
          type: 'success',
          text1: 'Recipe Added',
          text2: `${capEachWord(
            newRecipe?.title,
          )} was added to the recipe box.`,
        });
      }
    } else {
      yield put({
        type: 'RECIPE_BOX_ADD_FAILED',
        payload: 'Recipe box not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Add Recipe',
        text2: 'Recipe box not found. Please try again later.',
      });
    }
  } catch (error) {
    // console.error(error);
    yield put({type: 'RECIPE_BOX_ADD_FAILED', payload: error.message});
    Toast.show({
      type: 'danger',
      text1: 'Failed to Add Recipe',
      text2: `${capEachWord(
        newRecipe?.title,
      )} could not be added. Please try again later.`,
    });
  }
}

function* updateToPersonalRecipes(action) {
  const {
    recipeBoxID,
    editedRecipe,
    finalImage,
    profileID,
    pictureWasChanged,
    oldImageName,
  } = action.payload;

  try {
    const recipeBoxRef = doc(db, 'recipeBoxes', recipeBoxID);
    const recipeBoxDoc = yield call(getDoc, recipeBoxRef);

    if (recipeBoxDoc.exists) {
      const recipeBoxData = recipeBoxDoc.data();

      // 🔑 Step 1: Update the correct recipe in the array
      const updatedItems = (recipeBoxData.items || []).map(item =>
        item.id === editedRecipe.id
          ? {...item, ...editedRecipe, lastUpdated: new Date().toISOString()}
          : item,
      );

      let imageSuccess = false;
      let imageDeleted = false;

      // 🔑 Step 2: Remove the old image (if any)
      if (pictureWasChanged && oldImageName) {
        try {
          const oldImageRef = storage().ref(`recipes/${oldImageName}`);
          yield call([oldImageRef, oldImageRef.delete]);
          imageDeleted = true;
        } catch {
          imageDeleted = false; // ignore delete error
        }
      }

      // 🔑 Step 3: Upload the new image (if any)
      if (pictureWasChanged && finalImage) {
        try {
          const reference = storage().ref(`recipes/${finalImage.name}`);
          yield call([reference, reference.putFile], finalImage.uri);
          yield call([reference, reference.getDownloadURL]);
          imageSuccess = true;
        } catch {
          imageSuccess = false; // ignore upload error
        }
      }

      // 🔑 Step 4: Save the recipe
      yield call(updateDoc, recipeBoxRef, {
        items: updatedItems,
        lastUpdated: serverTimestamp(),
        lastUpdatedBy: profileID,
      });

      yield put({
        type: 'SET_RECIPE_BOX',
        payload: {
          ...recipeBoxData,
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
        },
      });

      // 🔑 Step 5: Handle toast conditions
      if (imageDeleted && imageSuccess && pictureWasChanged) {
        Toast.show({
          type: 'success',
          text1: 'Recipe Updated',
          text2: `${capEachWord(
            editedRecipe?.title,
          )} and its image were updated.`,
        });
      } else if (!imageDeleted && imageSuccess && pictureWasChanged) {
        Toast.show({
          type: 'success',
          text1: 'Recipe Updated',
          text2: `${capEachWord(editedRecipe?.title)} updated and image added.`,
        });
      } else if (pictureWasChanged && !imageSuccess) {
        Toast.show({
          type: 'warning',
          text1: 'Recipe Updated',
          text2: `${capEachWord(
            editedRecipe?.title,
          )} updated, but the new image could not be saved.`,
        });
      } else {
        Toast.show({
          type: 'success',
          text1: 'Recipe Updated',
          text2: `${capEachWord(editedRecipe?.title)} updated successfully.`,
        });
      }
    } else {
      yield put({
        type: 'RECIPE_BOX_UPDATE_FAILED',
        payload: 'Recipe box not found.',
      });
    }
  } catch (error) {
    yield put({type: 'RECIPE_BOX_UPDATE_FAILED', payload: error.message});
    Toast.show({
      type: 'danger',
      text1: 'Failed to Update Recipe',
      text2: `${capEachWord(
        editedRecipe?.title,
      )} could not be updated. Please try again later.`,
    });
  }
}

function* deleteFromPersonalRecipes(action) {
  const {recipeBoxID, selectedRecipe, profileID, owner} = action.payload;
  try {
    const recipeBoxRef = doc(db, 'recipeBoxes', recipeBoxID);
    const recipeBoxDoc = yield call(getDoc, recipeBoxRef);

    const recipeID = selectedRecipe?.id;
    const itemName = selectedRecipe?.title || 'Recipe';
    const imageName = selectedRecipe?.image; // stored filename like "xxx.jpg"

    if (recipeBoxDoc.exists) {
      const recipeBoxData = recipeBoxDoc.data();

      const updatedItems = recipeBoxData?.items?.filter(
        item => item.id !== recipeID,
      );

      // 🔑 Step 1: Remove from recipeBox
      yield call(() =>
        updateDoc(recipeBoxRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      yield put({
        type: 'SET_RECIPE_BOX',
        payload: {
          ...recipeBoxData,
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
        },
      });

      // 🔑 Step 2: Delete image only if owner
      if (owner && imageName) {
        try {
          const ref = storage().ref(`recipes/${imageName}`);
          yield call([ref, ref.getMetadata]); // ensure it exists
          yield call([ref, ref.delete]);
          // console.log(`🗑️ Deleted image from storage: ${imageName}`);
        } catch (err) {
          if (err.code === 'storage/object-not-found') {
            // console.warn(`⚠️ Image ${imageName} not found in storage`);
          } else {
            // console.error('❌ Failed to delete image:', err);
          }
        }
      }

      Toast.show({
        type: 'success',
        text1: owner ? 'Recipe Deleted' : 'Recipe Removed',
        text2: `${capEachWord(itemName)} was ${
          owner ? 'deleted' : 'removed'
        } from the Recipe Box.`,
      });
    } else {
      yield put({
        type: 'RECIPE_BOX_DELETE_ITEM_FAILED',
        payload: 'Recipe not found.',
      });
      Toast.show({
        type: 'danger',
        text1: `Failed to ${owner ? 'Delete' : 'Remove'} Recipe`,
        text2: 'Recipe not found. Please try again later.',
      });
    }
  } catch (error) {
    // console.log(error);
    yield put({type: 'RECIPE_BOX_DELETE_ITEM_FAILED', payload: error.message});
    Toast.show({
      type: 'danger',
      text1: `Failed to ${owner ? 'Delete' : 'Remove'} Recipe`,
      text2: `${capEachWord(selectedRecipe?.title) || 'Recipe'} could not be ${
        owner ? 'deleted' : 'removed'
      }. Please try again later.`,
    });
  }
}

function* resetRecipeBox(action) {}

export default function* recipeSaga() {
  yield takeLatest('FETCH_COMMUNITY_RECIPES', fetchCommunityRecipes);
  yield takeLatest('ADD_TO_COMMUNITY_RECIPES', addToCommunityRecipes);
  yield takeLatest('UPDATE_TO_COMMUNITY_RECIPES', updateToCommunityRecipes);
  yield takeLatest('DELETE_FROM_COMMUNITY_RECIPES', deleteFromCommunityRecipes);
  yield takeLatest('FETCH_RECIPE_BOX', fetchPersonalRecipes);
  yield takeLatest('ADD_ITEM_TO_RECIPE_BOX', addToPersonalRecipes);
  yield takeLatest('BOOKMARK_TO_RECIPE_BOX', bookmarkCommunityRecipes);
  yield takeLatest('UPDATE_ITEM_IN_RECIPE_BOX', updateToPersonalRecipes);
  yield takeLatest('DELETE_ITEM_FROM_RECIPE_BOX', deleteFromPersonalRecipes);
  yield takeLatest('RESET_FAVORITES', resetRecipeBox);
  yield takeLatest(
    'UPDATE_TO_COMMUNITY_RECIPES_REQUEST',
    updateToCommunityRecipesRequest,
  );
  yield takeLatest(
    'DELETE_FROM_COMMUNITY_RECIPES_REQUEST',
    deleteFromCommunityRecipesRequest,
  );
}


--- FILE: src/redux/sagas/shopCart.saga.jsx ---

//*shopCart.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import uuid from 'react-native-uuid';
import Toast from 'react-native-toast-message';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
  writeBatch,
  serverTimestamp,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';
import {select} from 'redux-saga/effects';
import {checkLimit} from '../../utilities/checkLimit';

const db = getFirestore(getApp());

function* fetchShopCart(action) {
  const {shoppingCartID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      let shopCartData = shopCartDoc.data();

      if (!shopCartData.items) {
        shopCartData = {...shopCartData, items: []};

        yield call(() =>
          updateDoc(shopCartRef, {
            items: [],
            lastUpdated: serverTimestamp(),
          }),
        );
      }

      let shopCart = {
        ...shopCartData,
        createdOn: shopCartData?.createdOn?.toDate?.().toISOString() ?? null,
        lastUpdated:
          shopCartData?.lastUpdated?.toDate?.().toISOString() ?? null,
      };

      yield put({type: 'SET_SHOP_CART', payload: shopCart});
    } else {
      yield put({type: 'SET_SHOP_CART', payload: null});
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_SET_FAILED', payload: error.message});
  }
}

function* addItemToShopCart(action) {
  const {shoppingCartID, newItem, profileID} = action.payload;
  try {
    const account = yield select(state => state.account.account);
    const shopping = yield select(state => state.shopping.shopping);

    const maxShoppingItems = account?.shoppingCartLimit || 0;
    const shoppingLength = shopping?.items?.length || 0;

    const isAllowed = checkLimit({
      current: shoppingLength,
      max: maxShoppingItems,
      label: 'Shopping',
    });

    if (!isAllowed) return;

    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();

      const updatedItems = [
        ...(shopCartData.items || []),
        {
          ...newItem,
          itemId: uuid.v4(),
          createdBy: profileID,
          itemDate: new Date().toISOString(),
        },
      ];

      yield call(() =>
        updateDoc(shopCartRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Added',
        text2: `${newItem.itemName} added to the shopping list.`,
      });
    } else {
      yield put({
        type: 'SHOP_CART_ADD_ITEM_FAILED',
        payload: 'Shopping cart not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Add Item',
        text2: 'Shopping cart not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_ADD_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Add Item',
      text2: `${newItem.itemName} could not be added. Please try again later.`,
    });
  }
}

function* updateItemInShopCart(action) {
  const {shoppingCartID, updatedItem, updateType, profileID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();
      const updatedItems = shopCartData?.items?.map(item =>
        item.itemId === updatedItem.itemId ? updatedItem : item,
      );

      yield call(() =>
        updateDoc(shopCartRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      if (updateType === 'updateList') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} was updated in the shopping list.`,
        });
      } else if (updateType === 'updateCart') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} was updated in the shopping cart.`,
        });
      } else if (updateType === 'toCart') {
        Toast.show({
          type: 'success',
          text1: 'Item Added',
          text2: `${updatedItem.itemName} moved to the shopping cart.`,
        });
      } else if (updateType === 'toList') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} moved to the shopping list.`,
        });
      } else if (updateType === 'toCupboard') {
        // No toast needed, as the cupboard logic handles it
      } else {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} updated to the shopping list.`,
        });
      }
    } else {
      yield put({
        type: 'SHOP_CART_UPDATE_ITEM_FAILED',
        payload: 'Shopping cart not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Update Item',
        text2: 'Shopping cart not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_UPDATE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Update Item',
      text2: `${updatedItem.itemName} could not be updated. Please try again later.`,
    });
  }
}

function* deleteItemFromShopCart(action) {
  const {shoppingCartID, itemId, itemName, profileID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();

      const updatedItems = shopCartData?.items?.filter(
        item => item.itemId !== itemId,
      );

      yield call(() =>
        updateDoc(shopCartRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Deleted',
        text2: `${itemName} removed from the shopping cart.`,
      });
    } else {
      yield put({
        type: 'SHOP_CART_DELETE_ITEM_FAILED',
        payload: 'Shopping cart not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Delete Item',
        text2: 'Shopping cart not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_DELETE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Delete Item',
      text2: `${itemName} could not be removed. Please try again later.`,
    });
  }
}

function* deleteListFromShopCart(action) {
  const {shoppingCartID, items, profileID} = action.payload;

  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();

      const updatedItems = shopCartData?.items?.filter(
        item => !items.some(cartItem => cartItem.itemId === item.itemId),
      );

      yield call(() =>
        updateDoc(shopCartRef, {
          items: updatedItems,
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_DELETE_LIST_FAILED', payload: error.message});
  }
}

function* batchToShopping(action) {
  const {shoppingCartID, items, status, profileID} = action.payload;

  try {
    const account = yield select(state => state.account.account);
    const shopping = yield select(state => state.shopping.shopping);

    const maxShoppingItems = account?.shoppingCartLimit || null;
    const shoppingLength = shopping?.items?.length || 0;

    const incomingItemCount = items.reduce((total, item) => {
      return total + (item.quantity > 0 ? item.quantity : 1);
    }, 0);

    const isAllowed = checkLimit({
      current: shoppingLength,
      incoming: incomingItemCount,
      max: maxShoppingItems,
      label: 'Shopping',
    });

    if (!isAllowed) return;

    yield put({type: 'SHOP_CART_BATCH_ADD_START'});

    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();
      const batch = writeBatch(db);
      let updatedItems = [...(shopCartData.items || [])];

      items.forEach(item => {
        const {
          itemName,
          brandName,
          description,
          packageSize,
          measurement,
          category,
          notes,
        } = item;

        for (let i = 0; i < item.quantity; i++) {
          const newItem = {
            itemName: itemName || '',
            brandName: brandName || '',
            description: description || '',
            packageSize: Number(packageSize) || 1,
            measurement: measurement || '',
            category: category || '',
            notes: notes || '',
            itemId: uuid.v4(),
            itemDate: new Date().toISOString(),
            quantity: 1,
            createdBy: profileID,
            status:
              status === 'shopping-list' ? 'shopping-list' : 'shopping-cart',
          };

          updatedItems.push(newItem);
        }
      });

      batch.update(shopCartRef, {
        items: updatedItems,
        lastUpdated: serverTimestamp(),
        lastUpdatedBy: profileID,
      });

      yield call(() => batch.commit());

      yield put({type: 'SET_SHOP_CART', payload: {shoppingCartID}});

      Toast.show({
        type: 'success',
        text1: 'Items Added',
        text2: `Items were added to your ${
          status === 'shopping-list' ? 'shopping list' : 'shopping cart'
        }.`,
      });

      yield put({type: 'SHOP_CART_BATCH_ADD_SUCCESS'});
    } else {
      yield put({
        type: 'SHOP_CART_BATCH_ADD_FAILED',
        payload: 'Shopping cart not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Batch Add Failed',
        text2: 'Shopping cart not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_BATCH_ADD_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Batch Add Failed',
      text2:
        'Items could not be added to the shopping cart. Please try again later.',
    });
  }
}

function* resetShopCart(action) {
  const {shoppingCartID, profileID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      yield call(() =>
        updateDoc(shopCartRef, {
          items: [],
          lastUpdated: serverTimestamp(),
          lastUpdatedBy: profileID,
        }),
      );

      yield put({type: 'SET_SHOP_CART', payload: {shoppingCartID}});

      Toast.show({
        type: 'success',
        text1: 'Shopping List Reset',
        text2: 'Your shopping list has been cleared.',
      });
    } else {
      Toast.show({
        type: 'warning',
        text1: 'No Shopping List Found',
        text2: 'Could not find a shopping list to reset.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_RESET_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Reset Failed',
      text2: 'Your shopping list could not be reset. Please try again later.',
    });
  }
}

export default function* shopCartSaga() {
  yield takeLatest('FETCH_SHOP_CART', fetchShopCart);
  yield takeLatest('ADD_ITEM_TO_SHOP_CART', addItemToShopCart);
  yield takeLatest('UPDATE_ITEM_IN_SHOP_CART', updateItemInShopCart);
  yield takeLatest('DELETE_ITEM_FROM_SHOP_CART', deleteItemFromShopCart);
  yield takeLatest('DELETE_LIST_FROM_SHOP_CART', deleteListFromShopCart);
  yield takeLatest('BATCH_TO_SHOP_CART', batchToShopping);
  yield takeLatest('RESET_SHOP_CART', resetShopCart);
}


--- FILE: src/redux/sagas/signup.saga.jsx ---

//* signup.saga.jsx

import {put, takeLatest, call} from 'redux-saga/effects';
import {
  getFirestore,
  setDoc,
  doc,
  serverTimestamp,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';
import {getAuth} from '@react-native-firebase/auth';
import uuid from 'react-native-uuid';

const db = getFirestore(getApp());
const auth = getAuth(getApp());

function* createNewUser(action) {
  try {
    // grab the payload
    const {email, password} = action.payload;

    // Checks if the email is in use, if not, it creates that user.
    const userCredential = yield call(
      [auth, auth.createUserWithEmailAndPassword],
      email,
      password,
    );

    //build the user object
    const user = userCredential.user;

    // send the user an email verification
    yield call([user, user.sendEmailVerification]);

    // need to confirm the user is created and grab the uid, not sure if this is correct.
    const newProfile = {
      account: null,
      email: email,
      firstName: null,
      id: user.uid,
      isActive: true,
      lastName: null,
      lastUpdated: new Date().toISOString(),
      createdOn: new Date().toISOString(),
      onlineName: null,
      pictureApproved: false,
      pictureURL: '',
      role: 'n/a',
      onboarding: {
        onboardDisabled: false, // after a certain number of steps, user can turn off onboarding
        onboardingAllowedDisabled: false, // if true, user can turn off onboarding
        lastStepCompleted: 'created-userProfile', // this is the last step completed in onboarding
        lastStepCompletedOn: new Date().toISOString(), // this is the date the last step was completed
        onboardingCompleted: false, // this is true when the user has completed all steps
        completedOn: null, // this is the date the last step was completed
        forceShowFTU: false, // this lets the user force to show the ftu again
        recipeSearchFTU: false, // this is for a modal that shows a disclaimer when the user creates their first recipe
        recipeBoxFTU: false,
      },
      permissionsGranted: false,
      permissionsRequested: false,
      userSettings: {
        flashCellOrder: [
          {index: 0, key: 'brandName', label: 'Brand Name'},
          {index: 1, key: 'description', label: 'Description'},
          {index: 2, key: 'itemName', label: 'Item Name'},
        ],
        hapticStrength: 'light',
      },
    };

    // Create the profile document in Firestore
    yield call(setDoc, doc(db, 'profiles', user.uid), newProfile);

    yield call([auth, auth.signOut]);
    yield put({type: 'LOGOUT_AND_CLEAR'});
  } catch (error) {
    console.error('An Error occurred during signup process:', error.message);
  }
}

function* createNewAccount(action) {
  try {
    const {userID, profileID} = action.payload;
    const accountID = uuid.v4();
    const cupboardID = uuid.v4();
    const shoppingCartID = uuid.v4();
    const recipeBoxID = uuid.v4();
    const favoriteItemsID = uuid.v4();
    const joinCode = uuid.v4().replace(/-/g, '');
    const cupboardLimit = 50;
    const shoppingCartLimit = 25;
    const favoriteItemsLimit = 10;
    const recipeBoxLimit = 5;
    const recipeSearchLimit = 0;
    const upcSearchLimit = 0;
    const dailyRecipeCounter = 0;
    const dailyUPCCounter = 0;

    const newAccount = {
      allowedUsers: [userID],
      createdOn: new Date().toISOString(),
      cupboardID: cupboardID,
      cupboardLimit: cupboardLimit,
      favoriteItemsID: favoriteItemsID,
      favoriteItemsLimit: favoriteItemsLimit,
      id: accountID,
      isActive: true,
      joinCode: joinCode,
      lastUpdated: new Date().toISOString(),
      lastUpdatedBy: userID,
      owner: userID,
      recipeBoxID: recipeBoxID,
      recipeBoxLimit: recipeBoxLimit,
      recipeSearchLimit: recipeSearchLimit,
      shoppingCartID: shoppingCartID,
      shoppingCartLimit: shoppingCartLimit,
      subType: 'Free',
      upcSearchLimit: upcSearchLimit,
      dailyRecipeCounter: dailyRecipeCounter,
      dailyUPCCounter: dailyUPCCounter,
    };

    yield call(setDoc, doc(db, 'accounts', accountID), newAccount);

    const newShopping = {
      id: shoppingCartID,
      accountID: accountID,
      createdOn: new Date().toISOString(),
      // items: [''],
      lastUpdated: new Date().toISOString(),
      lastUpdatedBy: userID,
    };

    yield call(setDoc, doc(db, 'shoppingCarts', shoppingCartID), newShopping);

    const newCupboard = {
      id: cupboardID,
      accountID: accountID,
      createdOn: new Date().toISOString(),
      // items: [''],
      lastUpdated: new Date().toISOString(),
      lastUpdatedBy: userID,
    };

    yield call(setDoc, doc(db, 'cupboards', cupboardID), newCupboard);

    const newRecipeBox = {
      id: recipeBoxID,
      accountID: accountID,
      createdOn: new Date().toISOString(),
      // items: [''],
      lastUpdated: new Date().toISOString(),
      lastUpdatedBy: userID,
    };

    yield call(setDoc, doc(db, 'recipeBoxes', recipeBoxID), newRecipeBox);

    const newFavoriteItems = {
      id: favoriteItemsID,
      accountID: accountID,
      createdOn: new Date().toISOString(),
      // items: [''],
      lastUpdated: new Date().toISOString(),
      lastUpdatedBy: userID,
    };

    yield call(
      setDoc,
      doc(db, 'favoriteItems', favoriteItemsID),
      newFavoriteItems,
    );

    yield call(
      setDoc,
      doc(db, 'profiles', userID),
      {
        account: accountID,
        role: 'owner',
        lastUpdated: serverTimestamp(),
      },
      {merge: true},
    );

    yield put({
      type: 'FETCH_ACCOUNT',
      payload: {account: accountID, id: userID},
    });

    yield put({
      type: 'FETCH_SHOP_CART',
      payload: {shoppingCartID: shoppingCartID},
    });
    yield put({type: 'FETCH_CUPBOARD', payload: {cupboardID: cupboardID}});

    yield put({type: 'SIGNUP_SUCCESS'});
  } catch (error) {
    console.error('An Error occurred during account creation:', error.message);
  }
}

export default function* signupSaga() {
  yield takeLatest('SIGNUP_REQUEST', createNewUser);
  yield takeLatest('CREATE_NEW_ACCOUNT', createNewAccount);
}


--- FILE: src/redux/sagas/user.saga.jsx ---

//* user.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import {getAuth} from '@react-native-firebase/auth';
import {persistor} from '../../../store';

const auth = getAuth();

const getErrorMessage = error => {
  switch (error?.code) {
    // 🔐 Signup + Account Creation
    case 'auth/email-already-in-use':
      return 'This email is already linked to another account. Try logging in or use a different one.';
    case 'auth/invalid-email':
      return 'That doesn’t look like a valid email address. Please double-check it.';
    case 'auth/operation-not-allowed':
      return 'Email sign-up is currently disabled. Please contact support for help.';
    case 'auth/weak-password':
      return 'That password is too weak. Try something longer with numbers and symbols.';

    // 🔓 Login / Credential
    case 'auth/invalid-credential':
    case 'auth/wrong-password':
      return 'Incorrect email or password. Please double-check your login details.';
    case 'auth/user-not-found':
    case 'auth/no-current-user':
      return 'We couldn’t find an account with that email. Did you sign up?';
    case 'auth/user-disabled':
      return 'This account has been disabled. Please reach out to support if this seems wrong.';

    // 🚫 Throttling / Abuse
    case 'auth/too-many-requests':
      return 'Too many attempts. Take a short break and try again in a few minutes.';
    case 'auth/blocked-by-response':
      return 'Login is temporarily blocked. Please wait a few minutes before trying again.';

    // 📧 Email Verification
    case 'auth/invalid-action-code':
      return 'That link is invalid or has expired. Request a new one to continue.';
    case 'auth/user-token-expired':
      return 'Your session expired. Please log in again to continue.';
    case 'auth/email-not-verified':
      return 'Your email hasn’t been verified yet. Check your inbox for a verification link.';

    // 🧠 Edge Cases (Network, App, Internal)
    case 'auth/network-request-failed':
      return 'Can’t connect. Please check your internet and try again.';
    case 'auth/app-not-authorized':
      return 'This app isn’t authorized for Firebase. Please contact support.';
    case 'auth/internal-error':
      return 'Something went wrong on our side. Try again in a moment.';

    // 🚨 Fallback
    default:
      return 'An unknown error occurred. Please try again later.';
  }
};

// LOGIN
function* loginUser(action) {
  try {
    const {email, password} = action.payload;

    const userCredential = yield call(
      [auth, auth.signInWithEmailAndPassword],
      email,
      password,
    );

    const user = userCredential?.user;

    if (user?.emailVerified) {
      yield put({type: 'SET_USER', payload: user});
      yield put({type: 'START_LOGIN', payload: user.uid});
    } else {
      // ❌ Block unverified users
      yield call([auth, auth.signOut]);
      yield put({type: 'UNSET_USER'});
      yield put({type: 'RESET_ALL_STATE'});
      yield call([persistor, persistor.purge]);
      yield call([persistor, persistor.flush]);

      yield put({
        type: 'LOGIN_FAILED',
        payload: getErrorMessage({code: 'auth/email-not-verified'}),
      });

      return; // 🔒 Stop flow
    }
  } catch (error) {
    const friendlyMessage = getErrorMessage(error);
    yield put({type: 'LOGIN_FAILED', payload: friendlyMessage});
  }
}

// LOGOUT
function* logoutUser() {
  try {
    yield call([auth, auth.signOut]);
    yield put({type: 'UNSET_USER'});
  } catch (error) {
    const friendlyMessage = getErrorMessage(error);
    yield put({type: 'LOGOUT_FAILED', payload: friendlyMessage});
  }
}

// LOGOUT AND CLEAR
function* logOutAndClear() {
  try {
    yield call([auth, auth.signOut]);
    yield put({type: 'UNSET_USER'});
    yield put({type: 'RESET_ALL_STATE'});
    yield call([persistor, persistor.purge]);
    yield call([persistor, persistor.flush]);
  } catch (error) {
    const friendlyMessage = getErrorMessage(error);
    yield put({type: 'LOGOUT_FAILED', payload: friendlyMessage});
  }
}

export default function* userSaga() {
  yield takeLatest('LOGIN_REQUEST', loginUser);
  yield takeLatest('LOGOUT', logoutUser);
  yield takeLatest('LOGOUT_AND_CLEAR', logOutAndClear);
}


--- FILE: src/screens/Account/Account.jsx ---

//* Account.jsx
import React, {useCallback, useEffect, useMemo, useState} from 'react';
import {Button, Input, Layout, Modal, Text, View} from '../../KQ-UI';
import {ActivityIndicator} from 'react-native';
import {Icons} from '../../components/IconListRouter';
import {
  useAccount,
  useDeviceInfo,
  useExistingInvite,
  useProfile,
} from '../../hooks/useHooks';
import {useDispatch} from 'react-redux';
import uuid from 'react-native-uuid';
import BuildAvatar from '../../components/BuildAvatar';
import {AccountStyles} from '../../styles/Styles';
import SAButton from './SAButton';
import Clipboard from '@react-native-clipboard/clipboard';
import {Animated} from 'react-native';
import {AppInfo} from '../../../AppInfo';

const Account = () => {
  const profile = useProfile();
  const device = useDeviceInfo();
  const dispatch = useDispatch();
  const account = useAccount();
  const existingInvite = useExistingInvite();
  const isIOS = device?.system?.os === 'iOS';
  const isAndroid = device?.system?.os === 'Android';
  const deviceAppVersion = isIOS
    ? `(iOS) App Version: ${AppInfo?.appleAppVersion}`
    : isAndroid
    ? `(Android) App Version: ${AppInfo?.googleAppVersion}`
    : '';
  const buildVersion = isIOS
    ? `Build: ${AppInfo?.appleBuildVersion}`
    : isAndroid
    ? `Build: ${AppInfo?.googleBuildVersion}`
    : '';

  const [showModal, setShowModal] = useState(false);
  const [inviteEmail, setInviteEmail] = useState('');
  const [emailError, setEmailError] = useState(false);
  const [emailErrorMsg, setEmailErrorMsg] = useState('');
  const [invitationMsg, setInvitationMsg] = useState('');
  const [codeGenerated, setCodeGenerated] = useState(false);
  const [displayCode, setDisplayCode] = useState('');
  const [canGenerate, setCanGenerate] = useState(true);
  const [loadingStatus, setLoadingStatus] = useState(false);
  const [showExceeding, setShowExceeding] = useState(false);

  const closeModal = useCallback(() => {
    setShowModal(false);
    setCodeGenerated(false);
    setCanGenerate(true);
    setDisplayCode('');
    setInviteEmail('');
    setEmailError(false);
    setEmailErrorMsg('');
    setInvitationMsg('');
    setShowExceeding(false);
    dispatch({type: 'CLEAR_EXISTING_INVITE'});
  }, [dispatch]);

  const showCodeModal = useMemo(() => {
    if (
      !showModal &&
      !loadingStatus &&
      ((codeGenerated && displayCode) || invitationMsg || showExceeding)
    ) {
      return true;
    }
  }, [
    codeGenerated,
    displayCode,
    showModal,
    loadingStatus,
    invitationMsg,
    showExceeding,
  ]);

  const isValidEmail = email => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  useEffect(() => {
    if (!inviteEmail) {
      setEmailError(false);
      setEmailErrorMsg('');
    }
  }, [inviteEmail]);

  useEffect(() => {
    if (existingInvite?.inviteCode !== displayCode) {
      setCodeGenerated(true);
      setDisplayCode(existingInvite?.inviteCode);
    }
  }, [existingInvite, displayCode]);

  const handleInvite = () => {
    if (!canGenerate || !isValidEmail(inviteEmail)) return;

    const code = uuid.v4().slice(0, 6).toUpperCase();

    const inviteObject = {
      inviteCode: code,
      email: inviteEmail,
      fromFirst: profile?.firstName,
      fromLast: profile?.lastName,
      fromEmail: profile?.email,
      joinCode: account?.joinCode,
      toExpire: new Date().toISOString(),
      accountID: account?.id,
    };

    setLoadingStatus(true);

    new Promise((resolve, reject) => {
      dispatch({
        type: 'QUEUE_INVITE_REQUEST',
        payload: {
          invite: inviteObject,
          accountID: account?.id,
          resolve,
          reject,
        },
      });
    })
      .then(({existing, invite, exceeding}) => {
        setInviteEmail('');
        setCodeGenerated(!!invite);
        setDisplayCode(invite?.inviteCode || '');
        setLoadingStatus(false);
        setCanGenerate(true);

        if (existing) {
          setShowModal(false);
          setInvitationMsg(
            'This invitation already exists. The expiration has been updated.',
          );
        } else if (exceeding) {
          setShowModal(false);
          setShowExceeding(true);
        } else {
          setInvitationMsg('');
        }
      })
      .catch(err => {
        setEmailError(true);
        setEmailErrorMsg(err.message || 'Invite failed');
        setLoadingStatus(false);
        setCanGenerate(true);
      });
  };

  const setScrolling = useMemo(() => {
    switch (device?.system?.deviceSize) {
      case 'small':
        return true;
      case 'xSmall':
        return true;
      default:
        return false;
    }
  }, [device?.system?.deviceSize]);

  return (
    <Layout
      headerTitle="Account"
      LeftButton=""
      RightButton="Logout"
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      mode="scroll-only"
      noBar={setScrolling}
      // outerViewStyles={{paddingBottom: 0}}
    >
      <View style={AccountStyles.topSection}>
        <View style={AccountStyles.sectionNav}>
          <SAButton
            title="Profile"
            location="AccountProfile"
            icon={<Icons.Profile size={20} color="#373d43" />}
          />
          <SAButton
            title="Settings"
            location="AccountSettings"
            icon={<Icons.Settings size={20} color="#373d43" />}
          />
          <SAButton
            title="Help"
            location="AccountHelp"
            icon={<Icons.Help size={20} color="#373d43" />}
          />
        </View>
      </View>

      <View style={AccountStyles.userSection}>
        <View style={AccountStyles.sectionUsers}>
          <View style={AccountStyles.usersHeader}>
            <Text size="small" font="open-7">
              Users:
            </Text>
            <Text size="xSmall" font="open-5">
              Have up to 4 users on your account
            </Text>
          </View>
          <View style={AccountStyles.avatarWrapper}>
            <BuildAvatar setShowModal={setShowModal} />
          </View>
        </View>
      </View>
      {/* <View style={AccountStyles.midSection}>
        <View style={AccountStyles.usersHeader}>
          <Text size="small" font="open-7">
            Collections:
          </Text>
        </View>
        <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>
          <Text size="xSmall">Coming Soon</Text>
        </View>
      </View>
      <View style={AccountStyles.midSection}>
        <View style={AccountStyles.usersHeader}>
          <Text size="small" font="open-7">
            Limits:
          </Text>
        </View>
        <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>
          <Text size="xSmall">Coming Soon</Text>
        </View>
      </View> */}
      {/* <View style={{flexDirection: 'row', marginHorizontal: 20, marginTop: 2}}>
        <View style={{alignItems: 'flex-start'}}>
          <Text size="xSmall" italic>
            {deviceAppVersion}
          </Text>
        </View>
        <View style={{flex: 1, alignItems: 'flex-end'}}>
          <Text size="xSmall" italic>
            {buildVersion}
          </Text>
        </View>
      </View> */}
      <RenderModal
        showModal={showModal}
        showExceeding={showExceeding}
        invitationMsg={invitationMsg}
        displayCode={displayCode}
        loadingStatus={loadingStatus}
        codeGenerated={codeGenerated}
        closeModal={closeModal}
        handleInvite={handleInvite}
        inviteEmail={inviteEmail}
        setInviteEmail={setInviteEmail}
        emailError={emailError}
        emailErrorMsg={emailErrorMsg}
        canGenerate={canGenerate}
        showCodeModal={showCodeModal}
        existingInvite={existingInvite}
        account={account}
        setEmailError={setEmailError}
        setEmailErrorMsg={setEmailErrorMsg}
      />
    </Layout>
  );
};

const RenderModal = React.memo(props => {
  const {
    showModal,
    showExceeding,
    invitationMsg,
    displayCode,
    loadingStatus,
    codeGenerated,
    closeModal,
    handleInvite,
    inviteEmail,
    setInviteEmail,
    emailError,
    emailErrorMsg,
    canGenerate,
    showCodeModal,
    existingInvite,
    account,
    setEmailError,
    setEmailErrorMsg,
  } = props;
  const [confirmCopy, setConfirmCopy] = useState(false);
  const fadeAnim = useState(new Animated.Value(0))[0];

  const copyToClipboard = () => {
    Clipboard.setString(displayCode);
    setConfirmCopy(true);

    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }).start(() => {
      setTimeout(() => {
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 500,
          useNativeDriver: true,
        }).start(() => {
          setConfirmCopy(false);
        });
      }, 5000);
    });
  };
  const isInviteModal = showModal;
  const isCodeModal = showCodeModal;
  const isLoading = loadingStatus;

  const getModalTitle = () => {
    if (showExceeding) return 'Maxed Invitations';
    if (invitationMsg) return 'Existing Code';
    if (codeGenerated) return 'Code Generated';
    return 'Invite User';
  };

  const renderInviteContent = () => {
    if (isLoading) {
      return (
        <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>
          <ActivityIndicator size="large" color="#29856c" />
          <Text size="medium" font="open-7">
            Generating Invite...
          </Text>
        </View>
      );
    }

    return (
      <View style={{flex: 1}}>
        <Input
          label="User Email"
          value={inviteEmail}
          onChangeText={text => {
            setInviteEmail(text.trim());
            setEmailError(false);
            setEmailErrorMsg('');
          }}
          validation={emailError}
          validationMessage={emailErrorMsg}
        />
        <Button onPress={handleInvite} disabled={!canGenerate}>
          Generate Invite
        </Button>
      </View>
    );
  };

  const renderCodeContent = () => (
    <View
      style={{
        flex: 1,
        borderWidth: 1,
        justifyContent: 'center',
        alignContent: 'center',
        alignItems: 'center',
      }}>
      {!showExceeding && (
        <View style={{marginHorizontal: 20, marginVertical: 10}}>
          <Text size="large" font="open-7" centered>
            Invitation Code: {existingInvite?.inviteCode}
          </Text>
        </View>
      )}
      {showExceeding && (
        <View style={{marginHorizontal: 20, marginVertical: 10}}>
          <Text size="medium" font="open-6" centered>
            Sorry, but you've reached the maximum number of invitations on your
            account.
          </Text>
        </View>
      )}
      {invitationMsg && (
        <View style={{marginHorizontal: 20, marginVertical: 10}}>
          <Text size="medium" font="open-6" centered>
            {invitationMsg}
          </Text>
        </View>
      )}
      {!showExceeding && !invitationMsg && (
        <View style={{marginHorizontal: 20, marginVertical: 10}}>
          <Text size="small" font="open-6" centered>
            An invitation has been generated and sent to {existingInvite?.email}
            . Use this code to invite them to your account.
          </Text>
          <View style={{marginTop: 30}}>
            <Text size="xSmall" font="open-6" centered italic>
              For any reason they didn't get the email, you can press the button
              below to copy and send it via text or email yourself.
            </Text>
          </View>
          <View style={{marginTop: 30}}>
            <Button status="primary" size="small" onPress={copyToClipboard}>
              Copy Join Code
            </Button>
          </View>
          <Animated.View style={{opacity: fadeAnim, marginTop: 10}}>
            <Text size="small" font="open-5" centered>
              {confirmCopy && `Code copied!`}
            </Text>
          </Animated.View>
        </View>
      )}
      {showExceeding && (
        <View style={{marginHorizontal: 20, marginVertical: 10}}>
          <Text size="small" font="open-5" centered italic>
            You currently have {account?.allowedUsers?.length} of 4 users and{' '}
            {account?.accountInvites?.length} active invitations on your
            account.
          </Text>
        </View>
      )}
      {invitationMsg && (
        <View style={{marginHorizontal: 20, marginVertical: 10}}>
          <Text size="xSmall" font="open-5" centered italic>
            {invitationMsg}
          </Text>
        </View>
      )}
    </View>
  );

  return (
    <Modal
      visible={isInviteModal || isCodeModal}
      title={getModalTitle()}
      onClose={closeModal}
      height="80%"
      width="95%"
      headerFont="open-7">
      {isInviteModal && renderInviteContent()}
      {isCodeModal && renderCodeContent()}
    </Modal>
  );
});

export default Account;


--- FILE: src/screens/Account/AccountSetup.jsx ---

//* AccountSetup.jsx

import React, {useEffect, useMemo, useState} from 'react';
import {Image, Keyboard, View} from 'react-native';
import {Button, Input, Modal, ScrollView, Text} from '../../KQ-UI';
import {
  useDeviceInfo,
  useFoundAccount,
  useFoundInvite,
} from '../../hooks/useHooks';
import {useCoreInfo} from '../../utilities/coreInfo';
import {useDispatch} from 'react-redux';
import {Icons} from '../../components/IconListRouter';

const AccountSetup = () => {
  const device = useDeviceInfo();
  const dispatch = useDispatch();
  const core = useCoreInfo();
  const {inviteFound, inviteData, error, errorMsg1, errorMsg2} =
    useFoundInvite();
  const {accountData} = useFoundAccount();

  const [isCreatingAccount, setIsCreatingAccount] = useState(false);
  const [showJoinAccount, setShowJoinAccount] = useState(false);
  const [inviteCode, setInviteCode] = useState('');
  const [foundInvite, setFoundInvite] = useState(false);
  const [foundInviteData, setFoundInviteData] = useState(null);
  const [inviteError, setInviteError] = useState(false);
  const [inviteErrorMsg1, setInviteErrorMsg1] = useState('');
  const [inviteErrorMsg2, setInviteErrorMsg2] = useState('');
  const [foundAccountData, setFoundAccountData] = useState(null);

  useEffect(() => {
    setFoundInvite(inviteFound);
    setFoundInviteData(inviteData);
    setInviteError(error);
    setInviteErrorMsg1(errorMsg1);
    setInviteErrorMsg2(errorMsg2);
  }, [inviteFound, inviteData, error, errorMsg1, errorMsg2]);

  useEffect(() => {
    if (inviteCode) {
      setFoundInvite(false);
      setFoundInviteData(null);
      setInviteError(false);
      setInviteErrorMsg1('');
      setInviteErrorMsg2('');
    }
  }, [inviteCode]);

  useEffect(() => {
    if (foundInviteData) {
      dispatch({
        type: 'CHECK_JOIN_ACCOUNT',
        payload: {
          accountID: foundInviteData?.accountID,
        },
      });
    }
  }, [foundInviteData]);

  useEffect(() => {
    setFoundAccountData(accountData);
  }, [accountData]);

  const logoSizeConfig = useMemo(() => {
    const type = device?.system?.deviceSize;
    switch (type) {
      case 'large':
        return {scale: 1.1, activityOffset: 65};
      case 'medium':
        return {scale: 1.2, activityOffset: 60};
      case 'small':
        return {scale: 1.3, activityOffset: 55};
      case 'xSmall':
        return {scale: 1.4, activityOffset: 50};
      default:
        return {scale: 1, activityOffset: 70};
    }
  }, [device]);

  const logoWidth = 350 / logoSizeConfig.scale;
  const logoHeight = 175 / logoSizeConfig.scale;

  const handleCreateAccount = () => {
    if (isCreatingAccount) return;
    setIsCreatingAccount(true);
    dispatch({
      type: 'CREATE_NEW_ACCOUNT',
      payload: {
        userID: core.userID,
        profileID: core.profileID,
      },
    });
    setTimeout(() => {
      setIsCreatingAccount(false);
    }, 30000);
  };

  const handleJoinAccount = () => {
    const code1 = foundInviteData?.joinCode;
    const code2 = foundAccountData?.joinCode;
    if (code1 === code2) {
      dispatch({
        type: 'UPDATE_PROFILE_REQUEST',
        payload: {
          userId: core.profileID,
          updatedData: {
            account: foundInviteData?.accountID,
            role: 'user',
          },
        },
      });
      dispatch({
        type: 'UPDATE_ACCOUNT',
        payload: {
          profileID: core.profileID,
          accountID: foundInviteData?.accountID,
          updatedData: {
            allowedUsers: [...foundAccountData?.allowedUsers, core.profileID],
            accountInvites: foundAccountData?.accountInvites?.filter(
              code => code !== foundInviteData?.inviteCode,
            ),
          },
        },
      });
      dispatch({
        type: 'DELETE_INVITE_REQUEST',
        payload: {
          inviteCode: foundInviteData?.inviteCode,
        },
      });
      setTimeout(() => {
        dispatch({type: 'START_LOGIN', payload: core?.userID});
      }, 2000);
    }
  };

  const handleSearchCode = () => {
    Keyboard.dismiss();
    const code = inviteCode.trim();

    if (code && code.length === 6) {
      dispatch({
        type: 'CHECK_JOIN_INVITE',
        payload: {
          inviteCode: code,
        },
      });
    } else {
      setInviteError(true);
      setInviteErrorMsg1('Invalid Code');
      setInviteErrorMsg2('Please check the code and try again.');
      return;
    }
  };

  const handleCancelJoin = () => {
    setFoundInvite(false);
    setFoundInviteData(null);
    setInviteError(false);
    setInviteErrorMsg1('');
    setInviteErrorMsg2('');
    dispatch({
      type: 'CLEAR_INVITE_DATA',
    });
    dispatch({
      type: 'CLEAR_TEMP_ACCOUNT_DATA',
    });
    setInviteCode('');
  };

  const handleGoBack = () => {
    setFoundInvite(false);
    setFoundInviteData(null);
    setInviteError(false);
    setInviteErrorMsg1('');
    setInviteErrorMsg2('');
    dispatch({
      type: 'CLEAR_INVITE_DATA',
    });
    dispatch({
      type: 'CLEAR_TEMP_ACCOUNT_DATA',
    });
    setInviteCode('');
    setShowJoinAccount(false);
  };

  const ListItem = ({children}) => (
    <Text size="small" centered>
      {`\u2022`} {children}
    </Text>
  );

  return (
    <>
      <View style={styles.logoContainer}>
        <Image
          source={require('../../images/AppLogo_350.png')}
          style={{width: logoWidth, height: logoHeight}}
        />
      </View>
      <View style={{flex: 1}}>
        {showJoinAccount ? (
          <>
            <View style={styles.centeredBlock}>
              <View style={styles.topPadding}>
                <Text size="giant" font="open-7" centered italic>
                  Welcome
                </Text>
              </View>
              <View style={styles.introPadding}>
                <Text size="medium" centered>
                  Please enter the 6 alphanumeric code provided by the account
                  owner or the email you received, then press search.
                </Text>
              </View>
              <View style={styles.divider} />
            </View>
            <View>
              <Input
                label="Invitation Code"
                placeholder="Enter Here"
                value={inviteCode}
                onChangeText={setInviteCode}
                capitalize={true}
                capitalMode="characters"
                counter
                maxCount={6}
              />
              <Button disabled={foundInvite} onPress={handleSearchCode}>
                Search for Account
              </Button>
            </View>
            {foundInvite && (
              <View style={{margin: 30}}>
                <View style={{alignItems: 'center'}}>
                  <View style={{borderBottomWidth: 1}}>
                    <Text size="medium" font="open-7" centered>
                      Invitation Found:
                    </Text>
                  </View>
                </View>
                <View style={{marginVertical: 20}}>
                  <Text size="medium" font="open-7" centered>
                    {foundInviteData?.fromEmail}
                  </Text>
                  <Text size="medium" font="open-7" centered>
                    {foundInviteData?.fromFirst} {foundInviteData?.fromLast}
                  </Text>
                </View>
                <View
                  style={{
                    flexDirection: 'row',
                  }}>
                  <View style={{flex: 1}}>
                    <Button onPress={handleJoinAccount}>Join Account</Button>
                  </View>
                  <View style={{flex: 1}}>
                    <Button color="danger" onPress={handleCancelJoin}>
                      Cancel
                    </Button>
                  </View>
                </View>
              </View>
            )}
            {inviteError && (
              <View style={{margin: 30}}>
                <Text kqColor="danger" size="large" font="open-7" centered>
                  {inviteErrorMsg1}
                </Text>
                <Text size="medium" font="open-7" centered italic>
                  {inviteErrorMsg2}
                </Text>
              </View>
            )}
            <Button
              type="ghost"
              onPress={handleGoBack}
              textStyle={{position: 'relative', left: -5}}>
              <Icons.ChevronLeft size={15} color={'#29856c'} />
              Go Back
            </Button>
          </>
        ) : (
          <ScrollView>
            <View style={styles.centeredBlock}>
              <View style={styles.topPadding}>
                <Text size="giant" font="open-7" centered italic>
                  Welcome
                </Text>
              </View>
              <View style={styles.introPadding}>
                <Text size="medium" centered>
                  Before you can use Kitchen Queue, you need to decide if you
                  want to create your own account or join another.
                </Text>
              </View>
              <View style={styles.divider} />
            </View>

            <View style={styles.section}>
              <Text size="large" font="open-7" centered>
                New Account (Free)
              </Text>
              <View>
                <Text size="xSmall" centered>
                  (Base Features Include)
                </Text>
                <ListItem>Invite / Add 3 more users</ListItem>
                <ListItem>100 Cupboard Items</ListItem>
                <ListItem>25 Shopping Items</ListItem>
                <ListItem>25 Favorite Items{'\u002A'}</ListItem>
                <ListItem>5 Recipes Items{'\u002A'}</ListItem>
              </View>
              <View style={styles.buttonWrapper}>
                <Button
                  size="medium"
                  textSize="medium"
                  fontType="open-7"
                  onPress={handleCreateAccount}>
                  Create My Account
                </Button>
              </View>
              <View style={styles.centered}>
                <View style={styles.divider} />
              </View>
            </View>

            <View style={styles.section}>
              <Text size="large" font="open-7" centered>
                Join an Account
              </Text>
              <Text size="xSmall" centered>
                (Base Features plus...)
              </Text>
              <ListItem>
                Inherited subscription limits{'\u002A'}
                {'\u002A'}
              </ListItem>

              <View style={styles.buttonWrapper}>
                <Button
                  size="medium"
                  textSize="medium"
                  fontType="open-7"
                  onPress={() => setShowJoinAccount(true)}>
                  Join an Account
                </Button>
              </View>
            </View>

            <View style={styles.footerNote}>
              <Text size="small" centered italic>
                {'\u002A'} Features are coming soon and not yet available
              </Text>
              <Text size="small" centered italic>
                {'\u002A'}
                {'\u002A'} Subscriptions are not yet available
              </Text>
            </View>
          </ScrollView>
        )}
      </View>
    </>
  );
};

const styles = {
  logoContainer: {
    alignItems: 'center',
  },
  centeredBlock: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  topPadding: {
    padding: 5,
  },
  introPadding: {
    padding: 10,
  },
  divider: {
    borderBottomWidth: 1,
    width: '80%',
    paddingBottom: 10,
    marginBottom: 20,
  },
  section: {
    justifyContent: 'center',
  },
  centered: {
    alignItems: 'center',
  },
  buttonWrapper: {
    paddingHorizontal: 30,
    paddingVertical: 15,
  },
  footerNote: {
    marginTop: 10,
    justifyContent: 'center',
    alignItems: 'center',
  },
};

export default AccountSetup;


--- FILE: src/screens/Account/AdvancedFields.jsx ---



--- FILE: src/screens/Account/DefaultGroupView.jsx ---



--- FILE: src/screens/Account/Help.jsx ---

//* Help.jsx
import React, {useState} from 'react';
import {useNavigation} from '@react-navigation/native';
import {Layout, Modal, ScrollView, Text} from '../../KQ-UI';
import {ScreenStyles} from '../../styles/Styles';
import {useProfile} from '../../hooks/useHooks';
import {View} from 'react-native';
import TellMeButton from '../../components/TellMeButton';
import {AppInfo} from '../../../AppInfo';
import TermsService from '../Legal/TermsService';
import PrivacyPolicy from '../Legal/PrivacyPolicy';
import About from '../Legal/About';

const Help = () => {
  const profile = useProfile();
  const navigation = useNavigation();

  const [showPPModal, setShowPPModal] = useState(false);
  const [showTOSModal, setShowTOSModal] = useState(false);
  const [showAboutModal, setShowAboutModal] = useState(false);

  return (
    <Layout
      headerTitle="Help"
      LeftButton="Back"
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      // outerViewStyles={{paddingBottom: 0}}
    >
      <View style={[ScreenStyles.viewContainer, {flex: 1}]}>
        <View style={ScreenStyles.viewInnerTopContainer}>
          <Text size="small" font="open-7" centered>
            Tell me about...
          </Text>
        </View>

        <ScrollView contentContainerStyle={ScreenStyles.scrollContainer}>
          <TellMeButton
            profile={profile?.userSettings?.hapticStrength}
            action={() => setShowAboutModal(true)}
            tt1={`${AppInfo.appName}`}
            tt2="Information about this app."
          />
          <TellMeButton
            profile={profile?.userSettings?.hapticStrength}
            action={() => setShowPPModal(true)}
            tt1="Privacy Policy"
            tt2="How we collect, use, and protect your data."
          />
          <TellMeButton
            profile={profile?.userSettings?.hapticStrength}
            action={() => setShowTOSModal(true)}
            tt1="Terms of Service"
            tt2="The rules and regulations for using our services."
          />
          {/* <TellMeButton
            profile={profile?.userSettings?.hapticStrength}
            action={() => navigation.navigate('Passwords')}
            tt1="Changing My Password"
            tt2="Changes your password to a new one."
          /> */}
          <TellMeButton
            profile={profile?.userSettings?.hapticStrength}
            action={() => navigation.navigate('Resets')}
            tt1="Resetting Your Lists"
            tt2="Clear your cupboard / shopping lists."
          />
        </ScrollView>
      </View>
      <Modal
        visible={showTOSModal}
        title={`Terms of Service v${AppInfo.tosVersion}`}
        onClose={() => setShowTOSModal(false)}
        headerFont="open-6"
        headerSize="small"
        height="98%"
        width="98%">
        <TermsService hideConfirm />
      </Modal>
      <Modal
        visible={showPPModal}
        title={`Privacy Policy v${AppInfo.ppVersion}`}
        onClose={() => setShowPPModal(false)}
        headerFont="open-6"
        headerSize="small"
        height="98%"
        width="98%">
        <PrivacyPolicy hideConfirm />
      </Modal>
      <Modal
        visible={showAboutModal}
        title={`About ${AppInfo.appName}`}
        onClose={() => setShowAboutModal(false)}
        headerFont="open-6"
        headerSize="small"
        height="98%"
        width="98%">
        <About hideConfirm />
      </Modal>
    </Layout>
  );
};

export default Help;


--- FILE: src/screens/Account/ItemDisplay.jsx ---

// * ItemDisplay.jsx
import React, {useState, useEffect, useMemo} from 'react';
import {View, TouchableOpacity} from 'react-native';
import {Button, Layout, ScrollView, Text} from '../../KQ-UI';
import {useDispatch} from 'react-redux';
import {useProfile, useShoppingCart} from '../../hooks/useHooks';
import {
  displayMeasurements,
  formatMeasurement,
} from '../../utilities/measurements';
import pluralize from 'pluralize';
import {Icons} from '../../components/IconListRouter';

const defaultFlashCellOrder = [
  {index: 0, key: 'brandName', label: 'Brand Name'},
  {index: 1, key: 'description', label: 'Description'},
  {index: 2, key: 'itemName', label: 'Item Name'},
];

const areArraysEqual = (a, b) =>
  a.length === b.length && a.every((item, i) => item.key === b[i].key);

const ItemDisplay = () => {
  const dispatch = useDispatch();
  const profile = useProfile();
  const shopping = useShoppingCart();

  const userSettings =
    profile?.userSettings?.flashCellOrder || defaultFlashCellOrder;

  const [initialFlashCellOrder] = useState([...userSettings]);
  const [flashCellOrder, setFlashCellOrder] = useState([...userSettings]);
  const [canSave, setCanSave] = useState(false);

  const demoItem = useMemo(() => {
    const item =
      shopping?.items?.find(item => item.status === 'shopping-list') || {};
    return {
      brandName: item.brandName || 'Local Brand',
      description: item.description || '2% Reduced Fat',
      itemName: item.itemName || 'Milk',
      packageSize: item.packageSize || '52',
      measurement: item.measurement || 'fluidounce',
      quantity: item.quantity || '1',
    };
  }, [shopping]);

  const renderPreviewText = useMemo(() => {
    return flashCellOrder
      .map(field => demoItem[field.key])
      .filter(Boolean)
      .join(' ');
  }, [flashCellOrder, demoItem]);

  const formatMeasurementWithPlural = (packageSize, measurement, itemName) => {
    if (!packageSize || !measurement) return '';

    if (packageSize === 1 && measurement === 'each') return '';
    if (measurement === 'each') return `${packageSize} ${pluralize(itemName)}`;

    const match = displayMeasurements.find(m => m.key === measurement);
    const label = match?.label || formatMeasurement(measurement);

    return `${packageSize} ${packageSize > 1 ? pluralize(label) : label}`;
  };

  useEffect(() => {
    setCanSave(!areArraysEqual(flashCellOrder, initialFlashCellOrder));
  }, [flashCellOrder, initialFlashCellOrder]);

  const handleSave = () => {
    if (!canSave) return;
    dispatch({
      type: 'UPDATE_PROFILE_REQUEST',
      payload: {
        userId: profile?.id,
        updatedData: {
          userSettings: {
            ...profile.userSettings,
            flashCellOrder,
          },
        },
      },
    });
  };

  const hasResettableChanges = () =>
    !areArraysEqual(flashCellOrder, defaultFlashCellOrder);

  const handleReset = () => {
    setFlashCellOrder([...defaultFlashCellOrder]);
  };

  const handleMove = (index, direction) => {
    const newIndex = index + direction;
    if (newIndex < 0 || newIndex >= flashCellOrder.length) return;

    const updated = [...flashCellOrder];
    [updated[index], updated[newIndex]] = [updated[newIndex], updated[index]];
    setFlashCellOrder(updated);
  };

  return (
    <Layout
      headerTitle="Item Display"
      LeftButton="Back"
      RightButton={canSave ? 'Save' : ''}
      LeftAction={null}
      RightAction={handleSave}
      sheetOpen={false}>
      <ScrollView style={{padding: 10}}>
        <Text centered size="small" style={{marginBottom: 5}}>
          Example Preview:
        </Text>

        <View
          style={{
            flexDirection: 'row',
            alignItems: 'center',
            borderBottomWidth: 1,
            borderTopWidth: 1,
            borderColor: '#373d4380',
            marginHorizontal: 10,
            height: 65,
            backgroundColor: '#fff',
            paddingHorizontal: 10,
          }}>
          <View
            style={{width: 60, justifyContent: 'center', alignItems: 'center'}}>
            <View
              style={{
                width: 50,
                height: 50,
                borderWidth: 1.25,
                borderColor: '#373d4380',
                borderRadius: 8,
                justifyContent: 'center',
                alignItems: 'center',
                elevation: 4,
                backgroundColor: '#fff',
              }}>
              <Text size="tiny">Qty</Text>
              <Text size="medium">{demoItem.quantity}</Text>
            </View>
          </View>
          <View style={{flex: 1, justifyContent: 'center', marginLeft: 10}}>
            <Text numberOfLines={1} size="small" font="open-7">
              {renderPreviewText}
            </Text>
            <Text size="xSmall" numberOfLines={1}>
              {formatMeasurementWithPlural(
                demoItem.packageSize,
                demoItem.measurement,
                demoItem.itemName,
              )}
            </Text>
          </View>
        </View>

        <View style={{marginTop: 20}}>
          {flashCellOrder.map((field, index) => (
            <View
              key={field.key}
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                paddingVertical: 10,
                borderBottomWidth: index !== flashCellOrder.length - 1 ? 1 : 0,
                borderColor: '#e0e0e0',
              }}>
              <Text style={{width: 25}} size="small" centered>
                {index + 1}.
              </Text>
              <Text style={{flex: 1}} size="small">
                {field.label}
              </Text>
              <View style={{flexDirection: 'row'}}>
                <TouchableOpacity
                  disabled={index === 0}
                  onPress={() => handleMove(index, -1)}
                  style={{
                    paddingHorizontal: 5,
                    opacity: index === 0 ? 0.4 : 1,
                  }}>
                  <Icons.ChevronUp size={18} color="#29856c" />
                </TouchableOpacity>
                <TouchableOpacity
                  disabled={index === flashCellOrder.length - 1}
                  onPress={() => handleMove(index, 1)}
                  style={{
                    paddingHorizontal: 5,
                    opacity: index === flashCellOrder.length - 1 ? 0.4 : 1,
                  }}>
                  <Icons.ChevronDown size={18} color="#29856c" />
                </TouchableOpacity>
              </View>
            </View>
          ))}
        </View>
        <Button
          type="outline"
          size="small"
          color="primary"
          disabled={!hasResettableChanges()}
          onPress={handleReset}>
          Reset
        </Button>
      </ScrollView>
    </Layout>
  );
};

export default ItemDisplay;


--- FILE: src/screens/Account/Passwords.jsx ---



--- FILE: src/screens/Account/Profile.jsx ---

//* Profile.jsx
import React, {useEffect, useMemo, useState} from 'react';
import {TouchableOpacity, View} from 'react-native';
import {ProfileStyles} from '../../styles/Styles';
import {useDispatch} from 'react-redux';
import {useDeviceInfo, useProfile} from '../../hooks/useHooks';
import {
  avatarConfig,
  bgColorOptions,
  categoryOptions,
  colorOptions,
  facialHairOptions,
  glassesOptions,
  graphicOptions,
  hairColorOptions,
  hairStyleOptions,
  shirtOptions,
  skinColorOptions,
} from '../../utilities/avatarOptions';
import {Icons} from '../../components/IconListRouter';
import {Input, Layout, ScrollView, Text} from '../../KQ-UI';
import Avatar from '../../components/Avatar';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';

function Profile() {
  const dispatch = useDispatch();
  const profile = useProfile();
  const [firstName, setFirstName] = useState(profile?.firstName || '');
  const [lastName, setLastName] = useState(profile?.lastName || '');
  const [onlineName, setOnlineName] = useState(profile?.onlineName || '');
  const [canSave, setCanSave] = useState(false);
  const device = useDeviceInfo();
  const useHaptics = setHapticFeedback();

  const [avatarSize, setAvatarSize] = useState({
    width: 200,
  });
  const [buttonHeight, setButtonHeight] = useState({
    height: 35,
  });
  const [buttonWidth, setButtonWidth] = useState({
    width: 150,
  });

  useEffect(() => {
    if (
      firstName !== profile?.firstName ||
      lastName !== profile?.lastName ||
      onlineName !== profile?.onlineName
    ) {
      setCanSave(true);
    } else {
      setCanSave(false);
    }
  }, [profile, firstName, lastName, onlineName]);

  useEffect(() => {
    if (profile?.account) {
      dispatch({type: 'FETCH_ACCOUNT', payload: profile.account});
    }
  }, [profile, dispatch]);

  const handleProfileUpdate = () => {
    const updatedPictureURL = {
      accessories: glassesOptions[avatarOptions.glasses] || '',
      accessoriesColor: colorOptions[avatarOptions.glassesColor] || '',
      backgroundColor: bgColorOptions[avatarOptions.bgColor] || '009DC4',
      clothesColor: colorOptions[avatarOptions.shirtColor] || '373D43',
      clothing: shirtOptions[avatarOptions.shirtStyle] || 'graphicShirt',
      clothingGraphic: graphicOptions[avatarOptions.clothingGraphic] || '',
      facialHair: facialHairOptions[avatarOptions.facialHair] || '',
      facialHairColor: hairColorOptions[avatarOptions.hairColor] || '',
      hairColor: hairColorOptions[avatarOptions.hairColor] || '1C1C1C',
      skinColor: skinColorOptions[avatarOptions.skinColor] || 'F3B28C',
      top: hairStyleOptions[avatarOptions.hairStyle] || 'shortFlat',
    };

    const updatedData = {
      firstName,
      lastName,
      onlineName,
      pictureURL: updatedPictureURL,
    };

    dispatch({
      type: 'UPDATE_PROFILE_REQUEST',
      payload: {userId: profile?.id, updatedData},
    });
  };

  const getIndexFromValue = (options, value) =>
    options.indexOf(value) !== -1 ? options.indexOf(value) : 0;

  const [avatarOptions, setAvatarOptions] = useState({
    bgColor: getIndexFromValue(
      bgColorOptions,
      profile?.pictureURL?.backgroundColor || '009DC4',
    ),
    skinColor: getIndexFromValue(
      skinColorOptions,
      profile?.pictureURL?.skinColor || 'FFE2C5',
    ),
    hairColor: getIndexFromValue(
      hairColorOptions,
      profile?.pictureURL?.hairColor || '6B4B31',
    ),
    hairStyle: getIndexFromValue(
      hairStyleOptions,
      profile?.pictureURL?.top || 'shortFlat',
    ),
    shirtStyle: getIndexFromValue(
      shirtOptions,
      profile?.pictureURL?.clothing || 'graphicShirt',
    ),
    shirtColor: getIndexFromValue(
      colorOptions,
      profile?.pictureURL?.clothesColor || '373D43',
    ),
    clothingGraphic: getIndexFromValue(
      graphicOptions,
      profile?.pictureURL?.clothingGraphic || '',
    ),
    glasses: getIndexFromValue(
      glassesOptions,
      profile?.pictureURL?.accessories || '',
    ),
    glassesColor: getIndexFromValue(
      colorOptions,
      profile?.pictureURL?.accessoriesColor || '373D43',
    ),
    facialHair: getIndexFromValue(
      facialHairOptions,
      profile?.pictureURL?.facialHair || '',
    ),
  });

  const handleAvatarOptionChange = (optionKey, optionsArray, direction) => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
    setAvatarOptions(prev => {
      const updatedOptions = {
        ...prev,
        [optionKey]:
          (prev[optionKey] + direction + optionsArray.length) %
          optionsArray.length,
      };
      return updatedOptions;
    });
  };

  useEffect(() => {
    const optionsMapping = {
      backgroundColor: bgColorOptions[avatarOptions.bgColor],
      accessories: glassesOptions[avatarOptions.glasses],
      accessoriesColor: colorOptions[avatarOptions.glassesColor],
      clothesColor: colorOptions[avatarOptions.shirtColor],
      clothing: shirtOptions[avatarOptions.shirtStyle],
      clothingGraphic: graphicOptions[avatarOptions.clothingGraphic],
      facialHair: facialHairOptions[avatarOptions.facialHair],
      facialHairColor: hairColorOptions[avatarOptions.hairColor],
      hairColor: hairColorOptions[avatarOptions.hairColor],
      skinColor: skinColorOptions[avatarOptions.skinColor],
      top: hairStyleOptions[avatarOptions.hairStyle],
    };

    const avatarChanged = Object.keys(optionsMapping).some(
      key => profile?.pictureURL?.[key] !== optionsMapping[key],
    );

    if (avatarChanged) {
      setCanSave(true);
    } else {
      setCanSave(false);
    }
  }, [avatarOptions, profile?.pictureURL]);

  const shouldShowGraphic =
    shirtOptions[avatarOptions.shirtStyle] === 'graphicShirt';

  const filteredAvatarConfig = useMemo(() => {
    const configCopy = {...avatarConfig};

    if (!shouldShowGraphic) {
      configCopy['Shirt'] = configCopy['Shirt']?.filter(
        option => option.optionKey !== 'clothingGraphic',
      );
    }

    return configCopy;
  }, [avatarOptions.shirtStyle]);

  const [currentCatIndex, setCurrentCatIndex] = useState(0);

  const [currentCat, setCurrentCat] = useState(categoryOptions[0]);

  const handleNextCat = () => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
    setCurrentCatIndex(prevIndex => {
      const nextIndex = (prevIndex + 1) % categoryOptions.length;
      setCurrentCat(categoryOptions[nextIndex]);
      return nextIndex;
    });
  };

  const handlePrevCat = () => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
    setCurrentCatIndex(prevIndex => {
      const prevIndexAdjusted =
        (prevIndex - 1 + categoryOptions.length) % categoryOptions.length;
      setCurrentCat(categoryOptions[prevIndexAdjusted]);
      return prevIndexAdjusted;
    });
  };

  const handleBtnPress = (optionKey, optionsArray, direction) => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
  };

  const AvCategory = () => {
    return (
      <View
        style={[
          ProfileStyles.optionContainer,
          buttonHeight,
          {marginBottom: 5},
        ]}>
        <View style={{flex: 1}}></View>
        <TouchableOpacity
          style={ProfileStyles.optionLeft}
          onPress={handlePrevCat}>
          <View style={ProfileStyles.olInner}>
            <Icons.Back size={18} />
          </View>
        </TouchableOpacity>
        <View style={[ProfileStyles.optionView, buttonWidth]}>
          <Text size={buttonTextSize}>{currentCat}</Text>
        </View>
        <TouchableOpacity
          style={ProfileStyles.optionRight}
          onPress={handleNextCat}>
          <View style={ProfileStyles.orInner}>
            <Icons.Forward size={18} />
          </View>
        </TouchableOpacity>
        <View style={{flex: 1}}></View>
      </View>
    );
  };

  const AvButton = ({text, leftAction, rightAction}) => (
    <View style={[ProfileStyles.optionContainer, buttonHeight]}>
      <View style={{flex: 1}}></View>
      <TouchableOpacity
        style={ProfileStyles.optionLeft}
        onPress={() => leftAction()}>
        <View style={ProfileStyles.olInner}>
          <Icons.Back size={18} />
        </View>
      </TouchableOpacity>
      <View style={[ProfileStyles.optionView, buttonWidth]}>
        <Text size={buttonTextSize}>{text}</Text>
      </View>
      <TouchableOpacity
        style={ProfileStyles.optionRight}
        onPress={() => rightAction()}>
        <View style={ProfileStyles.orInner}>
          <Icons.Forward size={18} />
        </View>
      </TouchableOpacity>
      <View style={{flex: 1}}></View>
    </View>
  );

  const AvButtonDynamic = ({text, optionKey, optionsArray}) => (
    <AvButton
      text={text}
      leftAction={() => handleAvatarOptionChange(optionKey, optionsArray, -1)}
      rightAction={() => handleAvatarOptionChange(optionKey, optionsArray, 1)}
    />
  );

  const [buttonTextSize, setButtonTextSize] = useState('small');

  useEffect(() => {
    switch (device?.system?.deviceSize) {
      case 'xSmall':
        setAvatarSize({width: 100, height: 100});
        setButtonHeight({height: 35});
        setButtonWidth({width: 125});
        setButtonTextSize('xSmall');
        break;
      case 'small':
        setAvatarSize({width: 125, height: 125});
        setButtonHeight({height: 35});
        setButtonWidth({width: 150});
        setButtonTextSize('small');
        break;
      case 'medium':
        setAvatarSize({width: 150, height: 150});
        setButtonHeight({height: 35});
        setButtonWidth({width: 175});
        setButtonTextSize('small');
        break;
      default:
        setAvatarSize({width: 175, height: 175});
        setButtonHeight({height: 40});
        setButtonWidth({width: 175});
        setButtonTextSize('small');
    }
  }, [device?.system?.deviceSize]);

  return (
    <Layout
      headerTitle="Profile"
      LeftButton="Back"
      RightButton={canSave ? 'Save' : ''}
      RightAction={handleProfileUpdate}
      LeftAction={false}
      sheetOpen={false}
      mode="scroll-only"
      noBar={true}
      // outerViewStyles={{paddingBottom: 0}}
    >
      <Input
        label="Email"
        placeholder="Email"
        value={profile?.email}
        disabled
      />
      <Input
        label="First Name"
        placeholder="First Name"
        value={firstName}
        onChangeText={setFirstName}
        capitalize
        capitalMode="words"
      />
      <Input
        label="Last Name"
        placeholder="Last Name"
        value={lastName}
        onChangeText={setLastName}
        capitalize
        capitalMode="words"
      />
      <Input
        label={'Online Name'}
        placeholder="Online Name"
        value={onlineName}
        onChangeText={setOnlineName}
        capitalize
        capitalMode="words"
      />
      <ScrollView>
        <View style={{alignItems: 'center', marginTop: 25, marginBottom: 10}}>
          <Avatar
            profilePicture={profile?.pictureURL}
            avatarOptions={avatarOptions}
            viewStyles={[avatarSize, {borderRadius: avatarSize.width / 2}]}
            isEditing
          />
        </View>

        <AvCategory />
        {filteredAvatarConfig[currentCat]?.map(
          ({text, optionKey, optionsArray}, index) => (
            <AvButtonDynamic
              key={`${currentCat}-${index}`}
              text={text}
              optionKey={optionKey}
              optionsArray={optionsArray}
            />
          ),
        )}
      </ScrollView>
    </Layout>
  );
}

export default Profile;


--- FILE: src/screens/Account/Resets.jsx ---

//* Resets.jsx
import React from 'react';
import {View, Alert} from 'react-native';
import {useDispatch} from 'react-redux';
import {ScreenStyles} from '../../styles/Styles';
import {Layout, ScrollView, Text} from '../../KQ-UI';
import TellMeButton from '../../components/TellMeButton';
import {useCoreInfo} from '../../utilities/coreInfo';

const Resets = () => {
  const core = useCoreInfo();
  const dispatch = useDispatch();

  const resetCupboard = () => {
    if (core?.role === 'owner') {
      Alert.alert(
        'Reset Cupboard',
        'Are you sure you want to reset your cupboard? This is a destructive action and cannot be undone.',
        [
          {
            text: 'Cancel',
            style: 'cancel',
          },
          {
            text: 'Confirm',
            style: 'destructive',
            onPress: () => {
              dispatch({
                type: 'RESET_CUPBOARD',
                payload: {
                  cupboardID: core?.cupboardID,
                  profileID: core?.profileID,
                },
              });
            },
          },
        ],
      );
    } else {
      Alert.alert(
        'Reset Cupboard',
        'You do not have permission to reset the cupboard. Only the account owner can do this.',
        [
          {
            text: 'Close',
            style: 'cancel',
          },
        ],
      );
    }
  };
  const resetShoppingList = () => {
    Alert.alert(
      'Reset Shopping List',
      'Are you sure you want to reset your shopping list? This is a destructive action and cannot be undone.',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Confirm',
          style: 'destructive',
          onPress: () => {
            dispatch({
              type: 'RESET_SHOP_CART',
              payload: {
                shoppingCartID: core?.shoppingCartID,
                profileID: core?.profileID,
              },
            });
          },
        },
      ],
    );
  };

  const resetFavorites = () => {
    Alert.alert(
      'Reset Favorites List',
      'Are you sure you want to reset your favorites list? This is a destructive action and cannot be undone.',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Confirm',
          style: 'destructive',
          onPress: () => {
            dispatch({
              type: 'RESET_FAVORITES',
              payload: {
                favoriteItemsID: core?.favoriteItemsID,
                profileID: core?.profileID,
              },
            });
          },
        },
      ],
    );
  };

  return (
    <Layout
      headerTitle="Resets"
      LeftButton="Back"
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}>
      <View style={[ScreenStyles.viewContainer, {flex: 1}]}>
        <View style={ScreenStyles.viewInnerTopContainer}>
          <Text size="small" font="open-7" centered>
            Tell me about...
          </Text>
        </View>
        <ScrollView contentContainerStyle={ScreenStyles.scrollContainer}>
          <TellMeButton
            profile={core?.userSettings?.hapticStrength}
            action={resetFavorites}
            tt1="Reset My Favorites"
            tt2="Clears all items from my favorites."
          />

          <TellMeButton
            profile={core?.userSettings?.hapticStrength}
            action={resetShoppingList}
            tt1="Reset My Shopping List"
            tt2="Clears all items from my shopping list."
          />
          <TellMeButton
            profile={core?.userSettings?.hapticStrength}
            action={resetCupboard}
            tt1="Reset My Cupboard"
            tt2="Clears all items from my cupboard."
          />
        </ScrollView>
      </View>
    </Layout>
  );
};

export default Resets;


--- FILE: src/screens/Account/SAButton.jsx ---

//* SAButton.jsx
import React from 'react';
import {View, TouchableOpacity} from 'react-native';
import {AccountStyles} from '../../styles/Styles';
import {useNavigation} from '@react-navigation/native';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';
import {useProfile} from '../../hooks/useHooks';
import {Text} from '../../KQ-UI';

const SAButton = props => {
  const {location, icon, title} = props;
  const useHaptics = setHapticFeedback();
  const navigation = useNavigation();
  const profile = useProfile();
  return (
    <View style={{flex: 1}}>
      <TouchableOpacity
        style={AccountStyles.subWrapper}
        onPress={() => {
          navigation.navigate(location);
          useHaptics(profile?.userSettings?.hapticStrength || 'light');
        }}>
        <View style={AccountStyles.subIcon}>{icon}</View>
        <View style={AccountStyles.subTextWrap}>
          <Text size="small" font="open-7">
            {title}
          </Text>
        </View>
      </TouchableOpacity>
    </View>
  );
};

export default React.memo(SAButton);


--- FILE: src/screens/Account/Settings.jsx ---

//* Settings.jsx
import React from 'react';
import {useNavigation} from '@react-navigation/native';
import {Layout, ScrollView, Text} from '../../KQ-UI';
import {ScreenStyles} from '../../styles/Styles';
import {useProfile} from '../../hooks/useHooks';
import {View} from 'react-native';
import TellMeButton from '../../components/TellMeButton';

const Settings = () => {
  const profile = useProfile();
  const navigation = useNavigation();

  return (
    <Layout
      headerTitle="Settings"
      LeftButton="Back"
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      // outerViewStyles={{paddingBottom: 0}}
    >
      <View style={[ScreenStyles.viewContainer, {flex: 1}]}>
        <View style={ScreenStyles.viewInnerTopContainer}>
          <Text size="small" font="open-7" centered>
            Customize settings for...
          </Text>
        </View>
        <ScrollView contentContainerStyle={ScreenStyles.scrollContainer}>
          <TellMeButton
            profile={profile?.userSettings?.hapticStrength}
            action={() => navigation.navigate('Vibrations')}
            tt1="Vibrations"
            tt2="Adjust the vibration strength of actions."
          />
          <TellMeButton
            profile={profile?.userSettings?.hapticStrength}
            action={() => navigation.navigate('ItemDisplay')}
            tt1="Item Display"
            tt2="Change the information ordered in the lists."
          />
          {/* <TellMeButton
            profile={profile?.userSettings?.hapticStrength}
            action={() => navigation.navigate('AdvancedFields')}
            tt1="Advanced Fields"
            tt2="Enable or Disable advanced fields."
          /> */}
          {/* 
        //TODO: Add these settings later
      <TellMeButton
        action={() => navigation.navigate('DefaultView')}
        tt1="Default View Mode"
        tt2="Default to Group or Single view in Cupboards."
      /> */}
        </ScrollView>
      </View>
    </Layout>
  );
};

export default Settings;


--- FILE: src/screens/Account/Vibrations.jsx ---

//* Vibrations.jsx

import React, {useEffect, useState} from 'react';
import {Layout, ScrollView, Text} from '../../KQ-UI';
import {useDispatch} from 'react-redux';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';
import {useProfile} from '../../hooks/useHooks';
import {TouchableOpacity, View} from 'react-native';
import {Icons} from '../../components/IconListRouter';
import {ScreenStyles, SettingsStyles} from '../../styles/Styles';

const hapticOptions = [
  {
    row: [
      {label: 'Off', icon: null},
      {
        label: 'Light',
        icon: <Icons.Wave size={25} color={'#29856c'} />,
        activeIcon: <Icons.Wave size={25} color={'#fff'} />,
      },
    ],
  },
  {
    row: [
      {
        label: 'Medium',
        icon: (
          <View>
            <View style={{position: 'relative', top: 9.25}}>
              <Icons.Wave size={25} color={'#29856c'} />
            </View>
            <View style={{position: 'relative', bottom: 9.25}}>
              <Icons.Wave size={25} color={'#29856c'} />
            </View>
          </View>
        ),
        activeIcon: (
          <View>
            <View style={{position: 'relative', top: 9.25}}>
              <Icons.Wave size={25} color={'#fff'} />
            </View>
            <View style={{position: 'relative', bottom: 9.25}}>
              <Icons.Wave size={25} color={'#fff'} />
            </View>
          </View>
        ),
      },
      {
        label: 'Heavy',
        icon: (
          <View>
            <View style={{position: 'relative', top: 18.5}}>
              <Icons.Wave size={25} color={'#29856c'} />
            </View>
            <View>
              <Icons.Wave size={25} color={'#29856c'} />
            </View>
            <View style={{position: 'relative', bottom: 18.5}}>
              <Icons.Wave size={25} color={'#29856c'} />
            </View>
          </View>
        ),
        activeIcon: (
          <View>
            <View style={{position: 'relative', top: 18.5}}>
              <Icons.Wave size={25} color={'#fff'} />
            </View>
            <View>
              <Icons.Wave size={25} color={'#fff'} />
            </View>
            <View style={{position: 'relative', bottom: 18.5}}>
              <Icons.Wave size={25} color={'#fff'} />
            </View>
          </View>
        ),
      },
    ],
  },
];

const Vibrations = () => {
  const dispatch = useDispatch();
  const useHaptics = setHapticFeedback();
  const profile = useProfile();
  const [hapticStrength, setHapticStrength] = useState(
    profile?.userSettings?.hapticStrength || 'light',
  );
  const [canSave, setCanSave] = useState(false);

  useEffect(() => {
    if (profile?.userSettings?.hapticStrength !== hapticStrength) {
      setCanSave(true);
    } else {
      setCanSave(false);
    }
  }, [profile, hapticStrength]);

  const handleSave = () => {
    if (!canSave) return;
    dispatch({
      type: 'UPDATE_PROFILE_REQUEST',
      payload: {
        userId: profile?.id,
        updatedData: {
          userSettings: {
            ...(profile.userSettings || {}),
            hapticStrength,
          },
        },
      },
    });
  };

  const InfoCell = ({label, description}) => (
    <View style={{marginTop: 5, flexDirection: 'row'}}>
      <View style={{flex: 1, alignItems: 'flex-end', paddingHorizontal: 5}}>
        <Text font="open-7" size="small">
          {label}
        </Text>
      </View>
      {description && (
        <View style={{flex: 2, paddingHorizontal: 5}}>
          <Text size="small">{description}</Text>
        </View>
      )}
    </View>
  );

  const HSButton = ({option}) => {
    const isActive = hapticStrength === option.label.toLowerCase();

    return (
      <TouchableOpacity
        onPress={() => {
          setHapticStrength(option.label.toLowerCase());
          useHaptics(option.label.toLowerCase());
        }}
        style={[
          SettingsStyles.hapticButton,
          {
            backgroundColor: isActive ? '#29856c' : '#fff',
            borderWidth: isActive ? 0 : 1,
          },
        ]}>
        <View style={SettingsStyles.hbInner}>
          <View style={{marginHorizontal: 5}}>
            {isActive ? option.activeIcon : option.icon}
          </View>
          <View style={{marginHorizontal: 5}}>
            <Text
              weight="w7"
              size="small"
              style={{
                color: isActive ? '#fff' : '#29856c',
              }}>
              {option.label}
            </Text>
          </View>
        </View>
      </TouchableOpacity>
    );
  };

  return (
    <Layout
      headerTitle="Vibrations"
      LeftButton="Back"
      RightButton={canSave ? 'Save' : ''}
      LeftAction={null}
      RightAction={handleSave}
      sheetOpen={false}
      // outerViewStyles={{paddingBottom: 0}}
    >
      <ScrollView style={ScreenStyles.scrollContainer}>
        <View style={ScreenStyles.viewInnerTopContainer}>
          <Text centered>Press a button to set your vibration intensity.</Text>
        </View>
        {hapticOptions.map((group, groupIndex) => (
          <View
            key={groupIndex}
            style={SettingsStyles.segmentedButtonContainer}>
            {group.row.map((option, index) => (
              <View key={index} style={{flex: 1}}>
                <HSButton option={option} />
              </View>
            ))}
          </View>
        ))}
      </ScrollView>
      <View style={{marginTop: 20}}>
        <InfoCell label="Off:" description="No vibration intensity." />
        <InfoCell label="Light:" description="Subtle vibration intensity." />
        <InfoCell label="Medium:" description="Standard vibration intensity." />
        <InfoCell label="Heavy:" description="Strong vibration intensity." />
      </View>
      <View style={{marginTop: 30, paddingHorizontal: 10}}>
        <Text size="small" font="open-5" italic>
          Note: The default for vibration is preset to "Light". The chosen
          setting will not affect all buttons or actions due to some functions
          that require a forced vibration. However, if you choose 'Off', it will
          turn off all vibrations in the app.
        </Text>
      </View>
    </Layout>
  );
};

export default Vibrations;


--- FILE: src/screens/Auth/Auth.jsx ---

//* Auth.jsx
import React, {useCallback, useEffect, useMemo, useRef, useState} from 'react';
import {
  ActivityIndicator,
  Animated,
  Easing,
  Image,
  StatusBar,
  TouchableWithoutFeedback,
  View,
} from 'react-native';
import {useDispatch} from 'react-redux';
import {Button, Input, Layout, ScrollView, Text} from '../../KQ-UI';
import {useDeviceInfo, useLoginError} from '../../hooks/useHooks';
import {Icons} from '../../components/IconListRouter';
import {useColors} from '../../KQ-UI/KQUtilities';

function Auth(props) {
  const {bgColor, isSplashVisible} = props;
  const dispatch = useDispatch();
  const device = useDeviceInfo();
  const loginError = useLoginError();

  // ---------- View + Animation State ----------
  const [authView, setAuthView] = useState('create'); // 'login' | 'create' | 'completed'
  const [logoSet, setLogoSet] = useState(false);
  const [delayedError, setDelayedError] = useState(null);
  const logoTop = useRef(new Animated.Value(2)).current;
  const hasAnimated = useRef(false);

  // ---------- Input State ----------
  const [secureTextEntry, setSecureTextEntry] = useState(true);
  const [secureTextEntry1, setSecureTextEntry1] = useState(true);
  const [secureTextEntry2, setSecureTextEntry2] = useState(true);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [createEmail, setCreateEmail] = useState('');
  const [createPassword, setCreatePassword] = useState('');
  const [confirmedPassword, setConfirmedPassword] = useState('');

  // ---------- Derived Sizes ----------
  const deviceWidth = device?.dimensions?.width;
  const deviceHeight = device?.dimensions?.height;

  const logoSizeConfig = useMemo(() => {
    const type = device?.system?.deviceSize;
    switch (type) {
      case 'large':
        return {scale: 1.1, activityOffset: 65};
      case 'medium':
        return {scale: 1.2, activityOffset: 60};
      case 'small':
        return {scale: 1.3, activityOffset: 55};
      case 'xSmall':
        return {scale: 1.4, activityOffset: 50};
      default:
        return {scale: 1, activityOffset: 70};
    }
  }, [device]);

  const logoWidth = 350 / logoSizeConfig.scale;
  const logoHeight = 175 / logoSizeConfig.scale;
  const actPosition = logoSizeConfig.activityOffset;

  const xPosition = useMemo(() => {
    if (!deviceWidth || !logoWidth) return 0;
    return deviceWidth / 2 - logoWidth / 2 - 5;
  }, [deviceWidth]);

  const yPosition = useMemo(() => {
    if (!deviceHeight || !logoHeight) return 0;
    return deviceHeight / 2.25 - logoHeight / 1.37;
  }, [deviceHeight]);

  // ---------- Validation ----------
  const isValidEmail = useCallback(
    email => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
    [],
  );

  const isValidPassword = useCallback(
    password =>
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%&*])[A-Za-z\d!@#$%&*]{8,}$/.test(
        password,
      ),
    [],
  );

  const canSignIn = isValidEmail(email) && isValidPassword(password);

  const passwordValidation = useMemo(() => {
    const length = createPassword.length >= 8;
    const upperCase = /[A-Z]/.test(createPassword);
    const lowerCase = /[a-z]/.test(createPassword);
    const number = /\d/.test(createPassword);
    const special = /[!@#$%&*]/.test(createPassword);
    const onlyAllowedChars = /^[a-zA-Z0-9!@#$%&*]*$/.test(createPassword);
    const match =
      confirmedPassword.length > 0 && createPassword === confirmedPassword;

    return {
      validEmail: isValidEmail(createEmail),
      length,
      upperCase,
      lowerCase,
      number,
      special,
      onlyAllowedChars,
      match,
    };
  }, [createEmail, createPassword, confirmedPassword, isValidEmail]);

  const checkMode = useCallback(
    (type, value1, value2) => {
      if (type === 'password-length')
        return value1 >= 8 ? 'check' : value1 ? 'error' : 'uncheck';
      if (type === 'email-check')
        return isValidEmail(value1) ? 'check' : value1 ? 'error' : 'uncheck';
      if (type === 'default')
        return value2 === 0 ? 'uncheck' : value1 ? 'check' : 'error';
    },
    [isValidEmail],
  );

  const allValid = Object.values(passwordValidation).every(Boolean);

  // ---------- Effects ----------
  useEffect(() => {
    if (!isSplashVisible && !hasAnimated.current) {
      hasAnimated.current = true;
      Animated.timing(logoTop, {
        toValue: -(deviceHeight / 2.25 - logoHeight),
        duration: 800,
        useNativeDriver: false,
        easing: Easing.inOut(Easing.ease),
      }).start(() => setLogoSet(true));
    }
  }, [isSplashVisible]);

  useEffect(() => {
    if (!isSplashVisible && logoSet) {
      setAuthView('login');
    }
  }, [isSplashVisible, logoSet]);

  useEffect(() => {
    if (loginError) {
      const showErrorTimer = setTimeout(() => setDelayedError(loginError), 200);
      const logoutTimer = setTimeout(() => {
        dispatch({type: 'LOGOUT_AND_CLEAR'});
      }, 300);
      const resetFieldsTimer = setTimeout(() => {
        setPassword('');
      }, 1000);
      const clearErrorTimer = setTimeout(() => {
        setDelayedError(null);
      }, 5000);

      return () => {
        clearTimeout(showErrorTimer);
        clearTimeout(logoutTimer);
        clearTimeout(resetFieldsTimer);
        clearTimeout(clearErrorTimer);
      };
    } else {
      setDelayedError(null);
    }
  }, [loginError]);

  // ---------- Handlers ----------
  const handleInputChange = setter => value => {
    dispatch({type: 'LOGIN_FAILED', payload: null});
    setter(value);
  };

  const handleSignIn = () => {
    if (canSignIn) {
      dispatch({type: 'LOGIN_REQUEST', payload: {email, password}});
    }
  };

  const handleCreateUser = () => {
    if (allValid) {
      dispatch({
        type: 'SIGNUP_REQUEST',
        payload: {email: createEmail, password: createPassword},
      });

      setTimeout(() => setAuthView('completed'), 100);
      setTimeout(() => {
        setCreateEmail('');
        setCreatePassword('');
        setConfirmedPassword('');
        setEmail('');
        setPassword('');
      }, 500);
      setTimeout(() => setAuthView('login'), 7000);
    }
  };

  // ---------- UI Render ----------
  const CheckListWrap = ({children}) => (
    <View
      style={{
        backgroundColor: '#fff',
        minHeight: 50,
        borderWidth: 1,
        borderColor: '#C4C4C4',
        borderRadius: 8,
        shadowColor: '#373d4380',
        shadowOffset: {width: 1, height: 2},
        shadowOpacity: 0.25,
        shadowRadius: 2,
        elevation: 4,
        margin: 5,
        padding: 2,
      }}>
      {children}
    </View>
  );

  const CheckListItem = ({mode, message}) => (
    <View
      style={{
        flexDirection: 'row',
        alignItems: 'center',
        paddingHorizontal: 3,
        paddingVertical: 3,
      }}>
      <View style={{marginRight: 5}}>
        {mode === 'check' ? (
          <Icons.CheckFilledCircle size={15} color={useColors('primary')} />
        ) : mode === 'error' ? (
          <Icons.XCircle size={15} color={useColors('danger')} />
        ) : (
          <Icons.EmptyCircle size={15} color={useColors('dark60')} />
        )}
      </View>
      <Text
        size="xSmall"
        kqColor={
          mode === 'check' ? 'primary' : mode === 'error' ? 'danger' : 'dark60'
        }>
        {message}
      </Text>
    </View>
  );

  const renderEyeIcon = (visible, setVisible) => {
    const IconComponent = visible ? Icons.EyeOff : Icons.EyeOn;
    if (!IconComponent) return null;

    return (
      <TouchableWithoutFeedback onPress={() => setVisible(!visible)}>
        <IconComponent />
      </TouchableWithoutFeedback>
    );
  };

  const RenderDisplay = () => {
    switch (authView) {
      case 'login':
        return (
          <ScrollView
            style={{
              flex: 1,
              marginTop: logoHeight * 1.25,
              paddingTop: logoHeight / 1.5,
              paddingLeft: 10,
              marginHorizontal: -5,
            }}>
            <Input
              placeholder="Email"
              capitalize={false}
              value={email}
              onChangeText={handleInputChange(setEmail)}
              autoComplete="email"
              textContentType="emailAddress"
            />
            <Input
              placeholder="Password"
              value={password}
              onChangeText={handleInputChange(setPassword)}
              accessoryRight={() =>
                renderEyeIcon(secureTextEntry, setSecureTextEntry)
              }
              autoComplete="password"
              textContentType="password"
              secureTextEntry={true}
              capitalize={false}
            />
            <Button
              status={canSignIn ? 'primary' : 'basic'}
              onPress={handleSignIn}
              disabled={!canSignIn}>
              Sign In
            </Button>
            <View style={{marginVertical: 10}}>
              <Button
                type="ghost"
                color="primary"
                size="giant"
                textSize="medium"
                font="open-6"
                underline
                underlineWidth={2}
                onPress={() => setAuthView('create')}>
                <View style={{flexDirection: 'column', alignItems: 'center'}}>
                  <Text
                    // size="medium"
                    font="open-7"
                    kqColor="primary">{`New User?`}</Text>
                  <Text
                    font="open-7"
                    kqColor="primary">{`Let's get started!`}</Text>
                </View>
              </Button>
            </View>
            <View style={{height: 100, justifyContent: 'center'}}>
              {delayedError && (
                <Text size="small" centered kqColor="danger">
                  {delayedError}
                </Text>
              )}
            </View>
          </ScrollView>
        );
      case 'create':
        return (
          <ScrollView
            style={{
              flex: 1,
              marginTop: logoHeight * 1.25,
              paddingTop: 20,
              paddingLeft: 10,
              marginHorizontal: -5,
              backgroundColor: '#fff',
            }}>
            <Input
              placeholder="Email"
              capitalize={false}
              value={createEmail}
              onChangeText={setCreateEmail}
            />
            <Input
              placeholder="Password"
              value={createPassword}
              onChangeText={setCreatePassword}
              accessoryRight={() =>
                renderEyeIcon(secureTextEntry1, setSecureTextEntry1)
              }
              secureTextEntry={secureTextEntry1}
              capitalize={false}
            />
            <Input
              placeholder="Verify Password"
              value={confirmedPassword}
              onChangeText={setConfirmedPassword}
              accessoryRight={() =>
                renderEyeIcon(secureTextEntry2, setSecureTextEntry2)
              }
              secureTextEntry={secureTextEntry2}
              capitalize={false}
            />
            <CheckListWrap>
              <CheckListItem
                mode={checkMode('email-check', createEmail)}
                message="Valid email format"
              />
              <CheckListItem
                mode={checkMode('password-length', createPassword.length)}
                message="At least 8 characters"
              />
              <CheckListItem
                mode={checkMode(
                  'default',
                  passwordValidation.upperCase,
                  createPassword.length,
                )}
                message="An uppercase letter"
              />
              <CheckListItem
                mode={checkMode(
                  'default',
                  passwordValidation.lowerCase,
                  createPassword.length,
                )}
                message="A lowercase letter"
              />
              <CheckListItem
                mode={checkMode(
                  'default',
                  passwordValidation.number,
                  createPassword.length,
                )}
                message="A number"
              />
              <CheckListItem
                mode={checkMode(
                  'default',
                  passwordValidation.special,
                  createPassword.length,
                )}
                message="A special character (@$!%*?&)"
              />
              <CheckListItem
                mode={checkMode(
                  'default',
                  passwordValidation.match,
                  confirmedPassword.length,
                )}
                message="Passwords match"
              />
              {!passwordValidation.onlyAllowedChars && (
                <CheckListItem
                  mode={checkMode(
                    'default',
                    passwordValidation.onlyAllowedChars,
                    createPassword.length,
                  )}
                  message="Unsupported Character Used"
                />
              )}
            </CheckListWrap>
            <Button
              status={allValid ? 'primary' : 'basic'}
              disabled={!allValid}
              onPress={handleCreateUser}>
              Create User
            </Button>
            <View style={{marginVertical: 10}}>
              <Button
                type="ghost"
                color="primary"
                size="giant"
                textSize="medium"
                font="open-6"
                underline
                underlineWidth={2}
                onPress={() => setAuthView('login')}>
                <View style={{flexDirection: 'column', alignItems: 'center'}}>
                  <Text
                    // size="medium"
                    font="open-7"
                    kqColor="primary">{`Returning user?`}</Text>
                  <Text
                    font="open-7"
                    kqColor="primary">{`Press here to sign in.`}</Text>
                </View>
              </Button>
            </View>
          </ScrollView>
        );
      case 'completed':
        return (
          <View
            style={{
              flex: 1,
              marginTop: logoHeight * 1.25,
              paddingTop: 100,
              paddingHorizontal: 20,
              backgroundColor: '#fff',
            }}>
            <Text size="large" font="open-7" centered>
              Your profile has been created!
            </Text>
            <View style={{marginTop: 20}}>
              <Text size="medium" font="open-5" centered>
                We've emailed you a link!
              </Text>
              <Text size="medium" font="open-5" centered>
                Tap it to verify before logging in.
              </Text>
            </View>
            <Button
              type="ghost"
              color="primary"
              underline
              onPress={() => setAuthView('login')}>
              Back to Login
            </Button>
          </View>
        );
      default:
        return null;
    }
  };

  return (
    <Layout useHeader={false} mode="keyboard-static">
      <StatusBar backgroundColor={bgColor} barStyle="light-content" />
      <Animated.View
        pointerEvents="none"
        style={{
          position: 'absolute',
          top: yPosition,
          left: xPosition,
          zIndex: 999,
          transform: [{translateY: logoTop}],
        }}>
        {isSplashVisible && (
          <View style={{position: 'relative', top: actPosition}}>
            <ActivityIndicator size="large" color="#29856c" />
          </View>
        )}
        <Image
          source={require('../../images/AppLogo_350.png')}
          style={{width: logoWidth, height: logoHeight}}
        />
      </Animated.View>
      {!isSplashVisible && logoSet && RenderDisplay()}
    </Layout>
  );
}

export default Auth;


--- FILE: src/screens/CenterMenu/CenterMenu.jsx ---

//*CenterMenu.jsx
import React, {useCallback, useReducer} from 'react';
import {Alert, ScrollView, TouchableOpacity, View} from 'react-native';
import {useNavigation} from '@react-navigation/native';
import {useDispatch} from 'react-redux';
import {useShoppingCart} from '../../hooks/useHooks';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';
import {menuArray} from './CenterMenuArray';
import {Icons} from '../../components/IconListRouter';
import {CMStyles} from '../../styles/Styles';
import {Text} from '../../KQ-UI';
import {useCoreInfo} from '../../utilities/coreInfo';

function CenterMenu(props) {
  const {toggleMenu} = props;
  const navigation = useNavigation();
  const useHaptics = setHapticFeedback();
  const dispatch = useDispatch();
  const core = useCoreInfo();
  const shopping = useShoppingCart();
  const cartList =
    shopping?.items?.filter(item => item.status === 'shopping-cart') ?? [];

  const handleOnPress = useCallback(
    action => {
      if (action === 'console') return;
      if (action === 'Logout') {
        handleSignOut();
        return;
      }

      useHaptics(core?.userSettings?.hapticStrength || 'light');
      toggleMenu();

      if (typeof action === 'string') {
        navigation.navigate(action);
      } else if (typeof action === 'object' && action.screen) {
        navigation.navigate(action.screen, action.params || {});
      }
    },
    [core?.userSettings?.hapticStrength, toggleMenu, navigation],
  );

  const handleSignOut = useCallback(() => {
    Alert.alert('Logging Out', 'Are you sure you want to logout?', [
      {text: 'Cancel', style: 'destructive'},
      {
        text: 'Confirm',
        onPress: () => {
          useHaptics(core?.userSettings?.hapticStrength || 'light');
          dispatch({type: 'LOGOUT'});
        },
      },
    ]);
  }, [core?.userSettings?.hapticStrength, dispatch]);

  const sectionReducer = (state, action) => {
    return {...state, [action]: !state[action]};
  };

  const initialState = menuArray.reduce((acc, section) => {
    acc[section.section] = section.defaultOpen;
    return acc;
  }, {});

  const [sectionStates, dispatchSection] = useReducer(
    sectionReducer,
    initialState,
  );

  const toggleSection = useCallback(
    sectionName => dispatchSection(sectionName),
    [dispatchSection],
  );

  const SectionHeaderComponent = ({title, state, onPress}) => {
    return (
      <TouchableOpacity style={CMStyles.shContainer} onPress={onPress}>
        <View style={CMStyles.shLine}></View>
        <View style={{flex: 1, zIndex: 2}}>
          <View style={[CMStyles.shTWrap, {flex: 1}]}>
            <View style={CMStyles.shTO}>
              {state ? <Icons.ChevronUp /> : <Icons.ChevronDown />}
            </View>
          </View>
        </View>

        <View style={CMStyles.shTitleWrap}>
          <View style={CMStyles.shTitle}>
            <Text>{title}</Text>
          </View>
        </View>
      </TouchableOpacity>
    );
  };

  const SectionHeader = __DEV__
    ? SectionHeaderComponent
    : React.memo(SectionHeaderComponent);

  const SectionComponent = ({title, state, onPress, data}) => {
    return (
      <>
        <SectionHeader title={title} state={state} onPress={onPress} />
        {state ? (
          <View style={CMStyles.sectionExpanded}>
            {data.map((item, index) =>
              item.action === 'ShoppingCart' && cartList.length === 0 ? null : (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleOnPress(item.action)}
                  style={CMStyles.sectionTO}>
                  <View style={CMStyles.sectionIcon}>{item.icon}</View>
                  <Text>{item.title}</Text>
                </TouchableOpacity>
              ),
            )}
          </View>
        ) : (
          <View style={CMStyles.sectionCollapsed}>
            <Text size="xSmall">(Hidden: Expand to View)</Text>
          </View>
        )}
      </>
    );
  };

  const Section = __DEV__ ? SectionComponent : React.memo(SectionComponent);

  return (
    <ScrollView style={{backgroundColor: '#fff'}}>
      {menuArray.map((section, index) => (
        <Section
          key={index}
          title={section.section}
          state={sectionStates[section.section]}
          onPress={() => toggleSection(section.section)}
          data={section.items}
        />
      ))}
    </ScrollView>
  );
}

export default CenterMenu;


--- FILE: src/screens/CenterMenu/CenterMenuArray.jsx ---

//* CenterMenuArray.jsx
import {Icons} from '../../components/IconListRouter';

export const menuArray = [
  {
    section: 'Shopping',
    defaultOpen: true,
    items: [
      // future feature
      // {
      //   title: 'Scan to',
      //   icon: <Icons.Barcode />,
      //   action: 'console',
      // },
      {
        title: 'Add to',
        icon: <Icons.AddList />,
        action: {
          screen: 'ShoppingItems',
          params: {
            title: 'Add Item(s)',
            itemId: null,
            navigateBackTo: 'ShoppingList',
          },
        },
      },

      {
        title: 'View List',
        icon: <Icons.MenuList />,
        action: 'ShoppingList',
      },
      {
        title: 'View Cart',
        icon: <Icons.Shopping />,
        action: 'ShoppingCart',
      },
    ],
  },
  {
    section: 'Cupboard',
    defaultOpen: true,
    items: [
      // future feature
      // {
      //   title: 'Scan to',
      //   icon: <Icons.Barcode />,
      //   action: 'console',
      // },
      {
        title: 'Add to',
        icon: <Icons.AddList />,
        action: {
          screen: 'CupboardItems',
          params: {
            title: 'Add Item(s)',
            itemId: null,
            navigateBackTo: 'CupboardList-Single',
          },
        },
      },
      {
        title: 'View List',
        icon: <Icons.Cupboards />,
        action: 'CupboardList-Single',
      },
    ],
  },
  {
    section: 'Favorites',
    defaultOpen: true,
    items: [
      {
        title: 'Add to',
        icon: <Icons.AddList />,
        action: {
          screen: 'FavoriteItems',
          params: {
            title: 'Add Item(s)',
            itemId: null,
            navigateBackTo: 'FavoritesList',
          },
        },
      },

      {
        title: 'View List',
        icon: <Icons.Favorite />,
        action: 'FavoritesList',
      },
    ],
  },
  // future feature
  {
    section: 'Recipe',
    defaultOpen: true,
    items: [
      {
        title: 'Search',
        icon: <Icons.Search />,
        action: 'RecipeSearch',
      },
      {
        title: 'Add to',
        icon: <Icons.AddList />,
        action: 'AddRecipe',
      },

      {title: 'View List', icon: <Icons.Chest />, action: 'RecipeBox'},
    ],
  },
  {
    section: 'Misc',
    defaultOpen: true,
    items: [
      {
        title: 'View Account',
        icon: <Icons.Account />,
        action: 'Account',
      },
      {
        title: 'View Profile',
        icon: <Icons.Profile />,
        action: 'AccountProfile',
      },
      {
        title: 'View Settings',
        icon: <Icons.Settings />,
        action: 'AccountSettings',
      },
      {
        title: 'Get Help',
        icon: <Icons.Help />,
        action: 'AccountHelp',
      },
      {
        title: 'LogOut',
        icon: <Icons.Logout />,
        action: 'Logout',
      },
    ],
  },
  // __DEV__
  //   ? {
  //       section: '(Development)',
  //       defaultOpen: false,
  //       items: [
  //         {
  //           title: 'Dev Playground',
  //           icon: <Icons.Dev />,
  //           action: 'DevPlayground',
  //         },
  //         {
  //           title: 'Text',
  //           icon: <Icons.Dev />,
  //           action: 'DevText',
  //         },
  //         {
  //           title: 'Inputs',
  //           icon: <Icons.Dev />,
  //           action: 'DevInputs',
  //         },
  //         {
  //           title: 'Buttons',
  //           icon: <Icons.Dev />,
  //           action: 'DevButtons',
  //         },
  //         {
  //           title: 'Modals',
  //           icon: <Icons.Dev />,
  //           action: 'DevModals',
  //         },
  //         {
  //           title: 'Dropdowns',
  //           icon: <Icons.Dev />,
  //           action: 'DevDropdowns',
  //         },
  //       ],
  //     }
  //   : null,
].filter(Boolean);


--- FILE: src/screens/Cupboard/CupboardGroup.jsx ---

//* CupboardGroup.jsx
import React, {useState, useMemo, useCallback, useEffect} from 'react';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useCupboard} from '../../hooks/useHooks';
import {ListStyles} from '../../styles/Styles';
import {View} from 'react-native';
import SwipeableItem from '../../components/SwipeableItem';
import SelectedItemInfo from '../../components/SelectedItemInfo';
import {useCoreInfo} from '../../utilities/coreInfo';
import {useFocusEffect} from '@react-navigation/native';

const CupboardGroup = () => {
  const core = useCoreInfo();
  const cupboard = useCupboard();
  const [refreshFlag, setRefreshFlag] = useState(false);

  useFocusEffect(
    useCallback(() => {
      setRefreshFlag(prev => !prev);
    }, [cupboard?.items]),
  );
  const cupboardItems = cupboard?.items ?? [];

  const groupedList = useMemo(() => {
    const map = new Map();

    for (const item of cupboardItems) {
      const {
        itemName,
        brandName,
        category,
        description,
        measurement,
        packageSize,
        remainingAmount,
      } = item;

      const key = `${itemName}__${category || ''}__${measurement || ''}`;

      if (map.has(key)) {
        const group = map.get(key);
        group.count++;
        group.items.push(item);

        group.brandName = group.brandName === brandName ? brandName : undefined;
        group.description =
          group.description === description ? description : undefined;

        group.packageSize += Number(packageSize || 0);
        group.remainingAmount += Number(remainingAmount || 0);
      } else {
        map.set(key, {
          itemName,
          itemId: item.itemId,
          count: 1,
          brandName,
          category,
          description,
          measurement,
          packageSize: Number(packageSize || 0),
          remainingAmount: Number(remainingAmount || 0),
          items: [item],
        });
      }
    }

    return Array.from(map.values());
  }, [cupboardItems]);

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  useEffect(() => {
    if (showItemInfo === false) {
      setSelectedItem(null);
    }
  }, [showItemInfo]);

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        cupboardView
        groupedView
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
      />
    </BottomSheet>
  );

  return (
    <Layout
      headerTitle="Cupboards"
      LeftButton="Merge"
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}>
      {groupedList.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Cupboards are Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            key={refreshFlag}
            core={core}
            list={groupedList}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            leftButtons={[]}
            rightButton={[]}
            groupedView
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default CupboardGroup;


--- FILE: src/screens/Cupboard/CupboardItems.jsx ---

//* CupboardItems.jsx

import {
  useFocusEffect,
  useNavigation,
  useRoute,
} from '@react-navigation/native';
import React, {useCallback, useEffect, useState} from 'react';
import {Dropdown, Input, Layout} from '../../KQ-UI';
import {useCupboard} from '../../hooks/useHooks';
import {displayMeasurements} from '../../utilities/measurements';
import {displayCategories} from '../../utilities/categories';
import {displayDropField, setNumericValue} from '../../utilities/helpers';
import {View} from 'react-native';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';

const CupboardItems = () => {
  const route = useRoute();
  const {itemId} = route.params || {};

  const dispatch = useDispatch();
  const core = useCoreInfo();
  const navigation = useNavigation();
  const cupboard = useCupboard();

  const itemToUpdate =
    cupboard?.items?.find(item => item.itemId === itemId) ?? null;

  const [itemName, setItemName] = useState(itemToUpdate?.itemName ?? null);
  const [brandName, setBrandName] = useState(itemToUpdate?.brandName ?? '');
  const [description, setDescription] = useState(
    itemToUpdate?.description ?? '',
  );
  const [packageSize, setPackageSize] = useState(
    String(itemToUpdate?.packageSize ?? '1'),
  );
  const [quantity, setQuantity] = useState(
    String(itemToUpdate?.quantity ?? '1'),
  );
  const [remainingAmount, setRemainingAmount] = useState(
    String(itemToUpdate?.remainingAmount ?? '1'),
  );
  const [measurement, setMeasurement] = useState(
    displayDropField(itemToUpdate?.measurement, displayMeasurements) ?? null,
  );
  const [category, setCategory] = useState(
    displayDropField(itemToUpdate?.category, displayCategories) ?? null,
  );
  const [notes, setNotes] = useState(itemToUpdate?.notes ?? '');

  const [validation, setValidation] = useState(false);
  const [remainValidation, setRemainValidation] = useState(false);
  const [canSave, setCanSave] = useState(false);

  useEffect(() => {
    if (itemName === null) {
      setValidation(false);
      setCanSave(false);
    } else if (itemName === '') {
      setValidation(true);
      setCanSave(false);
    } else {
      setValidation(false);
      setCanSave(true);
    }
  }, [itemName]);

  useEffect(() => {
    if (!itemToUpdate?.remainingAmount) {
      setRemainingAmount(packageSize);
    }
  }, [packageSize, itemToUpdate?.remainingAmount]);

  const handleRemainingAmountChange = value => {
    const safeValue = value.replace(/[^0-9.]/g, '');

    const parts = safeValue.split('.');
    if (parts.length > 2) return;

    const numericValue = parseFloat(safeValue);

    if (numericValue > parseFloat(packageSize)) {
      setRemainValidation(true);
    } else {
      setRemainValidation(false);
    }

    setRemainingAmount(safeValue);
  };

  const handlePackageChange = value => {
    // Allow typing decimals freely
    const safeValue = value.replace(/[^0-9.]/g, '');

    // Prevent more than one "."
    const parts = safeValue.split('.');
    if (parts.length > 2) return;

    setPackageSize(safeValue);
    setRemainingAmount(safeValue); // default remaining = full package
  };

  const resetForm = () => {
    setItemName(null);
    setBrandName('');
    setDescription('');
    setPackageSize('1');
    setRemainingAmount('1');
    setMeasurement(null);
    setCategory(null);
    setNotes('');
    setQuantity('1');
  };

  const SaveItem = () => {
    const parsedQuantity = parseInt(quantity, 10);

    if (
      itemName === '' ||
      itemName === null ||
      (!itemToUpdate && (!parsedQuantity || parsedQuantity < 1))
    ) {
      setValidation(true);
      return;
    } else {
      setValidation(false);
    }

    const newItem = {
      itemName: itemName || '',
      brandName: brandName || '',
      description: description || '',
      packageSize: Number(packageSize) > 0 ? Number(packageSize) : 1,
      remainingAmount:
        parseFloat(remainingAmount) > 0 ? parseFloat(remainingAmount) : 1,
      measurement: measurement?.key?.trim() || 'each',
      category: category?.key?.trim() || 'other',
      notes: notes || '',
    };

    const updatedItem = {
      ...itemToUpdate,
      ...newItem,
    };

    if (itemToUpdate) {
      dispatch({
        type: 'UPDATE_ITEM_IN_CUPBOARD',
        payload: {
          cupboardID: core.cupboardID,
          updatedItem,
          profileID: core.profileID,
        },
      });
    } else {
      if (parsedQuantity === 1) {
        dispatch({
          type: 'ADD_ITEM_TO_CUPBOARD',
          payload: {
            cupboardID: core.cupboardID,
            newItem,
            profileID: core.profileID,
          },
        });
      } else {
        dispatch({
          type: 'BATCH_ADD_TO_CUPBOARD',
          payload: {
            cupboardID: core.cupboardID,
            newItem,
            quantity: parsedQuantity,
            profileID: core.profileID,
          },
        });
      }
    }

    resetForm();
  };

  const handleClose = () => {
    // dispatch({type: 'RESET_FOOD_DATA'}); // this is for edamam later
    resetForm();
    // setStoredData(null); // this is for edamam later
    navigation.goBack();
  };

  const displayRemaining = (packageSize, remainingAmount) => {
    let percent = (remainingAmount / packageSize) * 100;
    return `${percent.toFixed(0)}% left`;
  };

  useFocusEffect(useCallback(() => () => resetForm(), []));

  return (
    <Layout
      headerTitle="Cupboard Item"
      LeftButton="Close"
      RightButton={canSave ? 'Save' : null}
      LeftAction={handleClose}
      RightAction={canSave ? SaveItem : null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}
      mode="keyboard-scroll">
      <Input
        required
        label="Item Name"
        value={itemName}
        onChangeText={setItemName}
        validation={validation}
        validationMessage="Item Name is required"
        capitalize
        capitalMode="words"
      />
      <Input
        label="Brand Name"
        value={brandName}
        onChangeText={setBrandName}
        capitalize
        capitalMode="words"
      />
      <Input
        label="Description"
        value={description}
        onChangeText={setDescription}
        capitalize
        capitalMode="sentences"
      />
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1.25}}>
          <Input
            label="Qty"
            value={quantity}
            onChangeText={setNumericValue(setQuantity)}
            caption="# of Pkgs"
            // capitalMode="sentences"
          />
        </View>
        <View style={{flex: 1.75}}>
          <Input
            label="Package Size"
            value={packageSize}
            onChangeText={handlePackageChange}
            caption="Total in Pkg"
            capitalMode="sentences"
          />
        </View>
        <View style={{flex: 1.75}}>
          <Input
            label="Remaining"
            value={remainingAmount}
            onChangeText={handleRemainingAmountChange}
            caption={displayRemaining(packageSize, remainingAmount)}
            // capitalMode="sentences"
          />
        </View>
      </View>
      <Dropdown
        label="Measurement"
        customLabel="Custom Measurement"
        placeholder="Select a measurement"
        value={measurement}
        setValue={setMeasurement}
        caption={'Single is for individual items. Ex: Eggs'}
        mapData={displayMeasurements}
      />
      <Dropdown
        label="Category"
        customLabel="Custom Category"
        placeholder="Select a category"
        value={category}
        setValue={setCategory}
        mapData={displayCategories}
      />
      <Input
        label="Notes"
        value={notes}
        onChangeText={setNotes}
        multiline
        multiHeight="large"
        caption="Add notes here"
        counter
        maxCount={250}
      />
    </Layout>
  );
};

export default CupboardItems;


--- FILE: src/screens/Cupboard/CupboardSingle.jsx ---

//* CupboardSingle.jsx
import React, {useCallback, useEffect, useState} from 'react';
import {useFocusEffect, useNavigation} from '@react-navigation/native';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useCupboard} from '../../hooks/useHooks';
import {useDispatch} from 'react-redux';
import {ListStyles} from '../../styles/Styles';
import {View} from 'react-native';
import SwipeableItem from '../../components/SwipeableItem';
import {useCoreInfo} from '../../utilities/coreInfo';
import SelectedItemInfo from '../../components/SelectedItemInfo';

const CupboardSingle = () => {
  const core = useCoreInfo();
  const cupboard = useCupboard();
  const navigation = useNavigation();
  const dispatch = useDispatch();

  const [refreshFlag, setRefreshFlag] = useState(false);

  useFocusEffect(
    useCallback(() => {
      setRefreshFlag(prev => !prev);
    }, [cupboard?.items]),
  );

  const cupboardList = Array.isArray(cupboard?.items) ? cupboard?.items : [];

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  useEffect(() => {
    if (showItemInfo === false) {
      setSelectedItem(null);
    }
  }, [showItemInfo]);

  const handleUpdateItem = itemId => {
    navigation.navigate('CupboardItems', {
      title: 'Update Item',
      itemId,
      navigateBackTo: 'CupboardList-Single',
    });
  };

  const handleDeleteItem = useCallback(
    itemId => {
      if (core.profileID) {
        const item = cupboardList?.find(item => item?.itemId === itemId);
        if (item) {
          dispatch({
            type: 'DELETE_ITEM_FROM_CUPBOARD',
            payload: {
              cupboardID: core.cupboardID,
              itemId: item.itemId,
              itemName: item.itemName,
              profileID: core.profileID,
            },
          });
        }
      }
    },
    [dispatch, core, cupboardList],
  );

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        cupboardView
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
        navigate={{to: 'CupboardItems', backTo: 'CupboardList-Single'}}
      />
    </BottomSheet>
  );

  return (
    <Layout
      headerTitle="Cupboards"
      LeftButton={cupboardList.length === 0 ? null : 'Split'}
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}>
      {cupboardList.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Cupboards are Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            key={refreshFlag}
            core={core}
            list={cupboardList}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            noQuantity
            rightButtons={[
              {
                action: itemId => handleUpdateItem(itemId),
                text1: 'Update',
                text2: 'Item',
                style: ListStyles.updateButton,
              },
              {
                action: itemId => handleDeleteItem(itemId),
                text1: 'Delete',
                style: ListStyles.deleteButton,
              },
            ]}
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default CupboardSingle;


--- FILE: src/screens/Dev/DevButtons.jsx ---

//* DevButtons.jsx
import React from 'react';
import {Button, Layout} from '../../KQ-UI';
import {View} from 'react-native';

const DevButtons = () => {
  return (
    <Layout
      headerTitle="Dev Buttons"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{
        justifyContent: 'center',
        alignItems: 'center',
      }}>
      <Button
        type="filled" //useButtonType
        size="small" //useButtonSizes
        color="primary" //useColors or allow custom like "white" or "#fff"
        textSize="medium" //useFonts
        fontType="open-6" //useFonts
        textColor="white" //or useColors or allow custom like "white" or "#fff"
        disabled={false} //true or false, default is false and the prop is optional
        onPress={() => {
          // kqconsole.log('button pressed');
        }}>
        Press Me
      </Button>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Primary"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Primary"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Primary"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Success"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Success"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Success"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Info"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Info"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Info"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Warning"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Warning"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Warning"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Danger"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Danger"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Danger"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Dark"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Dark"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Dark"
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            disabled
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            disabled
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            disabled
            onPress={() => {
              // kqconsole.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
      </View>
    </Layout>
  );
};

export default DevButtons;


--- FILE: src/screens/Dev/DevDropdowns.jsx ---

//* DevDropdowns.jsx
import React, {useState} from 'react';
import {Dropdown, Input, Layout, Text} from '../../KQ-UI';
import {displayMeasurements} from '../../utilities/measurements';

const DevDropdowns = () => {
  const [value, setValue] = useState(null);
  const [value2, setValue2] = useState('');

  return (
    <Layout
      headerTitle="Dev Dropdowns"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}>
      <Input
        label="Item Name"
        placeholder="Enter Item Name"
        value={value2}
        onChangeText={setValue2}
        capitalize={false}
        capitalMode="words"
        caption="Enter Item"
      />
      <Dropdown
        label="Category"
        placeholder="Press to Select"
        value={value}
        setValue={setValue}
        caption="Select a Category"
        mapData={displayMeasurements}
      />
    </Layout>
  );
};

export default DevDropdowns;


--- FILE: src/screens/Dev/DevInputs.jsx ---

//* DevInputs.jsx
import React, {useState} from 'react';
import {Layout, Input} from '../../KQ-UI';
import {TouchableWithoutFeedback} from 'react-native';
import {Icons} from '../../components/IconListRouter';

const DevInputs = ({}) => {
  const [value, setValue] = useState('');
  const [value1, setValue1] = useState('');
  const [value2, setValue2] = useState('');
  const [value3, setValue3] = useState('');
  const [secureTextEntry, setSecureTextEntry] = useState(true);

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  const renderIcon = () => (
    <TouchableWithoutFeedback onPress={toggleSecureEntry}>
      {secureTextEntry ? <Icons.EyeOff /> : <Icons.EyeOn />}
    </TouchableWithoutFeedback>
  );

  return (
    <Layout
      headerTitle="Dev Inputs"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      mode="keyboard-scroll">
      <Input
        label="Email"
        placeholder="Email"
        value={value}
        onChangeText={setValue}
        capitalize={false}
        capitalMode="words"
        caption="Enter your email address"
        // keyboardType="default"
        // keyboardType="number-pad" // ios, has no decimal point
        // keyboardType="decimal-pad"
        // keyboardType="numeric" // ios, shows letters on number pad
        // keyboardType="email-address"
        // keyboardType="phone-pad" // same as numeric
        // keyboardType="url"
      />
      <Input
        label="Password"
        placeholder="Password"
        value={value1}
        onChangeText={setValue1}
        capitalize={false}
        accessoryRight={renderIcon}
        secureTextEntry={secureTextEntry}
        required
        caption="Password must be at least 8 characters long"
        counter
        maxCount={500}
      />
      <Input
        label="Multiple Lines"
        placeholder="Enter text here"
        value={value2}
        onChangeText={setValue2}
        multiline
        // multiHeight="medium"
        required
        caption="Enter a message"
        counter
        maxCount={150}
      />
      <Input
        label="Notes"
        placeholder="Type multiple lines..."
        value={value3}
        onChangeText={setValue3}
        multiline
        multiHeight="large"
        caption="Enter notes"
        counter
        maxCount={250}
      />
    </Layout>
  );
};

export default DevInputs;


--- FILE: src/screens/Dev/DevModals.jsx ---

//* DevModals.jsx
import React, {useState} from 'react';
import {View} from 'react-native';
import {Button, Layout, Modal, Text} from '../../KQ-UI';

const DevModals = () => {
  const [showModal, setShowModal] = useState(false);
  const [showModal2, setShowModal2] = useState(false);
  const [showModal3, setShowModal3] = useState(false);
  const [showModal4, setShowModal4] = useState(false);

  return (
    <Layout
      headerTitle="Dev Modals"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Modal
        visible={showModal}
        title="Full Screen"
        headerFont="open-6"
        headerSize="small"
        height="95%"
        width="95%"
        fullScreen
        // hideHeader
        // hideTitle
        // hideClose
        onClose={() => setShowModal(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>Full Screen w/ Header</Text>
          <Button onPress={() => setShowModal(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal2}
        title="Full Screen"
        headerFont="open-6"
        headerSize="small"
        height="95%"
        width="95%"
        fullScreen
        hideHeader
        // hideTitle
        // hideClose
        onClose={() => setShowModal2(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>Full Screen w/o Header</Text>
          <Button onPress={() => setShowModal2(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal3}
        title="Modal Title"
        headerFont="open-6"
        headerSize="small"
        height="95%"
        width="95%"
        // fullScreen
        // hideHeader
        hideTitle
        // hideClose
        onClose={() => setShowModal3(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>95% Screen w/o Title</Text>
          <Button onPress={() => setShowModal3(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal4}
        title="Modal Title"
        headerFont="open-6"
        headerSize="small"
        height="85%"
        width="85%"
        // fullScreen
        // hideHeader
        // hideTitle
        hideClose
        onClose={() => setShowModal4(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>85% Screen w/o Close Button</Text>
          <Button onPress={() => setShowModal4(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Button onPress={() => setShowModal(true)}>Show F/S w/ Header</Button>
      <Button onPress={() => setShowModal2(true)}>Show F/S w/o Header</Button>
      <Button onPress={() => setShowModal3(true)}>
        Show 95% Modal w/o Title
      </Button>
      <Button onPress={() => setShowModal4(true)}>
        Show 85% Modal w/o Close
      </Button>
    </Layout>
  );
};

export default __DEV__ ? DevModals : React.memo(DevModals);


--- FILE: src/screens/Dev/DevPlayground.jsx ---

//* DevPlayground.jsx
import React from 'react';
import {useIsFocused} from '@react-navigation/native';
import {Layout, ScrollView, Text} from '../../KQ-UI';
import {
  useAccount,
  useCupboard,
  useDeviceInfo,
  useFavorites,
  useProfile,
  useShoppingCart,
} from '../../hooks/useHooks';
import {View} from 'react-native';

const DevPlayground = () => {
  const isFocused = useIsFocused();
  const profile = useProfile();
  const account = useAccount();
  const shopping = useShoppingCart();
  const cupboard = useCupboard();
  const favorites = useFavorites();

  const device = useDeviceInfo();

  const renderValue = value => {
    if (Array.isArray(value)) {
      return value.map((item, idx) => {
        if (typeof item === 'object' && item !== null) {
          return (
            <View key={idx} style={{marginLeft: 8, marginBottom: 12}}>
              <Text font="open-6" size="xSmall" style={{marginBottom: 4}}>
                {idx}:
              </Text>
              {Object.entries(item)
                .sort(([a, b]) => a.localeCompare(b))
                .map(([k, v], subIdx) => (
                  <Text
                    key={subIdx}
                    font="open-5"
                    size="xSmall"
                    style={{marginLeft: 16}}>
                    • {k}:{' '}
                    {typeof v === 'object' ? JSON.stringify(v) : String(v)}
                  </Text>
                ))}
            </View>
          );
        }

        return (
          <Text
            key={idx}
            font="open-5"
            size="xSmall"
            style={{marginLeft: 16, marginBottom: 8}}>
            {idx}: {String(item)}
          </Text>
        );
      });
    }

    if (typeof value === 'object' && value !== null) {
      return Object.entries(value)
        .sort(([a, b]) => a.localeCompare(b))
        .map(([k, v], idx) => (
          <Text
            key={idx}
            font="open-5"
            size="xSmall"
            style={{marginLeft: 16, marginBottom: 4}}>
            • {k}: {typeof v === 'object' ? JSON.stringify(v) : String(v)}
          </Text>
        ));
    }

    return (
      <Text font="open-5" size="xSmall" style={{marginLeft: 16}}>
        {String(value)}
      </Text>
    );
  };

  return (
    <Layout
      headerTitle="Dev Playground"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}>
      <ScrollView>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Device Info</Text>
          {Object.entries(device)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Profile</Text>
          {Object.entries(profile)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Account</Text>
          {Object.entries(account)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Shopping</Text>
          {Object.entries(shopping)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Cupboard</Text>
          {Object.entries(cupboard)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Favorites</Text>
          {Object.entries(favorites)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        {/* <View style={{borderWidth: 1, padding: 5}}>
          <Text>Cupboard</Text>
          {Object.entries(cupboard)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View> */}
      </ScrollView>
    </Layout>
  );
};

export default DevPlayground;


--- FILE: src/screens/Dev/DevText.jsx ---

//* DevText.jsx
import React from 'react';
import {Platform, View} from 'react-native';
import {Layout, Text} from '../../KQ-UI';

const DevText = () => {
  const Row = ({children}) => (
    <View style={{flexDirection: 'row', width: '90%'}}>{children}</View>
  );

  const Cell = ({children}) => (
    <View
      style={{
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        borderWidth: 0.2,
        borderColor: '#00000090',
        margin: 5,
        height: 40,
      }}>
      {children}
    </View>
  );

  const TextBefore = ({font, text, weight, size, ...props}) => (
    <Text
      kqColor="black"
      style={{fontFamily: font, fontWeight: weight, fontSize: size || 20}}
      {...props}>
      {text}
    </Text>
  );

  const TextAfter = ({font, text, size, ...props}) => (
    <Text kqColor="black" font={font} style={{fontSize: size || 20}} {...props}>
      {text}
    </Text>
  );

  return (
    <Layout
      headerTitle="Dev Text"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Light" weight={300} text="Noto 300" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-3" text="Noto 300" style={{color: 'purple'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Medium" weight={500} text="Noto 500" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-5" text="Noto 500" kqColor="primary" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Bold" weight={700} text="Noto 700" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-7" text="Noto 700" kqColor="success" />
        </Cell>
      </Row>

      <Row>
        <Cell>
          <TextBefore font="Montserrat-Light" weight={200} text="Mont 300" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-3" text="Mont 300" style={{color: 'blue'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="Montserrat-Medium" weight={500} text="Mont 500" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-5" text="Mont 500" kqColor="info" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="Montserrat-Bold" weight={700} text="Mont 700" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-7" text="Mont 700" kqColor="warning" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Light" weight={300} text="Open 300" />
        </Cell>
        <Cell>
          <TextAfter font="open-3" text="Open 300" style={{color: 'aqua'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Medium" weight={500} text="Open 500" />
        </Cell>
        <Cell>
          <TextAfter font="open-5" text="Open 500" kqColor="danger" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Bold" weight={700} text="Open 700" />
        </Cell>
        <Cell>
          <TextAfter font="open-7" text="Open 700" kqColor="dark" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore
            font={Platform.OS === 'ios' ? 'CherryBlossom' : 'Cherry-Blossom'}
            weight={500}
            size={22}
            text="Cherry Blossom"
          />
        </Cell>
        <Cell>
          <TextAfter
            font="cherry"
            text="Cherry Blossom"
            size={22}
            kqColor="basic"
          />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore
            font="BananaChips-Regular"
            text="Banana Chips"
            size={40}
            weight={500}
          />
        </Cell>
        <Cell>
          <TextAfter
            font="banana"
            text="Banana Chips"
            size={40}
            style={{color: 'gold'}}
          />
        </Cell>
      </Row>
      <Text font="open-6" size="large">
        The quick brown lazy dog.
      </Text>
    </Layout>
  );
};

export default DevText;


--- FILE: src/screens/Favorites/FavoriteItems.jsx ---

//* FavoriteItems.jsx
import {
  useFocusEffect,
  useNavigation,
  useRoute,
} from '@react-navigation/native';
import React, {useCallback, useEffect, useState} from 'react';
import {Dropdown, Input, Layout} from '../../KQ-UI';
import {useFavorites} from '../../hooks/useHooks';
import {displayMeasurements} from '../../utilities/measurements';
import {displayCategories} from '../../utilities/categories';
import {displayDropField} from '../../utilities/helpers';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';

const FavoriteItems = () => {
  const route = useRoute();
  const {itemId} = route.params || {};

  const dispatch = useDispatch();
  const core = useCoreInfo();
  const navigation = useNavigation();
  const favorites = useFavorites();

  const itemToUpdate =
    favorites?.items?.find(item => item.itemId === itemId) ?? null;

  const [itemName, setItemName] = useState(itemToUpdate?.itemName ?? null);
  const [brandName, setBrandName] = useState(itemToUpdate?.brandName ?? '');
  const [description, setDescription] = useState(
    itemToUpdate?.description ?? '',
  );
  const [packageSize, setPackageSize] = useState(
    String(itemToUpdate?.packageSize ?? '1'),
  );
  const [measurement, setMeasurement] = useState(
    displayDropField(itemToUpdate?.measurement, displayMeasurements) ?? null,
  );
  const [category, setCategory] = useState(
    displayDropField(itemToUpdate?.category, displayCategories) ?? null,
  );
  const [notes, setNotes] = useState(itemToUpdate?.notes ?? '');

  const [validation, setValidation] = useState(false);

  const [canSave, setCanSave] = useState(false);

  useEffect(() => {
    if (itemName === null) {
      setValidation(false);
      setCanSave(false);
    } else if (itemName === '') {
      setValidation(true);
      setCanSave(false);
    } else {
      setValidation(false);
      setCanSave(true);
    }
  }, [itemName]);

  const handlePackageChange = value => {
    // Allow typing decimals freely
    const safeValue = value.replace(/[^0-9.]/g, '');

    // Prevent more than one "."
    const parts = safeValue.split('.');
    if (parts.length > 2) return;

    setPackageSize(safeValue);
  };

  const resetForm = () => {
    setItemName(null);
    setBrandName('');
    setDescription('');
    setPackageSize('1');
    setMeasurement(null);
    setCategory(null);
    setNotes('');
  };

  const SaveItem = () => {
    if (itemName === '' || itemName === null) {
      setValidation(true);
    } else {
      setValidation(false);

      const newItem = {
        itemName: itemName || '',
        brandName: brandName || '',
        description: description || '',
        packageSize: Number(packageSize) > 0 ? Number(packageSize) : 1,
        measurement: measurement?.key?.trim() || 'each',
        category: category?.key?.trim() || 'other',
        notes: notes || '',
      };

      const updatedItem = {
        ...itemToUpdate,
        ...newItem,
      };

      if (itemToUpdate) {
        dispatch({
          type: 'UPDATE_ITEM_IN_FAVORITES',
          payload: {
            favoriteItemsID: core.favoriteItemsID,
            updatedItem,
            profileID: core.profileID,
          },
        });
      } else {
        dispatch({
          type: 'ADD_ITEM_TO_FAVORITES',
          payload: {
            favoriteItemsID: core.favoriteItemsID,
            newItem: newItem,
            profileID: core.profileID,
          },
        });
      }

      resetForm();
    }
  };

  const handleClose = () => {
    resetForm();
    navigation.goBack();
  };

  useFocusEffect(useCallback(() => () => resetForm(), []));

  return (
    <Layout
      headerTitle="Favorite Item"
      LeftButton="Close"
      RightButton={canSave ? 'Save' : null}
      LeftAction={handleClose}
      RightAction={canSave ? SaveItem : null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}
      mode="keyboard-scroll">
      <Input
        required
        label="Item Name"
        value={itemName}
        onChangeText={setItemName}
        validation={validation}
        validationMessage="Item Name is required"
        capitalize
        capitalMode="words"
      />
      <Input
        label="Brand Name"
        value={brandName}
        onChangeText={setBrandName}
        capitalize
        capitalMode="words"
      />
      <Input
        label="Description"
        value={description}
        onChangeText={setDescription}
        capitalize
        capitalMode="sentences"
      />
      <Input
        label="Package Size"
        value={packageSize}
        onChangeText={handlePackageChange}
        caption="Total amount in a package"
        capitalMode="sentences"
      />
      <Dropdown
        label="Measurement"
        customLabel="Custom Measurement"
        placeholder="Select a measurement"
        value={measurement}
        setValue={setMeasurement}
        caption={'Single is for individual items. Ex: Eggs'}
        mapData={displayMeasurements}
      />
      <Dropdown
        label="Category"
        customLabel="Custom Category"
        placeholder="Select a category"
        value={category}
        setValue={setCategory}
        mapData={displayCategories}
      />
      <Input
        label="Notes"
        value={notes}
        onChangeText={setNotes}
        multiline
        multiHeight="large"
        caption="Add notes here"
        counter
        maxCount={250}
      />
    </Layout>
  );
};

export default FavoriteItems;


--- FILE: src/screens/Favorites/FavoritesList.jsx ---

//* FavoritesList.jsx
import React, {useCallback, useEffect, useState} from 'react';
import {useFocusEffect, useNavigation} from '@react-navigation/native';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useFavorites} from '../../hooks/useHooks';
import {View} from 'react-native';
import {ListStyles} from '../../styles/Styles';
import SwipeableItem from '../../components/SwipeableItem';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';
import SelectedItemInfo from '../../components/SelectedItemInfo';

const FavoritesList = () => {
  const favorites = useFavorites();
  const navigation = useNavigation();
  const core = useCoreInfo();
  const dispatch = useDispatch();

  const [refreshFlag, setRefreshFlag] = useState(false);

  useFocusEffect(
    useCallback(() => {
      setRefreshFlag(prev => !prev);
    }, [favorites?.items]),
  );

  const favoritesList = favorites?.items ?? [];

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  useEffect(() => {
    if (showItemInfo === false) {
      setSelectedItem(null);
    }
  }, [showItemInfo]);

  const handleUpdateItem = itemId => {
    navigation.navigate('FavoriteItems', {
      title: 'Update Item',
      itemId,
      navigateBackTo: 'FavoritesList',
      statusTo: 'shopping-list',
    });
  };

  const handleDeleteItem = useCallback(
    itemId => {
      if (core.profileID) {
        const item = favoritesList.find(item => item.itemId === itemId);
        if (item) {
          dispatch({
            type: 'DELETE_ITEM_FROM_FAVORITES',
            payload: {
              favoriteItemsID: core.favoriteItemsID,
              itemId: item.itemId,
              itemName: item.itemName,
              profileID: core.profileID,
            },
          });
        }
      }
    },
    [dispatch, core.profileID, favoritesList],
  );

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
        navigate={{
          to: 'FavoriteItems',
          backTo: 'FavoritesList',
        }}
        addToList
      />
    </BottomSheet>
  );

  return (
    <Layout
      headerTitle="Favorites"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}>
      {favoritesList.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Favorites List is Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            key={refreshFlag}
            list={favoritesList}
            core={core}
            showItemInfo={showItemInfo}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            favoritesView
            rightButtons={[
              {
                action: itemId => handleUpdateItem(itemId),
                text1: 'Update',
                text2: 'Item',
                style: ListStyles.updateButton,
              },
              {
                action: itemId => handleDeleteItem(itemId),
                text1: 'Delete',
                style: ListStyles.deleteButton,
              },
            ]}
            leftButtons={[]}
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default FavoritesList;


--- FILE: src/screens/Home/Home.jsx ---

//* Home.jsx
import React, {useMemo} from 'react';
import {useNavigation} from '@react-navigation/native';
import {Layout, Text} from '../../KQ-UI';
import {useCoreInfo} from '../../utilities/coreInfo';
import {Image, TouchableOpacity, View} from 'react-native';
import {useColors} from '../../KQ-UI/KQUtilities';
import {useDeviceInfo} from '../../hooks/useHooks';
import {Icons} from '../../components/IconListRouter';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';

const Home = () => {
  const core = useCoreInfo();
  const device = useDeviceInfo();
  const navigation = useNavigation();

  let screenWidth = device?.dimensions?.width;
  const imageCutRatio = 1000 / (screenWidth / 1.5);
  const imageWidth = 1000 / imageCutRatio;
  const imageHeight = 500 / imageCutRatio;

  // const greetingMsg = () => {
  //   if (core?.firstName) {
  //     return `Hello, ${core?.firstName}!`;
  //   } else {
  //     return `Hello new user!`;
  //   }
  // };

  // const displayDate = () => {
  //   let day = moment(new Date()).format('ddd');
  //   let date = moment(new Date()).format('MMM DD, YYYY');
  //   return `${day}, ${date}`;
  // };

  const DisplayCell = React.memo(props => {
    const {
      title,
      subTitle,
      icon,
      value1,
      value2,
      blank = false,
      blankStyle = {},
      iconStyles = {},
      height,
      infoCentered,
      onPress = () => {},
      children,
      disabled = false,
    } = props;
    const useHaptics = setHapticFeedback();
    const fixedHeight = height || 90;
    const {color, border} = useMemo(() => {
      const newValue1 = value1 || 0;
      const newValue2 = value2 || 0;
      const percent = newValue2 !== 0 ? (newValue1 / newValue2) * 100 : 0;
      let mode = 'basic';

      if (percent <= 50) {
        mode = 'success';
      } else if (percent <= 85) {
        mode = 'warning';
      } else if (percent <= 100) {
        mode = 'danger';
      }

      const modeStyles = {
        success: {
          color: 'success10',
          border: 'success30',
        },
        warning: {
          color: 'warning10',
          border: 'warning30',
        },
        danger: {color: 'danger10', border: 'danger30'},
        basic: {color: 'basic'},
        header: {color: 'white'},
      };

      const selected = modeStyles[mode] || modeStyles.basic;

      return {
        color: useColors(selected.color),
        border: useColors(selected.border),
      };
    }, [value1, value2]);

    const handleOnPress = () => {
      useHaptics(core?.userSettings?.hapticStrength || 'light');
      onPress();
    };

    return (
      <TouchableOpacity
        style={{
          flex: 1,
          borderWidth: 1.5,
          borderRadius: 15,
          height: fixedHeight,
          marginHorizontal: 5,
          backgroundColor: useColors('white'),
          borderColor: useColors('dark30'),
          shadowColor: useColors('dark'),
          shadowOffset: {width: 1, height: 2},
          shadowOpacity: 0.5,
          shadowRadius: 1.5,
          elevation: 8,
          overflow: 'hidden',
        }}
        disabled={disabled}
        onPress={() => handleOnPress()}>
        {blank ? (
          <View style={[{padding: 5}, blankStyle]}>{children}</View>
        ) : (
          <View style={{flexDirection: 'row'}}>
            <View
              style={{
                height: fixedHeight,
                justifyContent: 'center',
                backgroundColor: color,
                borderTopLeftRadius: 14,
                borderBottomLeftRadius: 14,
                borderRightWidth: 1,
                borderRightColor: border,
              }}>
              <View
                style={[
                  {
                    height: 35,
                    width: 35,
                    margin: 5,
                    justifyContent: 'center',
                    alignItems: 'center',
                  },
                  iconStyles,
                ]}>
                {icon}
              </View>
            </View>
            <View
              style={{
                height: fixedHeight,
                flex: 1,
                justifyContent: infoCentered ? 'center' : 'flex-start',
                alignItems: infoCentered ? 'center' : 'flex-start',
              }}>
              <View
                style={{
                  flex: 1,
                  marginBottom: 5,
                  justifyContent: infoCentered ? 'space-evenly' : 'flex-start',
                  alignItems: infoCentered ? 'center' : 'flex-start',
                }}>
                <View
                  style={{alignItems: infoCentered ? 'center' : 'flex-start'}}>
                  <Text size="small" font="mont-7">
                    {title}
                  </Text>
                  <Text size="tiny" font="mont-6">
                    {subTitle}
                  </Text>
                </View>
                <Text size="small" font="mont-7">
                  {value1} of {value2}
                </Text>
              </View>
            </View>
          </View>
        )}
      </TouchableOpacity>
    );
  });

  const DisplayRow = ({children}) => {
    return (
      <View
        style={{
          flexDirection: 'row',
          marginHorizontal: 5,
          marginVertical: 5,
        }}>
        {children}
      </View>
    );
  };

  return (
    <Layout
      headerTitle="Home"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}
      innerViewStyles={{}}>
      <View
        style={{
          alignItems: 'center',
          marginTop: 10,
          marginBottom: 5,
        }}>
        <View>
          <Image
            source={require('../../images/AppLogo_1000.png')}
            style={{width: imageWidth, height: imageHeight}}
          />
        </View>
      </View>
      <DisplayRow>
        <DisplayCell
          infoCentered
          title="Shopping"
          subTitle="(Cart / List)"
          value1={core?.shoppingAllItemsLength}
          value2={core?.maxShoppingItems}
          icon={<Icons.Shopping size={25} />}
          onPress={() => navigation.navigate('ShoppingList')}
        />
        <DisplayCell
          infoCentered
          title="Cupboards"
          subTitle="(Items)"
          value1={core?.cupboardLength}
          value2={core?.maxCupboardItems}
          icon={<Icons.Cupboards size={25} />}
          onPress={() => navigation.navigate('CupboardList-Single')}
        />
      </DisplayRow>
      <DisplayRow>
        <DisplayCell
          infoCentered
          title="Favorites"
          subTitle="(Items)"
          value1={core?.favoritesLength}
          value2={core?.maxFavoriteItems}
          // iconStyles={{marginTop: -1}}
          icon={<Icons.Star size={25} />}
          onPress={() => navigation.navigate('FavoritesList')}
        />
        <DisplayCell
          infoCentered
          title="Recipe Box"
          subTitle="(Recipes)"
          value1={core?.recipeBoxLength}
          value2={core?.maxRecipeBoxItems}
          // iconStyles={{marginTop: -4}}
          icon={<Icons.Chest size={25} />}
          onPress={() => navigation.navigate('RecipeBox')}
        />
      </DisplayRow>
      <DisplayRow>
        <DisplayCell
          infoCentered
          title="Item Scanner"
          subTitle="(Daily Limit)"
          value1={core?.dailyUPCCounter}
          value2={core?.maxUPCSearchLimit}
          icon={<Icons.Barcode size={20} />}
          // onPress={() => navigation.navigate('FavoritesList')}
          disabled
        />
        <DisplayCell
          infoCentered
          title="Find Recipes"
          subTitle="(Daily Limit)"
          value1={core?.dailyRecipeCounter}
          value2={core?.maxRecipeSearchLimit}
          icon={<Icons.Search size={25} />}
          onPress={() => navigation.navigate('RecipeSearch')}
        />
      </DisplayRow>
    </Layout>
  );
};

export default Home;


--- FILE: src/screens/Legal/About.jsx ---

//* About.jsx
import React from 'react';
import {View} from 'react-native';
import {LegalStyles} from '../../styles/Styles';
import {LegalArray} from './LegalArray';
import {Text, Button, ScrollView} from '../../KQ-UI';

export default function About({handleTOSConfirm, handleCancel, hideConfirm}) {
  let terms = LegalArray.About[0];

  const RenderTermData = ({terms}) => {
    return terms.sections.map(section => (
      <View key={section.index} style={LegalStyles.sectionWrapper}>
        <View style={LegalStyles.sectionHeader}>
          <View style={LegalStyles.sectionIndex}>
            <Text size="small">{section.index}.</Text>
          </View>
          <View style={LegalStyles.sectionTitle}>
            <Text size="small">{section.title}:</Text>
          </View>
        </View>
        {section.clauses.map(clause => (
          <View key={clause.index} style={LegalStyles.clauseWrapper}>
            <View style={LegalStyles.clauseHeader}>
              <View style={LegalStyles.clauseIndexSpacing}></View>
              <View style={LegalStyles.clauseTextWrapper}>
                <Text size="small">{clause.info}</Text>
              </View>
            </View>
            {clause.subClause?.length > 0 && (
              <View style={LegalStyles.subClauseWrapper}>
                {clause.subClause.map(sub => (
                  <View key={sub.index} style={LegalStyles.subClauseHeader}>
                    <View style={LegalStyles.bulletWrapper}>
                      <Text size="small">{'\u2022'}</Text>
                    </View>
                    <View style={LegalStyles.subClauseTextWrapper}>
                      <Text size="small">{sub.info}</Text>
                    </View>
                  </View>
                ))}
              </View>
            )}
          </View>
        ))}
      </View>
    ));
  };

  return (
    <View style={LegalStyles.container}>
      <View
        style={[
          LegalStyles.body,
          hideConfirm ? {paddingBottom: 20} : {paddingBottom: 10},
        ]}>
        <ScrollView>
          <RenderTermData terms={terms} />
        </ScrollView>
      </View>
      {!hideConfirm && (
        <View style={LegalStyles.buttonWrapper}>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="danger"
              size="small"
              onPress={() => handleCancel('Terms of Service')}>
              Cancel
            </Button>
          </View>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="success"
              size="small"
              onPress={() => handleTOSConfirm()}>
              Confirm
            </Button>
          </View>
        </View>
      )}
    </View>
  );
}


--- FILE: src/screens/Legal/LegalArray.js ---

//*LegalArray.js
export const LegalArray = {
  PP: [
    {
      dates: {effective: 'July 1, 2025', written: 'March 23, 2025'},
      version: {previous: '1.0.0', current: '1.0.0'},
      sections: [
        {
          index: 1,
          title: 'Information We Collect',
          clauses: [
            {
              index: 1,
              info: 'We collect and process the following types of information:',
              subClause: [
                {
                  index: 1,
                  info: 'Personal Data: Includes names, email addresses, and profile information provided by users during account creation.',
                },
                {
                  index: 2,
                  info: 'Household Data: Information about items entered by users into the app, such as shopping lists, cupboard inventories, and categories.',
                },
                {
                  index: 3,
                  info: 'Device Information: Information about the device used to access the app, such as device type and operating system, used solely to improve app functionality.',
                },
                {
                  index: 4,
                  info: 'Usage Data: Activity logs related to shopping, cupboard, and event features to enhance user experience.',
                },
                {
                  index: 5,
                  info: 'Third-Party Data: Retrieved via trusted APIs (e.g., barcode lookups and recipe suggestions) and processed according to those services’ policies.',
                },
              ],
            },
          ],
        },
        {
          index: 2,
          title: 'How We Use Your Data',
          clauses: [
            {
              index: 1,
              info: 'Data is used to:',
              subClause: [
                {index: 1, info: 'Facilitate and improve core app features.'},
                {
                  index: 2,
                  info: 'Ensure a seamless experience across devices.',
                },
                {index: 3, info: 'Analyze and improve app performance.'},
                {
                  index: 4,
                  info: 'Support barcode lookup and recipe suggestions from third-party APIs.',
                },
              ],
            },
          ],
        },
        {
          index: 3,
          title: 'Data Sharing',
          clauses: [
            {
              index: 1,
              info: 'We do not sell or rent user data. Data is shared only with trusted third-party services strictly for feature functionality.',
              subClause: [
                {
                  index: 1,
                  info: 'Data may be passed to trusted APIs for features like UPC scanning or recipe search.',
                },
              ],
            },
          ],
        },
        {
          index: 4,
          title: 'Data Security',
          clauses: [
            {
              index: 1,
              info: 'We use secure, encrypted systems to store and manage user data. While best efforts are made, no system is entirely immune to risks.',
            },
          ],
        },
        {
          index: 5,
          title: 'User Rights',
          clauses: [
            {
              index: 1,
              info: 'Users have the right to:',
              subClause: [
                {index: 1, info: 'Access their personal data.'},
                {index: 2, info: 'Request corrections to their data.'},
                {
                  index: 3,
                  info: 'Request deletion of their account and associated data.',
                },
              ],
            },
          ],
        },
        {
          index: 6,
          title: "Children's Privacy",
          clauses: [
            {
              index: 1,
              info: 'This app is not intended for children under 13. Use by minors is the responsibility of the account holder.',
            },
          ],
        },
        {
          index: 7,
          title: 'Third-Party Services',
          clauses: [
            {
              index: 1,
              info: 'The app integrates trusted third-party services such as Edamam for features like barcode lookups and recipe suggestions. These services may collect data in accordance with their own privacy policies.',
            },
          ],
        },
        {
          index: 8,
          title: 'Changes to the Privacy Policy',
          clauses: [
            {
              index: 1,
              info: 'This policy may be updated periodically to reflect feature changes or legal requirements. Continued use of the app implies acceptance.',
            },
          ],
        },
      ],
    },
  ],
  TOS: [
    {
      dates: {effective: 'July 1, 2025', written: 'March 23, 2025'},
      version: {previous: '1.0.0', current: '1.0.0'},
      sections: [
        {
          index: 1,
          title: 'Acceptance of Terms',
          clauses: [
            {
              index: 1,
              info: 'By using Kitchen Queue, you agree to these terms. If you do not agree, discontinue use of the app.',
            },
          ],
        },
        {
          index: 2,
          title: 'Purpose of Kitchen Queue',
          clauses: [
            {
              index: 1,
              info: 'Kitchen Queue is designed to help users manage kitchen inventory, shopping lists, and meal planning.',
            },
          ],
        },
        {
          index: 3,
          title: 'User Responsibilities',
          clauses: [
            {
              index: 1,
              info: 'Users must use the app for its intended household planning and food management purposes only.',
            },
            {
              index: 2,
              info: 'Prohibited use includes illegal content, including drug-related items or activity.',
            },
            {
              index: 3,
              info: 'Users are responsible for ensuring their data is accurate and purposeful.',
            },
            {
              index: 4,
              info: 'Kitchen Queue is not responsible for any inaccuracies or misuse of user-entered data.',
            },
          ],
        },
        {
          index: 4,
          title: 'Age Restrictions',
          clauses: [
            {
              index: 1,
              info: 'The app is not intended for users under 13 years old.',
            },
            {
              index: 2,
              info: 'Account holders are responsible for the data entered by any minor users they authorize.',
            },
            {
              index: 3,
              info: 'Unauthorized accounts for children under 13 will be deleted.',
            },
          ],
        },
        {
          index: 5,
          title: 'Data Usage and Limitations',
          clauses: [
            {
              index: 1,
              info: 'Users are fully responsible for managing and verifying their own data within the app.',
            },
          ],
        },
        {
          index: 6,
          title: 'Third-Party Services',
          clauses: [
            {
              index: 1,
              info: 'The app uses services such as Edamam for recipe suggestions and barcode lookups. Users must comply with the terms of these third-party providers.',
            },
          ],
        },
        {
          index: 7,
          title: 'Changes to Terms',
          clauses: [
            {
              index: 1,
              info: 'Terms may be updated from time to time. Continued use of the app confirms your acceptance of any updates.',
            },
          ],
        },
        {
          index: 8,
          title: 'Limitation of Liability',
          clauses: [
            {
              index: 1,
              info: 'Kitchen Queue is not liable for misuse, data errors, or third-party service issues. The app is provided as-is.',
            },
          ],
        },
        {
          index: 9,
          title: 'Governing Law',
          clauses: [
            {
              index: 1,
              info: 'These terms are governed by the laws of the State of North Dakota, USA.',
            },
          ],
        },
        {
          index: 10,
          title: 'Subscriptions and Payments',
          clauses: [
            {
              index: 1,
              info: 'All subscriptions and in-app purchases are handled exclusively through Apple and Google’s platforms. Kitchen Queue does not process or store any payment data.',
            },
          ],
        },
      ],
    },
  ],

  About: [
    {
      sections: [
        {
          index: 1,
          title: 'Welcome to Kitchen Queue',
          clauses: [
            {
              index: 1,
              info: 'Kitchen Queue helps you organize your kitchen, track groceries, and plan meals together as a household.',
              subClause: [
                {
                  index: 1,
                  info: 'Add items to your shopping list and move them to your cart when you`re ready.',
                },
                {
                  index: 2,
                  info: 'After shopping, transfer items to your cupboard to keep track of what you already have.',
                },
                {
                  index: 3,
                  info: 'Supports real-time updates for up to 4 users per household, keeping everyone in sync.',
                },
                {
                  index: 4,
                  info: 'Clean design, smooth interaction, and easy-to-use features that make managing your kitchen simple and fun.',
                },
              ],
            },
          ],
        },
        {
          index: 2,
          title: 'What You Can Do Today',
          clauses: [
            {
              index: 1,
              info: 'Shared Shopping List and Cart',
              subClause: [
                {
                  index: 1,
                  info: 'Add, edit, or remove items across your household in real-time.',
                },
                {
                  index: 2,
                  info: 'Use the Cart for in-store shopping and check items off as you go.',
                },
                {
                  index: 3,
                  info: 'One-tap checkout moves everything to your cupboard automatically.',
                },
              ],
            },
            {
              index: 2,
              info: 'Cupboard Inventory',
              subClause: [
                {
                  index: 1,
                  info: 'Keep track of what’s already in your pantry, fridge, or freezer.',
                },
                {
                  index: 2,
                  info: 'Monitor how much is left of each item so nothing goes to waste.',
                },
              ],
            },
            {
              index: 3,
              info: 'Profiles and Shared Accounts',
              subClause: [
                {
                  index: 1,
                  info: 'Invite up to 4 users to join your household account.',
                },
                {
                  index: 2,
                  info: 'Each person can customize their own profile and avatar.',
                },
              ],
            },
          ],
        },
        {
          index: 3,
          title: 'What’s Coming Next',
          clauses: [
            {
              index: 1,
              info: 'Recipe Box',
              subClause: [
                {index: 1, info: 'Save and organize your favorite recipes.'},
                {
                  index: 2,
                  info: 'Automatically check your cupboard for ingredients you already have.',
                },
                {
                  index: 3,
                  info: 'Add missing ingredients to your shopping list with one tap.',
                },
              ],
            },
            {
              index: 2,
              info: 'Favorites List',
              subClause: [
                {
                  index: 1,
                  info: 'Quickly add frequent items to your shopping list without re-entering them.',
                },
              ],
            },
            {
              index: 3,
              info: 'Dark Mode Theme',
              subClause: [
                {
                  index: 1,
                  info: 'Switch between light, dark, or auto theme depending on your device settings.',
                },
              ],
            },
            {
              index: 4,
              info: 'Barcode Scanning',
              subClause: [
                {
                  index: 1,
                  info: 'Scan UPC codes to instantly add items to your cart or cupboard.',
                },
              ],
            },
            {
              index: 5,
              info: 'Recipe Search',
              subClause: [
                {
                  index: 1,
                  info: 'Find new recipes online and save them to your box.',
                },
              ],
            },

            {
              index: 6,
              info: 'Meal Planning',
              subClause: [
                {
                  index: 1,
                  info: 'Plan meals for the week and automatically add ingredients to your shopping list.',
                },
              ],
            },
            {
              index: 7,
              info: 'Community Recipes',
              subClause: [
                {
                  index: 1,
                  info: 'Browse and favorite meals shared by other users.',
                },
              ],
            },
            {
              index: 8,
              info: 'Event Planning',
              subClause: [
                {
                  index: 1,
                  info: 'Create events like dinners or holidays and build lists for them.',
                },
                {
                  index: 2,
                  info: 'Let guests sign up for food contributions, even if they don’t have an account.',
                },
              ],
            },
            {
              index: 9,
              info: 'Nutrition Insights',
              subClause: [
                {
                  index: 1,
                  info: 'View nutritional info for recipes and ingredients (optional future feature).',
                },
              ],
            },
          ],
        },
      ],
    },
  ],
};


--- FILE: src/screens/Legal/PrivacyPolicy.jsx ---

//* PrivacyPolicy.jsx
import React from 'react';
import {View} from 'react-native';
import {LegalStyles} from '../../styles/Styles';
import {LegalArray} from './LegalArray';
import {Text, Button, ScrollView} from '../../KQ-UI';

export default function PrivacyPolicy({
  handlePPConfirm,
  handleCancel,
  hideConfirm,
}) {
  let terms = LegalArray.PP[0];

  const RenderTermData = ({terms}) => {
    return terms.sections.map(section => (
      <View key={section.index} style={LegalStyles.sectionWrapper}>
        <View style={LegalStyles.sectionHeader}>
          <View style={LegalStyles.sectionIndex}>
            <Text size="small">{section.index}.</Text>
          </View>
          <View style={LegalStyles.sectionTitle}>
            <Text size="small">{section.title}:</Text>
          </View>
        </View>
        {section.clauses.map(clause => (
          <View key={clause.index} style={LegalStyles.clauseWrapper}>
            <View style={LegalStyles.clauseHeader}>
              <View style={LegalStyles.clauseIndexSpacing}></View>
              <View style={LegalStyles.clauseTextWrapper}>
                <Text size="small" style={LegalStyles.clauseInfo}>
                  {clause.info}
                </Text>
              </View>
            </View>
            {clause.subClause?.length > 0 && (
              <View style={LegalStyles.subClauseWrapper}>
                {clause.subClause.map(sub => (
                  <View key={sub.index} style={LegalStyles.subClauseHeader}>
                    <View style={LegalStyles.bulletWrapper}>
                      <Text size="small">{'\u2022'}</Text>
                    </View>
                    <View style={LegalStyles.subClauseTextWrapper}>
                      <Text size="small" style={LegalStyles.clauseInfo}>
                        {sub.info}
                      </Text>
                    </View>
                  </View>
                ))}
              </View>
            )}
          </View>
        ))}
      </View>
    ));
  };
  return (
    <View style={LegalStyles.container}>
      <View
        style={[
          LegalStyles.body,
          hideConfirm ? {paddingBottom: 20} : {paddingBottom: 10},
        ]}>
        <ScrollView>
          <RenderTermData terms={terms} />
        </ScrollView>
      </View>
      {!hideConfirm && (
        <View style={LegalStyles.buttonWrapper}>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="danger"
              size="small"
              onPress={() => handleCancel('Privacy Policy')}>
              Cancel
            </Button>
          </View>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="success"
              size="small"
              onPress={() => handlePPConfirm()}>
              Confirm
            </Button>
          </View>
        </View>
      )}
    </View>
  );
}


--- FILE: src/screens/Legal/TermsService.jsx ---

//* TermsService.jsx
import React from 'react';
import {View} from 'react-native';
import {LegalStyles} from '../../styles/Styles';
import {LegalArray} from './LegalArray';
import {Text, Button, ScrollView} from '../../KQ-UI';

export default function TermsService({
  handleTOSConfirm,
  handleCancel,
  hideConfirm,
}) {
  let terms = LegalArray.TOS[0];

  const RenderTermData = ({terms}) => {
    return terms.sections.map(section => (
      <View key={section.index} style={LegalStyles.sectionWrapper}>
        <View style={LegalStyles.sectionHeader}>
          <View style={LegalStyles.sectionIndex}>
            <Text size="small">{section.index}.</Text>
          </View>
          <View style={LegalStyles.sectionTitle}>
            <Text size="small">{section.title}:</Text>
          </View>
        </View>
        {section.clauses.map(clause => (
          <View key={clause.index} style={LegalStyles.clauseWrapper}>
            <View style={LegalStyles.clauseHeader}>
              <View style={LegalStyles.clauseIndexSpacing}></View>
              <View style={LegalStyles.clauseTextWrapper}>
                <Text size="small">{clause.info}</Text>
              </View>
            </View>
            {clause.subClause?.length > 0 && (
              <View style={LegalStyles.subClauseWrapper}>
                {clause.subClause.map(sub => (
                  <View key={sub.index} style={LegalStyles.subClauseHeader}>
                    <View style={LegalStyles.bulletWrapper}>
                      <Text size="small">{'\u2022'}</Text>
                    </View>
                    <View style={LegalStyles.subClauseTextWrapper}>
                      <Text size="small">{sub.info}</Text>
                    </View>
                  </View>
                ))}
              </View>
            )}
          </View>
        ))}
      </View>
    ));
  };

  return (
    <View style={LegalStyles.container}>
      <View
        style={[
          LegalStyles.body,
          hideConfirm ? {paddingBottom: 20} : {paddingBottom: 10},
        ]}>
        <ScrollView>
          <RenderTermData terms={terms} />
        </ScrollView>
      </View>
      {!hideConfirm && (
        <View style={LegalStyles.buttonWrapper}>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="danger"
              size="small"
              onPress={() => handleCancel('Terms of Service')}>
              Cancel
            </Button>
          </View>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="success"
              size="small"
              onPress={() => handleTOSConfirm()}>
              Confirm
            </Button>
          </View>
        </View>
      )}
    </View>
  );
}


--- FILE: src/screens/Recipe/AddRecipe.jsx ---

//* AddRecipe.jsx

import React, {useEffect, useMemo, useState} from 'react';
import {BottomSheet, Button, Input, Layout, Text, View} from '../../KQ-UI';
import {useCoreInfo} from '../../utilities/coreInfo';
import {displaySourceType} from '../../utilities/materialSource';
import {displayDropField, displayDropArray} from '../../utilities/helpers';
import {displayCuisineTypes} from '../../utilities/cuisineType';
import {displayDishTypes} from '../../utilities/dishType';
import {displayDietTypes} from '../../utilities/dietType';
import {displayMeasurements} from '../../utilities/measurements';
import {normalizeTitleForKeywords} from '../../utilities/normalizeTitle';
import UploadPicture from './UploadPicture';
import IngredientForm from './Forms/IngredientForm';
import InstructionForm from './Forms/InstructionForm';
import RecipeForm from './Forms/RecipeForm';
import {useDispatch} from 'react-redux';

const AddRecipe = () => {
  const core = useCoreInfo();
  const dispatch = useDispatch();

  const [validation1, setValidation1] = useState(false);
  const [validation2, setValidation2] = useState(false);
  const [validation3, setValidation3] = useState(false);
  const [validation4, setValidation4] = useState(false);
  const [canSave, setCanSave] = useState(false);

  const [recipeName, setRecipeName] = useState(null);
  const [sourceMaterial, setSourceMaterial] = useState(
    displayDropField(displaySourceType) ?? null,
  );
  const [source, setSource] = useState(null);
  const [sourceURL, setSourceURL] = useState(null);
  const [cuisineType, setCuisineType] = useState(
    displayDropArray(displayCuisineTypes) ?? null,
  );
  const [dishType, setDishType] = useState(
    displayDropArray(displayDishTypes) ?? null,
  );
  const [dietType, setDietType] = useState(
    displayDropArray(displayDietTypes) ?? null,
  );
  const [servings, setServings] = useState(null);
  const [prepTime, setPrepTime] = useState(null);
  const [cookTime, setCookTime] = useState(null);
  const [ingredients, setIngredients] = useState([]);
  const [instructions, setInstructions] = useState([]);
  const [aboutRecipe, setAboutRecipe] = useState(null);

  const [finalImage, setFinalImage] = useState(null);

  const [showInstructions, setShowInstructions] = useState(false);
  const [showIngredients, setShowIngredients] = useState(false);

  const [canPressIngredients, setCanPressIngredients] = useState(true);
  const [canPressInstructions, setCanPressInstructions] = useState(true);

  const [showUploadPicture, setShowUploadPicture] = useState(false);
  const [showAboutRecipe, setShowAboutRecipe] = useState(false);

  const [canPressUploadPicture, setCanPressUploadPicture] = useState(true);
  const [canPressAboutRecipe, setCanPressAboutRecipe] = useState(true);

  const [tempIngAmount, setTempIngAmount] = useState(null);
  const [tempIngMeasurement, setTempIngMeasurement] = useState(
    displayDropField(displayMeasurements) ?? null,
  );
  const [tempIngName, setTempIngName] = useState(null);
  const [tempNote, setTempNote] = useState(null);

  const [sourceType, setSourceType] = useState(null);

  const [keywords, setKeywords] = useState(null);
  const [pictureName, setPictureName] = useState(null);

  useEffect(() => {
    if (!sourceMaterial) {
      setSource(null);
      setSourceType(null);
      return;
    }

    const key = sourceMaterial?.key;

    switch (true) {
      case key === 'personal':
        setSource('personal');
        setSourceType('personal');
        break;

      case ['friend', 'family'].includes(key):
        setSource(null);
        setSourceType('private');
        break;

      case ['social', 'website', 'app'].includes(key):
        setSource(null);
        setSourceType('online');
        break;

      case [
        'cookbook',
        'restaurant',
        'tv',
        'magazine',
        'package',
        'event',
      ].includes(key):
        setSource(null);
        setSourceType('published');
        break;

      default:
        setSourceType(null);
        break;
    }
  }, [sourceMaterial]);

  useMemo(() => {
    const normalized = normalizeTitleForKeywords(recipeName);
    setKeywords(normalized);

    const slug = normalized.slice(1).join('-');
    const prefix = core?.profileID || core?.userID;

    setPictureName(`${prefix}-${slug}`);
  }, [recipeName]);

  const recipeObject = {
    title: recipeName?.toLowerCase().trim() ?? null,
    sourceMaterial: sourceMaterial?.key ?? null,
    source: source?.toLowerCase().trim() ?? null,
    sourceURL: sourceURL?.trim().toLowerCase().replace(/\s+/g, '') ?? null,
    credit: core?.onlineName,
    authorOnlineName: core?.onlineName,
    authorFirstName: core?.firstName,
    authorLastName: core?.lastName,
    authorID: core?.userID,
    accountID: core?.accountID,
    adminEdit: true,
    userEdit: true,
    cuisines: cuisineType?.map(c => c.value),
    dishTypes: dishType?.map(c => c.value),
    diets: dietType?.map(c => c.value),
    displayAuthorName: false, // later addition - for shared recipes
    publicAuthor: false, // later addition - for shared recipes
    recipeShared: false, // later addition - for shared recipes
    sharedStatus: 'approved', // later addition - for shared recipes // for admin approvals
    servings: servings ? Number(servings) : null,
    prepTime: prepTime ? Number(prepTime) : null,
    cookTime: cookTime ? Number(cookTime) : null,
    readyIn: prepTime && cookTime ? Number(prepTime) + Number(cookTime) : null,
    ingredients: ingredients,
    instructions: instructions,
    image: finalImage?.name ?? null,
    imageUri: finalImage
      ? `https://firebasestorage.googleapis.com/v0/b/kitchen-queue-fe2fe.firebasestorage.app/o/recipes%2F${finalImage?.name}?alt=media`
      : null,
    imageDate: finalImage?.imageDate ?? null,
    pictureApproved: true,
    ingredientList:
      ingredients?.map(ing => ing.name?.toLowerCase().trim() ?? null) ?? null,
    isArchived: false,
    keywords: keywords ?? null,
    aboutRecipe: aboutRecipe?.trim() ?? null,
    seasonal: null, // later addition
    occasions: null, // later addition
    healthScore: null, // later addition
    ratingScore: null, // later addition
  };

  const isValidText = value =>
    typeof value === 'string' && value.trim().length >= 2;

  useEffect(() => {
    const nameValid = isValidText(recipeName);
    const materialValid = sourceMaterial !== null;

    const sourceRequired = sourceType !== 'personal';
    const sourceValid = !sourceRequired || isValidText(source);

    const urlRequired = sourceType === 'online';
    const urlValid = !urlRequired || isValidText(sourceURL);

    const ingredientValid = ingredients?.length > 0;
    const instructionValid = instructions?.length > 0;

    // For debugging purposes
    // if (recipeName === null) console.log('Recipe Name is null');
    // if (!isValidText(recipeName)) console.log('Recipe Name is invalid');
    // if (!materialValid) console.log('Source Material is null');
    // if (!sourceValid) console.log('Source is invalid');
    // if (!urlValid) console.log('Source URL is invalid');
    // if (!ingredientValid) console.log('Ingredients are empty');
    // if (!instructionValid) console.log('Instructions are empty');

    // Show red error on name only
    setValidation1(
      recipeName === '' ||
        (typeof recipeName === 'string' && recipeName.trim() === ''),
    );

    // Disable save unless all are valid
    const allValid =
      nameValid &&
      materialValid &&
      sourceValid &&
      urlValid &&
      ingredientValid &&
      instructionValid;
    setCanSave(allValid);
  }, [
    recipeName,
    sourceMaterial,
    source,
    sourceURL,
    sourceType,
    ingredients,
    instructions,
  ]);

  const displaySourceExample = useMemo(() => {
    if (sourceMaterial?.key === 'friend') return 'Ex: Jane Doe';
    if (sourceMaterial?.key === 'family') return 'Ex: Grandma Jane';
    if (sourceMaterial?.key === 'social') return 'Ex: Facebook';
    if (sourceMaterial?.key === 'website') return 'Ex: Pinch of Yum';
    if (sourceMaterial?.key === 'app') return 'Ex: ChatGPT';
    if (sourceMaterial?.key === 'cookbook') return 'Ex: Better Homes Cook Book';
    if (sourceMaterial?.key === 'restaurant') return 'Ex: Olive Garden';
    if (sourceMaterial?.key === 'tv') return 'Ex: Iron Chef';
    if (sourceMaterial?.key === 'magazine') return 'Ex: Food Network Magazine';
    if (sourceMaterial?.key === 'package') return 'Ex: Nestle Toll House';
    if (sourceMaterial?.key === 'event') return 'Ex: Square One';
    return null;
  }, [sourceMaterial]);

  const handleCloseIngredients = () => {
    setCanPressIngredients(false);
    setShowIngredients(false);
    setTempIngAmount(null);
    setTempIngMeasurement(null);
    setTempIngName(null);
    setTimeout(() => {
      setCanPressIngredients(true);
    }, 2000);
  };

  const handleCloseInstructions = () => {
    setCanPressInstructions(false);
    setShowInstructions(false);
    setTimeout(() => {
      setCanPressInstructions(true);
    }, 2000);
  };

  const handleCloseUploadPicture = () => {
    setCanPressUploadPicture(false);
    setShowUploadPicture(false);
    setTimeout(() => {
      setCanPressUploadPicture(true);
    }, 2000);
  };

  const handleCloseAboutRecipe = () => {
    setCanPressAboutRecipe(false);
    setShowAboutRecipe(false);
    setTimeout(() => {
      setCanPressAboutRecipe(true);
    }, 2000);
  };

  const resetForm = () => {
    setRecipeName(null);
    setSourceMaterial(displayDropField(displaySourceType));
    setSource(null);
    setSourceURL(null);
    setCuisineType(displayDropArray(displayCuisineTypes));
    setDishType(displayDropArray(displayDishTypes));
    setDietType(displayDropArray(displayDietTypes));
    setServings(null);
    setPrepTime(null);
    setCookTime(null);
    setIngredients([]);
    setInstructions([]);
    setAboutRecipe(null);
    setFinalImage(null);
    setTempIngAmount(null);
    setTempIngMeasurement(displayDropField(displayMeasurements));
    setTempIngName(null);
    setTempNote(null);

    setShowInstructions(false);
    setShowIngredients(false);
    setShowUploadPicture(false);
    setShowAboutRecipe(false);
    setCanPressIngredients(true);
    setCanPressInstructions(true);
    setCanPressUploadPicture(true);
    setCanPressAboutRecipe(true);
    setRecipeName(null);
    setValidation1(false);
    setValidation2(false);
    setValidation3(false);
    setValidation4(false);
  };

  const handleSaveRecipe = () => {
    if (!canSave) return;

    dispatch({
      type: 'ADD_ITEM_TO_RECIPE_BOX',
      payload: {
        recipeBoxID: core?.recipeBoxID,
        newRecipe: recipeObject,
        finalImage,
        profileID: core?.userID,
      },
    });
    resetForm();
  };

  return (
    <Layout
      headerTitle={'Add Recipe'}
      LeftButton="Back"
      RightButton={canSave ? 'Save' : ''}
      LeftAction={null}
      RightAction={handleSaveRecipe}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}
      innerViewStyles={{paddingHorizontal: 5}}
      mode={
        showIngredients ||
        showInstructions ||
        showAboutRecipe ||
        showUploadPicture
          ? 'static'
          : 'keyboard-scroll'
      }
      hideBar>
      <RecipeForm
        recipeName={recipeName}
        setRecipeName={setRecipeName}
        validation1={validation1}
        sourceMaterial={sourceMaterial}
        setSourceMaterial={setSourceMaterial}
        displaySourceType={displaySourceType}
        validation2={validation2}
        sourceType={sourceType}
        validation3={validation3}
        validation4={validation4}
        displaySourceExample={displaySourceExample}
        source={source}
        setSource={setSource}
        sourceURL={sourceURL}
        setSourceURL={setSourceURL}
        cuisineType={cuisineType}
        setCuisineType={setCuisineType}
        displayCuisineTypes={displayCuisineTypes}
        dishType={dishType}
        setDishType={setDishType}
        displayDishTypes={displayDishTypes}
        dietType={dietType}
        setDietType={setDietType}
        displayDietTypes={displayDietTypes}
        servings={servings}
        setServings={setServings}
        prepTime={prepTime}
        setPrepTime={setPrepTime}
        cookTime={cookTime}
        setCookTime={setCookTime}
      />
      <View row>
        <View flex mt20>
          <Button
            textSize="small"
            size="medium"
            disabled={!canPressAboutRecipe}
            onPress={() => {
              setShowAboutRecipe(true);
            }}>
            Add Description
          </Button>
        </View>
        <View flex mt20>
          <Button
            textSize="small"
            size="medium"
            disabled={
              !canPressUploadPicture || recipeName === null || recipeName === ''
            }
            onPress={() => {
              setShowUploadPicture(true);
            }}>
            Upload Picture
          </Button>
        </View>
      </View>
      <View row>
        <View flex mt5>
          <Button
            textSize="small"
            size="medium"
            disabled={!canPressIngredients}
            onPress={() => {
              setShowIngredients(true);
            }}>
            Add Ingredients
            {ingredients?.length > 0 && ` (${ingredients?.length})`}
          </Button>
        </View>
        <View flex mt5>
          <Button
            textSize="small"
            size="medium"
            disabled={!canPressInstructions}
            onPress={() => {
              setShowInstructions(true);
            }}>
            Add Instructions
            {instructions?.length > 0 && ` (${instructions?.length})`}
          </Button>
        </View>
      </View>

      <View style={{height: 100}} />

      <BottomSheet
        visible={showIngredients}
        onClose={handleCloseIngredients}
        snapPoints={[0.01, 0.95]}
        innerStyles={{margin: 0}}>
        <IngredientForm
          ingredients={ingredients}
          setIngredients={setIngredients}
          tempIngAmount={tempIngAmount}
          setTempIngAmount={setTempIngAmount}
          tempIngMeasurement={tempIngMeasurement}
          setTempIngMeasurement={setTempIngMeasurement}
          tempIngName={tempIngName}
          setTempIngName={setTempIngName}
          handleCloseIngredients={handleCloseIngredients}
          tempNote={tempNote}
          setTempNote={setTempNote}
        />
      </BottomSheet>

      <BottomSheet
        visible={showInstructions}
        onClose={handleCloseInstructions}
        snapPoints={[0.01, 0.95]}
        innerStyles={{margin: 0}}>
        <InstructionForm
          instructions={instructions}
          setInstructions={setInstructions}
          handleCloseInstructions={handleCloseInstructions}
        />
      </BottomSheet>

      <BottomSheet
        visible={showAboutRecipe}
        onClose={handleCloseAboutRecipe}
        snapPoints={[0.01, 0.95]}>
        <Input
          label="Recipe Description"
          caption="Optional: Info about this recipe"
          placeholder="Ex: This is a warm and hearty dish that..."
          value={aboutRecipe}
          onChangeText={setAboutRecipe}
          capitalize
          capitalMode="sentences"
          multiline
          multiHeight="large"
          counter
          maxCount={300}
          textInputStyles={{height: 140}}
        />

        <View row>
          <View flex />
          <View>
            <Button onPress={handleCloseAboutRecipe}>Finished</Button>
          </View>
        </View>
        <View mt25 ph15>
          <Text centered size="xSmall" italic kqColor="dark70">
            Note: Description will not be shown in Recipe Box Recipe View. It
            will appear when/if recipe is shared publicly.
          </Text>
        </View>
      </BottomSheet>
      <BottomSheet
        visible={showUploadPicture}
        onClose={handleCloseUploadPicture}
        snapPoints={[0.01, 0.95]}>
        <UploadPicture
          pictureName={pictureName}
          handleCloseUploadPicture={handleCloseUploadPicture}
          finalImage={finalImage}
          setFinalImage={setFinalImage}
        />
      </BottomSheet>
    </Layout>
  );
};

export default AddRecipe;


--- FILE: src/screens/Recipe/EditRecipe.jsx ---

//* EditRecipe.jsx

import React, {useEffect, useMemo, useState} from 'react';
import {BottomSheet, Button, Input, Layout, Text, View} from '../../KQ-UI';
import {useCoreInfo} from '../../utilities/coreInfo';
import {displaySourceType} from '../../utilities/materialSource';
import {
  displayDropField,
  displayDropArray,
  capEachWord,
} from '../../utilities/helpers';
import {displayCuisineTypes} from '../../utilities/cuisineType';
import {displayDishTypes} from '../../utilities/dishType';
import {displayDietTypes} from '../../utilities/dietType';
import {displayMeasurements} from '../../utilities/measurements';
import {normalizeTitleForKeywords} from '../../utilities/normalizeTitle';
import UploadPicture from './UploadPicture';
import IngredientForm from './Forms/IngredientForm';
import InstructionForm from './Forms/InstructionForm';
import RecipeForm from './Forms/RecipeForm';
import {useDispatch} from 'react-redux';
import {useNavigation, useRoute} from '@react-navigation/native';

const EditRecipe = () => {
  const core = useCoreInfo();
  const dispatch = useDispatch();
  const navigation = useNavigation();
  const route = useRoute();
  const {recipeToEdit, editingRecipe, fromCommunity} = route.params || {};
  console.log('recipeToEdit:', recipeToEdit);

  const [validation1, setValidation1] = useState(false);
  const [validation2, setValidation2] = useState(false);
  const [validation3, setValidation3] = useState(false);
  const [validation4, setValidation4] = useState(false);
  const [canSave, setCanSave] = useState(false);

  const [recipeName, setRecipeName] = useState(null);
  const [sourceMaterial, setSourceMaterial] = useState(
    displayDropField(displaySourceType) ?? null,
  );

  const [source, setSource] = useState(null);
  const [sourceURL, setSourceURL] = useState(null);

  const [cuisineType, setCuisineType] = useState(
    displayDropArray(displayCuisineTypes) ?? null,
  );
  const [dishType, setDishType] = useState(
    displayDropArray(displayDishTypes) ?? null,
  );
  const [dietType, setDietType] = useState(
    displayDropArray(displayDietTypes) ?? null,
  );
  const [servings, setServings] = useState(null);
  const [prepTime, setPrepTime] = useState(null);
  const [cookTime, setCookTime] = useState(null);
  const [ingredients, setIngredients] = useState([]);
  const [instructions, setInstructions] = useState([]);
  const [aboutRecipe, setAboutRecipe] = useState(null);

  const [finalImage, setFinalImage] = useState(null);

  const [showInstructions, setShowInstructions] = useState(false);
  const [showIngredients, setShowIngredients] = useState(false);

  const [canPressIngredients, setCanPressIngredients] = useState(true);
  const [canPressInstructions, setCanPressInstructions] = useState(true);

  const [showUploadPicture, setShowUploadPicture] = useState(false);
  const [showAboutRecipe, setShowAboutRecipe] = useState(false);

  const [canPressUploadPicture, setCanPressUploadPicture] = useState(true);
  const [canPressAboutRecipe, setCanPressAboutRecipe] = useState(true);

  const [tempIngAmount, setTempIngAmount] = useState(null);
  const [tempIngMeasurement, setTempIngMeasurement] = useState(
    displayDropField(displayMeasurements) ?? null,
  );
  const [tempIngName, setTempIngName] = useState(null);
  const [tempNote, setTempNote] = useState(null);

  const [sourceType, setSourceType] = useState(null);

  const [keywords, setKeywords] = useState(null);
  const [pictureName, setPictureName] = useState(null);

  const [ignoreSource, setIgnoreSource] = useState(false);

  useEffect(() => {
    if (sourceMaterial && sourceType && source && sourceURL) return;

    if (recipeToEdit?.source === 'Epicurious') {
      setSourceMaterial(displaySourceType.find(i => i.key === 'website'));
      setSourceType('online');
      setSource('Epicurious');
      setSourceURL(recipeToEdit.sourceURL || 'www.epicurious.com');
      setIgnoreSource(true);
      return;
    }

    if (!sourceMaterial) {
      setSource(null);
      setSourceType(null);
      return;
    }

    const key = sourceMaterial?.key;

    if (key === 'personal') {
      setSource('personal');
      setSourceType('personal');
    } else if (['friend', 'family'].includes(key)) {
      setSource(prev => (editingRecipe && prev ? prev : null));
      setSourceType('private');
    } else if (['social', 'website', 'app'].includes(key)) {
      setSource(prev => (editingRecipe && prev ? prev : null));
      setSourceType('online');
    } else if (
      ['cookbook', 'restaurant', 'tv', 'magazine', 'package', 'event'].includes(
        key,
      )
    ) {
      setSource(prev => (editingRecipe && prev ? prev : null));
      setSourceType('published');
    } else {
      setSourceType(null);
    }
  }, [
    recipeToEdit,
    sourceMaterial,
    editingRecipe,
    sourceType,
    source,
    sourceURL,
  ]);

  useMemo(() => {
    const normalized = normalizeTitleForKeywords(recipeName);
    setKeywords(normalized);

    const slug = normalized.slice(1).join('-');
    const prefix = core?.profileID || core?.userID;

    setPictureName(`${prefix}-${slug}`);
  }, [recipeName]);

  const recipeObject = {
    ...recipeToEdit,
    title: recipeName?.toLowerCase().trim() ?? recipeToEdit?.title ?? null,
    sourceMaterial: sourceMaterial?.key ?? recipeToEdit?.sourceMaterial ?? null,
    source: source?.toLowerCase().trim() ?? recipeToEdit?.source ?? null,
    sourceURL:
      sourceURL?.trim().toLowerCase().replace(/\s+/g, '') ??
      recipeToEdit?.sourceURL ??
      null,
    cuisines: cuisineType?.map(c => c.value) ?? recipeToEdit?.cuisines ?? [],
    dishTypes: dishType?.map(c => c.value) ?? recipeToEdit?.dishTypes ?? [],
    diets: dietType?.map(c => c.value) ?? recipeToEdit?.diets ?? [],
    servings: servings ? Number(servings) : recipeToEdit?.servings ?? null,
    prepTime: prepTime ? Number(prepTime) : recipeToEdit?.prepTime ?? null,
    cookTime: cookTime ? Number(cookTime) : recipeToEdit?.cookTime ?? null,
    readyIn:
      prepTime && cookTime
        ? Number(prepTime) + Number(cookTime)
        : recipeToEdit?.readyIn ?? null,
    ingredients: ingredients?.length
      ? ingredients
      : recipeToEdit?.ingredients ?? [],
    instructions: instructions?.length
      ? instructions
      : recipeToEdit?.instructions ?? [],
    image: finalImage?.name ?? recipeToEdit?.image ?? null,
    imageUri: finalImage
      ? `https://firebasestorage.googleapis.com/v0/b/kitchen-queue-fe2fe.firebasestorage.app/o/recipes%2F${finalImage?.name}?alt=media`
      : recipeToEdit?.imageUri ?? null,
    imageDate: finalImage?.imageDate ?? recipeToEdit?.imageDate ?? null,
    ingredientList: ingredients?.length
      ? ingredients.map(ing => ing.name?.toLowerCase().trim())
      : recipeToEdit?.ingredientList ?? [],
    keywords: keywords ?? recipeToEdit?.keywords ?? [],
    aboutRecipe: aboutRecipe?.trim() ?? recipeToEdit?.aboutRecipe ?? null,
  };

  const isValidText = value =>
    typeof value === 'string' && value.trim().length >= 2;

  useEffect(() => {
    const nameValid = isValidText(recipeName);
    const materialValid = sourceMaterial !== null;

    const sourceRequired = sourceType !== 'personal';
    const sourceValid = !sourceRequired || isValidText(source);

    const urlRequired = sourceType === 'online';
    const urlValid = !urlRequired || isValidText(sourceURL);

    const ingredientValid = ingredients?.length > 0;
    const instructionValid = instructions?.length > 0;

    // For debugging purposes
    // if (recipeName === null) console.log('Recipe Name is null');
    // if (!isValidText(recipeName)) console.log('Recipe Name is invalid');
    // if (!materialValid) console.log('Source Material is null');
    // if (!sourceValid) console.log('Source is invalid');
    // if (!urlValid) console.log('Source URL is invalid');
    // if (!ingredientValid) console.log('Ingredients are empty');
    // if (!instructionValid) console.log('Instructions are empty');

    // Show red error on name only
    setValidation1(
      recipeName === '' ||
        (typeof recipeName === 'string' && recipeName.trim() === ''),
    );

    // Disable save unless all are valid
    const allValid =
      nameValid &&
      materialValid &&
      sourceValid &&
      urlValid &&
      ingredientValid &&
      instructionValid;
    setCanSave(allValid);
  }, [
    recipeName,
    sourceMaterial,
    source,
    sourceURL,
    sourceType,
    ingredients,
    instructions,
  ]);

  const displaySourceExample = useMemo(() => {
    if (sourceMaterial?.key === 'friend') return 'Ex: Jane Doe';
    if (sourceMaterial?.key === 'family') return 'Ex: Grandma Jane';
    if (sourceMaterial?.key === 'social') return 'Ex: Facebook';
    if (sourceMaterial?.key === 'website') return 'Ex: Pinch of Yum';
    if (sourceMaterial?.key === 'app') return 'Ex: ChatGPT';
    if (sourceMaterial?.key === 'cookbook') return 'Ex: Better Homes Cook Book';
    if (sourceMaterial?.key === 'restaurant') return 'Ex: Olive Garden';
    if (sourceMaterial?.key === 'tv') return 'Ex: Iron Chef';
    if (sourceMaterial?.key === 'magazine') return 'Ex: Food Network Magazine';
    if (sourceMaterial?.key === 'package') return 'Ex: Nestle Toll House';
    if (sourceMaterial?.key === 'event') return 'Ex: Square One';
    return null;
  }, [sourceMaterial]);

  useMemo(() => {
    if (editingRecipe) {
      setRecipeName(capEachWord(recipeToEdit?.title));
      setSourceMaterial(
        displaySourceType.find(
          item => item.key === recipeToEdit?.sourceMaterial,
        ) || null,
      );
      setSource(capEachWord(recipeToEdit?.source));
      setSourceURL(recipeToEdit?.sourceURL || null);
      setCuisineType(
        displayCuisineTypes.filter(c =>
          recipeToEdit?.cuisines?.includes(c.value),
        ) || null,
      );
      setDishType(
        displayDishTypes.filter(d =>
          recipeToEdit?.dishTypes?.includes(d.value),
        ) || null,
      );
      setDietType(
        displayDietTypes.filter(d => recipeToEdit?.diets?.includes(d.value)) ||
          null,
      );
      setServings(recipeToEdit?.servings?.toString() || null);
      setPrepTime(recipeToEdit?.prepTime?.toString() || null);
      setCookTime(recipeToEdit?.cookTime?.toString() || null);
      setIngredients(recipeToEdit?.ingredients || []);
      setInstructions(recipeToEdit?.instructions || []);
      setAboutRecipe(recipeToEdit?.aboutRecipe || null);
      setFinalImage(
        recipeToEdit?.image
          ? {
              imageUri: recipeToEdit?.imageUri,
              uri: recipeToEdit?.imageUri,
              imageDate: recipeToEdit?.imageDate,
            }
          : null,
      );
    }
  }, [recipeToEdit, editingRecipe]);

  const imageChanged = useMemo(() => {
    return Boolean(
      finalImage?.imageDate && finalImage.imageDate !== recipeToEdit?.imageDate,
    );
  }, [finalImage?.imageDate, recipeToEdit?.imageDate]);

  const handleCloseIngredients = () => {
    setCanPressIngredients(false);
    setShowIngredients(false);
    setTempIngAmount(null);
    setTempIngMeasurement(null);
    setTempIngName(null);
    setTimeout(() => {
      setCanPressIngredients(true);
    }, 2000);
  };

  const handleCloseInstructions = () => {
    setCanPressInstructions(false);
    setShowInstructions(false);
    setTimeout(() => {
      setCanPressInstructions(true);
    }, 2000);
  };

  const handleCloseUploadPicture = () => {
    setCanPressUploadPicture(false);
    setShowUploadPicture(false);
    setTimeout(() => {
      setCanPressUploadPicture(true);
    }, 2000);
  };

  const handleCloseAboutRecipe = () => {
    setCanPressAboutRecipe(false);
    setShowAboutRecipe(false);
    setTimeout(() => {
      setCanPressAboutRecipe(true);
    }, 2000);
  };

  const resetForm = () => {
    setRecipeName(null);
    setSourceMaterial(displayDropField(displaySourceType));
    setSource(null);
    setSourceURL(null);
    setCuisineType(displayDropArray(displayCuisineTypes));
    setDishType(displayDropArray(displayDishTypes));
    setDietType(displayDropArray(displayDietTypes));
    setServings(null);
    setPrepTime(null);
    setCookTime(null);
    setIngredients([]);
    setInstructions([]);
    setAboutRecipe(null);
    setFinalImage(null);
    setTempIngAmount(null);
    setTempIngMeasurement(displayDropField(displayMeasurements));
    setTempIngName(null);
    setTempNote(null);

    setShowInstructions(false);
    setShowIngredients(false);
    setShowUploadPicture(false);
    setShowAboutRecipe(false);
    setCanPressIngredients(true);
    setCanPressInstructions(true);
    setCanPressUploadPicture(true);
    setCanPressAboutRecipe(true);
    setRecipeName(null);
    setValidation1(false);
    setValidation2(false);
    setValidation3(false);
    setValidation4(false);
  };

  const handleSaveRecipe = () => {
    if (!canSave) return;

    const editedRecipeSafe = {
      ...recipeObject,
      ...(imageChanged
        ? {}
        : {
            image: recipeToEdit?.image ?? null,
            imageUri: recipeToEdit?.imageUri ?? null,
            imageDate: recipeToEdit?.imageDate ?? null,
          }),
    };

    !fromCommunity &&
      dispatch({
        type: 'UPDATE_ITEM_IN_RECIPE_BOX',
        payload: {
          recipeBoxID: core?.recipeBoxID,
          editedRecipe: editedRecipeSafe,
          finalImage,
          profileID: core?.userID,
          pictureWasChanged: imageChanged,
          oldImageName: recipeToEdit?.image,
        },
      });

    fromCommunity &&
      dispatch({
        type: 'UPDATE_TO_COMMUNITY_RECIPES',
        payload: {
          editedRecipe: editedRecipeSafe,
          finalImage,
          profileID: core?.userID,
          pictureWasChanged: imageChanged,
          oldImageName: recipeToEdit?.image,
        },
      });

    resetForm();
    navigation.goBack();
  };

  return (
    <Layout
      headerTitle={'Edit Recipe'}
      LeftButton="Back"
      RightButton={canSave ? 'Save' : ''}
      LeftAction={null}
      RightAction={handleSaveRecipe}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}
      innerViewStyles={{paddingHorizontal: 5}}
      mode={
        showIngredients ||
        showInstructions ||
        showAboutRecipe ||
        showUploadPicture
          ? 'static'
          : 'keyboard-scroll'
      }
      hideBar>
      <RecipeForm
        recipeName={recipeName}
        setRecipeName={setRecipeName}
        validation1={validation1}
        sourceMaterial={sourceMaterial}
        setSourceMaterial={setSourceMaterial}
        displaySourceType={displaySourceType}
        validation2={validation2}
        sourceType={sourceType}
        validation3={validation3}
        validation4={validation4}
        displaySourceExample={displaySourceExample}
        source={source}
        setSource={setSource}
        sourceURL={sourceURL}
        setSourceURL={setSourceURL}
        cuisineType={cuisineType}
        setCuisineType={setCuisineType}
        displayCuisineTypes={displayCuisineTypes}
        dishType={dishType}
        setDishType={setDishType}
        displayDishTypes={displayDishTypes}
        dietType={dietType}
        setDietType={setDietType}
        displayDietTypes={displayDietTypes}
        servings={servings}
        setServings={setServings}
        prepTime={prepTime}
        setPrepTime={setPrepTime}
        cookTime={cookTime}
        setCookTime={setCookTime}
        ignoreSource={ignoreSource}
      />
      <View row>
        <View flex mt20>
          <Button
            textSize="small"
            size="medium"
            disabled={!canPressAboutRecipe}
            onPress={() => {
              setShowAboutRecipe(true);
            }}>
            Add Description
          </Button>
        </View>
        <View flex mt20>
          <Button
            textSize="small"
            size="medium"
            disabled={
              !canPressUploadPicture || recipeName === null || recipeName === ''
            }
            onPress={() => {
              setShowUploadPicture(true);
            }}>
            Upload Picture
          </Button>
        </View>
      </View>
      <View row>
        <View flex mt5>
          <Button
            textSize="small"
            size="medium"
            disabled={!canPressIngredients}
            onPress={() => {
              setShowIngredients(true);
            }}>
            Add Ingredients
            {ingredients?.length > 0 && ` (${ingredients?.length})`}
          </Button>
        </View>
        <View flex mt5>
          <Button
            textSize="small"
            size="medium"
            disabled={!canPressInstructions}
            onPress={() => {
              setShowInstructions(true);
            }}>
            Add Instructions
            {instructions?.length > 0 && ` (${instructions?.length})`}
          </Button>
        </View>
      </View>

      <View style={{height: 100}} />

      <BottomSheet
        visible={showIngredients}
        onClose={handleCloseIngredients}
        snapPoints={[0.01, 0.95]}
        innerStyles={{margin: 0}}>
        <IngredientForm
          ingredients={ingredients}
          setIngredients={setIngredients}
          tempIngAmount={tempIngAmount}
          setTempIngAmount={setTempIngAmount}
          tempIngMeasurement={tempIngMeasurement}
          setTempIngMeasurement={setTempIngMeasurement}
          tempIngName={tempIngName}
          setTempIngName={setTempIngName}
          handleCloseIngredients={handleCloseIngredients}
          tempNote={tempNote}
          setTempNote={setTempNote}
        />
      </BottomSheet>

      <BottomSheet
        visible={showInstructions}
        onClose={handleCloseInstructions}
        snapPoints={[0.01, 0.95]}
        innerStyles={{margin: 0}}>
        <InstructionForm
          instructions={instructions}
          setInstructions={setInstructions}
          handleCloseInstructions={handleCloseInstructions}
        />
      </BottomSheet>

      <BottomSheet
        visible={showAboutRecipe}
        onClose={handleCloseAboutRecipe}
        snapPoints={[0.01, 0.95]}>
        <Input
          label="Recipe Description"
          caption="Optional: Info about this recipe"
          placeholder="Ex: This is a warm and hearty dish that..."
          value={aboutRecipe}
          onChangeText={setAboutRecipe}
          capitalize
          capitalMode="sentences"
          multiline
          multiHeight="large"
          counter
          maxCount={300}
          textInputStyles={{height: 140}}
        />

        <View row>
          <View flex />
          <View>
            <Button onPress={handleCloseAboutRecipe}>Finished</Button>
          </View>
        </View>
        <View mt25 ph15>
          <Text centered size="xSmall" italic kqColor="dark70">
            Note: Description will not be shown in Recipe Box Recipe View. It
            will appear when/if recipe is shared publicly.
          </Text>
        </View>
      </BottomSheet>
      <BottomSheet
        visible={showUploadPicture}
        onClose={handleCloseUploadPicture}
        snapPoints={[0.01, 0.95]}>
        <UploadPicture
          pictureName={pictureName}
          handleCloseUploadPicture={handleCloseUploadPicture}
          finalImage={finalImage}
          setFinalImage={setFinalImage}
        />
      </BottomSheet>
    </Layout>
  );
};

export default EditRecipe;


--- FILE: src/screens/Recipe/Forms/IngredientForm.jsx ---

//* IngredientForm.jsx
import React, {useEffect, useState} from 'react';
import {KeyboardAvoidingView, Platform, TouchableOpacity} from 'react-native';
import {Button, Dropdown, Input, ScrollView, Text, View} from '../../../KQ-UI';
import {Icons} from '../../../components/IconListRouter';
import {setHapticFeedback} from '../../../hooks/setHapticFeedback';
import {useColors} from '../../../KQ-UI/KQUtilities';
import {
  capFirst,
  formatMeasurementWithPluralRec,
} from '../../../utilities/helpers';
import {useCoreInfo} from '../../../utilities/coreInfo';
import {displayMeasurements} from '../../../utilities/measurements';

const IngredientForm = props => {
  const {
    ingredients,
    setIngredients,
    tempIngAmount,
    setTempIngAmount,
    tempIngMeasurement,
    setTempIngMeasurement,
    tempIngName,
    setTempIngName,
    handleCloseIngredients,
    tempNote,
    setTempNote,
  } = props;
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();
  const [canAdd, setCanAdd] = useState(false);

  const handleAddIngredient = () => {
    if (canAdd) {
      let newObject = {
        amount: tempIngAmount ? Number(tempIngAmount) : null,
        unit: tempIngMeasurement?.key,
        name: tempIngName?.toLowerCase().trim() ?? null,
        note: tempNote ?? null,
      };
      setIngredients(prev => [...prev, newObject]);
      setTempIngAmount(null);
      setTempIngMeasurement(null);
      setTempIngName(null);
      setTempNote(null);
    }
  };

  const moveIngredient = (fromIndex, toIndex) => {
    setIngredients(prev => {
      const updated = [...prev];
      const item = updated.splice(fromIndex, 1)[0];
      updated.splice(toIndex, 0, item);
      return updated;
    });
  };

  useEffect(() => {
    if (tempIngAmount && tempIngMeasurement && tempIngName) {
      setCanAdd(true);
    } else {
      setCanAdd(false);
    }
  }, [tempIngAmount, tempIngMeasurement, tempIngName]);

  const handleMove = (index, direction) => {
    useHaptics(core?.userSettings?.hapticStrength || 'light');
    moveIngredient(index, direction);
  };

  return (
    <>
      <View row>
        <View flex>
          <Input
            required
            labelStyles={{fontSize: 13}}
            label="Amount"
            value={tempIngAmount}
            onChangeText={setTempIngAmount}
            keyboardType="numeric"
            size="tiny"
          />
        </View>
        <View flex>
          <Dropdown
            required
            label="Measurement"
            placeholder="Select a measurement"
            labelStyles={{fontSize: 13}}
            value={tempIngMeasurement}
            setValue={setTempIngMeasurement}
            mapData={displayMeasurements}
            onRow
          />
        </View>
      </View>
      <View row>
        <View flex>
          <Input
            required
            label="Name"
            labelStyles={{fontSize: 13}}
            value={tempIngName}
            onChangeText={setTempIngName}
            capitalize
            capitalMode="words"
          />
        </View>
      </View>
      {/* 
        Note sure if we need this, but leaving it for now*/}
      <View row>
        <View flex>
          <Input
            label="Note"
            caption="Optional note for the ingredient"
            labelStyles={{fontSize: 13}}
            value={tempNote}
            onChangeText={setTempNote}
            capitalize
            capitalMode="sentences"
            counter
            maxCount={100}
            multiline
            multiHeight="large"
          />
        </View>
      </View>
      <View row mt15>
        <View>
          <Button
            type="outline"
            color="primary"
            textSize="xSmall"
            size="tiny"
            disabled={!canAdd}
            onPress={() => handleAddIngredient()}>
            Add Item
          </Button>
        </View>
        <View flex />
        <View>
          <Button
            textSize="xSmall"
            size="tiny"
            onPress={handleCloseIngredients}>
            Finished
          </Button>
        </View>
      </View>
      <KeyboardAvoidingView
        style={{flex: 1}}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 180 : 180} // adjust depending on your header height
      >
        <ScrollView style={styles.scrollStyles} hideBar>
          {ingredients?.length > 0 ? (
            ingredients?.map((ing, index) => (
              <View key={index} row centerH pv5>
                {/* Ingredient text */}
                <View flex ml5>
                  <Text size="xSmall" font="open-6">
                    {formatMeasurementWithPluralRec(
                      ing.amount,
                      ing.unit,
                      ing.name,
                    )}
                  </Text>
                  {ing.note && (
                    <Text size="tiny" font="open-5" italic>
                      ** {ing.note}
                    </Text>
                  )}
                </View>

                {/* Reorder arrows */}
                <View row>
                  {index > 0 && (
                    <TouchableOpacity
                      style={styles.indexButtons}
                      onPress={() => handleMove(index, index - 1)}>
                      <Icons.ChevronUp size={16} color={useColors('dark')} />
                    </TouchableOpacity>
                  )}
                  {index < ingredients.length - 1 && (
                    <TouchableOpacity
                      style={styles.indexButtons}
                      onPress={() => handleMove(index, index + 1)}>
                      <Icons.ChevronDown size={16} color={useColors('dark')} />
                    </TouchableOpacity>
                  )}
                  {/* Delete button */}
                  <View centerVH>
                    <TouchableOpacity
                      style={{marginRight: 10}}
                      onPress={() => {
                        useHaptics(
                          core?.userSettings?.hapticStrength || 'light',
                        );
                        setIngredients(prev =>
                          prev.filter((_, i) => i !== index),
                        );
                      }}>
                      <Icons.XCircleOutline
                        size={20}
                        color={useColors('danger')}
                      />
                    </TouchableOpacity>
                  </View>
                </View>
              </View>
            ))
          ) : (
            <View centerH mt20>
              <Text size="xSmall" font="open-6" centered>
                No ingredients added yet.
              </Text>
            </View>
          )}
        </ScrollView>
      </KeyboardAvoidingView>
    </>
  );
};

const styles = {
  indexButtons: {
    marginRight: 10,
    width: 30,
    height: 25,
    alignContent: 'center',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1.5,
    borderRadius: 5,
    borderColor: useColors('dark70'),
  },
  scrollStyles: {
    flex: 1,
    marginTop: 10,
    backgroundColor: '#fff',
    paddingHorizontal: 5,
  },
};

export default IngredientForm;


--- FILE: src/screens/Recipe/Forms/InstructionForm.jsx ---

//* InstructionForm.jsx

import React, {useEffect, useRef, useState} from 'react';
import {setHapticFeedback} from '../../../hooks/setHapticFeedback';
import {useCoreInfo} from '../../../utilities/coreInfo';
import {Button, Input, Text, View} from '../../../KQ-UI';
import {Icons} from '../../../components/IconListRouter';
import {ScrollView} from 'react-native-gesture-handler';
import {KeyboardAvoidingView, Platform, TouchableOpacity} from 'react-native';
import {useColors} from '../../../KQ-UI/KQUtilities';
import {capEachWord, formatParagraph} from '../../../utilities/helpers';
import {Keyboard} from 'react-native';

const InstructionForm = props => {
  const {instructions, setInstructions, handleCloseInstructions, tempName} =
    props;
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();

  useEffect(() => {
    const showSub = Keyboard.addListener('keyboardDidShow', e => {
      console.log('Keyboard height:', e.endCoordinates.height);
      // you can store this in state and use it for offset
    });

    const hideSub = Keyboard.addListener('keyboardDidHide', () => {
      // console.log('Keyboard hidden');
    });

    return () => {
      showSub.remove();
      hideSub.remove();
    };
  }, []);

  const groupRefs = useRef([]);

  const handleAddGroup = () => {
    setInstructions(prev => {
      const updated = [...prev, {name: '', steps: [], index: prev.length}];
      return updated.map((g, i) => ({...g, index: i}));
    });

    // mark the new group as edit mode
    setCompleted(prev => ({
      ...prev,
      [instructions.length]: true,
    }));

    setTimeout(() => {
      const lastIndex = instructions.length;
      groupRefs.current[lastIndex]?.focus();
    }, 50);
  };

  const stepRefs = useRef({});

  const handleAddStep = groupIndex => {
    setInstructions(prev => {
      const updated = [...prev];
      const newStepIndex = updated[groupIndex].steps.length;

      updated[groupIndex] = {
        ...updated[groupIndex],
        steps: [...updated[groupIndex].steps, {step: newStepIndex, action: ''}],
      };
      return updated;
    });

    setTimeout(() => {
      const newIndex = instructions[groupIndex]?.steps.length || 0;
      stepRefs.current[groupIndex]?.[newIndex]?.focus();
    }, 50);
  };

  const moveInstruction = (fromIndex, toIndex) => {
    setInstructions(prev => {
      const updated = [...prev];
      const item = updated.splice(fromIndex, 1)[0];
      updated.splice(toIndex, 0, item);
      return updated.map((g, i) => ({...g, index: i}));
    });
  };

  const handleMove = (index, direction) => {
    useHaptics(core?.userSettings?.hapticStrength || 'light');
    moveInstruction(index, direction);
  };

  const moveStep = (groupIndex, fromIndex, toIndex) => {
    setInstructions(prev => {
      const updated = [...prev];
      const steps = [...updated[groupIndex].steps];
      const [moved] = steps.splice(fromIndex, 1);
      steps.splice(toIndex, 0, moved);

      updated[groupIndex] = {
        ...updated[groupIndex],
        steps: steps.map((s, i) => ({...s, step: i})), // reindex
      };
      return updated;
    });
  };

  useEffect(() => {
    if (instructions.length === 0) {
      setInstructions([{name: '', steps: [], index: 0}]);
      setCompleted({0: true}); // start in edit mode
    }
  }, [instructions, setInstructions]);

  const [completed, setCompleted] = useState({});

  return (
    <View flex ph5>
      <View row mb5>
        <View flex>
          <Button
            type="outline"
            textSize="xSmall"
            size="tiny"
            onPress={handleAddGroup}>
            Add Group
          </Button>
        </View>
        <View flex>
          <Button
            textSize="xSmall"
            size="tiny"
            onPress={handleCloseInstructions}>
            Finished
          </Button>
        </View>
      </View>
      <KeyboardAvoidingView
        style={{flex: 1}}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 180 : 180} // adjust depending on your header height
      >
        <ScrollView style={styles.scrollStyles} hideBar>
          {instructions?.map((instruction, index) => (
            <View key={index} style={styles.groupContainer}>
              {completed[index] ? (
                <>
                  <View row>
                    <View flex>
                      <Input
                        ref={el => (groupRefs.current[index] = el)}
                        required
                        label="Group Name"
                        value={capEachWord(instruction.name)}
                        onChangeText={text => {
                          setInstructions(prev => {
                            const updated = [...prev];
                            updated[index] = {
                              ...updated[index],
                              name: text,
                            };
                            return updated;
                          });
                        }}
                        textSize="tiny"
                        labelTextSize="tiny"
                        capitalize
                        capitalMode="sentences"
                        multiline
                        multiHeight="small"
                      />
                    </View>
                    <View row centerVH>
                      {index > 0 && (
                        <TouchableOpacity
                          style={styles.indexButtons}
                          onPress={() => handleMove(index, index - 1)}>
                          <Icons.ChevronUp
                            size={15}
                            color={useColors('dark')}
                          />
                        </TouchableOpacity>
                      )}
                      {index < instructions.length - 1 && (
                        <TouchableOpacity
                          style={styles.indexButtons}
                          onPress={() => handleMove(index, index + 1)}>
                          <Icons.ChevronDown
                            size={15}
                            color={useColors('dark')}
                          />
                        </TouchableOpacity>
                      )}
                      <TouchableOpacity
                        style={{marginRight: 10}}
                        onPress={() => {
                          useHaptics(
                            core?.userSettings?.hapticStrength || 'light',
                          );
                          setInstructions(prev =>
                            prev.filter((_, i) => i !== index),
                          );
                        }}>
                        <Icons.XCircleOutline
                          size={18}
                          color={useColors('danger')}
                        />
                      </TouchableOpacity>
                    </View>
                  </View>

                  <View>
                    {instruction.steps?.length > 0 &&
                      instruction.steps.map((step, stepIndex) => (
                        <View key={stepIndex} row>
                          <View flex>
                            <Input
                              ref={el => {
                                if (!stepRefs.current[index])
                                  stepRefs.current[index] = [];
                                stepRefs.current[index][stepIndex] = el;
                              }}
                              label={`Step ${stepIndex + 1}`}
                              value={step.action}
                              onChangeText={text => {
                                setInstructions(prev => {
                                  const updated = [...prev];
                                  updated[index] = {
                                    ...updated[index],
                                    steps: updated[index].steps.map((s, i) =>
                                      i === stepIndex
                                        ? {...s, action: text}
                                        : s,
                                    ),
                                  };
                                  return updated;
                                });
                              }}
                              textSize="tiny"
                              labelTextSize="tiny"
                              capitalize
                              capitalMode="sentences"
                              multiline
                              multiHeight="small"
                            />
                          </View>
                          <View row centerVH>
                            {stepIndex > 0 && (
                              <TouchableOpacity
                                style={styles.indexButtons}
                                onPress={() => {
                                  useHaptics(
                                    core?.userSettings?.hapticStrength ||
                                      'light',
                                  );
                                  moveStep(index, stepIndex, stepIndex - 1);
                                }}>
                                <Icons.ChevronUp
                                  size={15}
                                  color={useColors('dark')}
                                />
                              </TouchableOpacity>
                            )}
                            {stepIndex < instruction.steps.length - 1 && (
                              <TouchableOpacity
                                style={styles.indexButtons}
                                onPress={() => {
                                  useHaptics(
                                    core?.userSettings?.hapticStrength ||
                                      'light',
                                  );
                                  moveStep(index, stepIndex, stepIndex + 1);
                                }}>
                                <Icons.ChevronDown
                                  size={15}
                                  color={useColors('dark')}
                                />
                              </TouchableOpacity>
                            )}
                            <TouchableOpacity
                              style={{marginRight: 10}}
                              onPress={() => {
                                useHaptics(
                                  core?.userSettings?.hapticStrength || 'light',
                                );
                                setInstructions(prev => {
                                  const updated = [...prev];
                                  updated[index] = {
                                    ...updated[index],
                                    steps: updated[index].steps.filter(
                                      (_, i) => i !== stepIndex,
                                    ),
                                  };
                                  return updated;
                                });
                              }}>
                              <Icons.XCircleOutline
                                size={18}
                                color={useColors('danger')}
                              />
                            </TouchableOpacity>
                          </View>
                        </View>
                      ))}
                    <View row>
                      <View>
                        <Button
                          textSize="xSmall"
                          size="tiny"
                          onPress={() => handleAddStep(index)}>
                          Add Step
                        </Button>
                      </View>
                      <View flex></View>
                      <View>
                        <Button
                          textSize="xSmall"
                          size="tiny"
                          onPress={() => {
                            setCompleted(prev => ({
                              ...prev,
                              [index]: false, // mark this group as complete
                            }));
                          }}>
                          Complete
                        </Button>
                      </View>
                    </View>
                  </View>
                </>
              ) : (
                <>
                  <View flex>
                    <View m5 mh10>
                      <Text size="small" font="open-7">
                        {capEachWord(instruction.name)}
                      </Text>
                    </View>
                    {instruction.steps?.length > 0 &&
                      instruction.steps.map((step, stepIndex) => (
                        <View key={stepIndex} m5 ph20 row>
                          <View>
                            <Text size="xSmall" font="open-7">
                              Step {step.step + 1}:
                            </Text>
                          </View>
                          <View flex ml5>
                            <Text size="xSmall" font="open-6">
                              {formatParagraph(step.action)}
                            </Text>
                          </View>
                        </View>
                      ))}
                    <View row>
                      <View flex />
                      <View>
                        <Button
                          textSize="xSmall"
                          size="tiny"
                          onPress={() => {
                            setCompleted(prev => ({
                              ...prev,
                              [index]: true, // mark this group as complete
                            }));
                          }}>
                          Edit
                        </Button>
                      </View>
                    </View>
                  </View>
                </>
              )}
            </View>
          ))}
          <View style={{height: 50}}></View>
        </ScrollView>
      </KeyboardAvoidingView>
    </View>
  );
};

const styles = {
  scrollStyles: {
    // borderWidth: 1,
    flex: 1,
    marginTop: 0,
    backgroundColor: '#fff',
    // paddingHorizontal: 5,
  },
  indexButtons: {
    marginRight: 5,
    width: 25,
    height: 20,
    alignContent: 'center',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1.5,
    borderRadius: 5,
    borderColor: useColors('dark70'),
  },
  groupContainer: {
    backgroundColor: 'white',
    borderWidth: 1.5,
    borderColor: useColors('dark50'),
    borderRadius: 10,
    shadowColor: '#000',
    shadowOffset: {width: 1, height: 2},
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    margin: 5,
    padding: 5, // remove this later
    marginBottom: 5,
  },
};

export default InstructionForm;


--- FILE: src/screens/Recipe/Forms/RecipeForm.jsx ---

//* RecipeForm.jsx
import React from 'react';
import {Dropdown, Input, MultiDropdown, View} from '../../../KQ-UI';

const RecipeForm = props => {
  const {
    recipeName,
    setRecipeName,
    validation1,
    sourceMaterial,
    setSourceMaterial,
    displaySourceType,
    validation2,
    sourceType,
    validation3,
    validation4,
    displaySourceExample,
    source,
    setSource,
    sourceURL,
    setSourceURL,
    cuisineType,
    setCuisineType,
    displayCuisineTypes,
    dishType,
    setDishType,
    displayDishTypes,
    dietType,
    setDietType,
    displayDietTypes,
    servings,
    setServings,
    prepTime,
    setPrepTime,
    cookTime,
    setCookTime,
    ignoreSource,
  } = props;

  return (
    <>
      <Input
        required
        label="Recipe Name"
        value={recipeName}
        onChangeText={setRecipeName}
        validation={validation1}
        validationMessage="Recipe Name is required"
        capitalize
        capitalMode="words"
      />

      <Dropdown
        required
        label="Source Material"
        placeholder="Select a Material Type"
        value={sourceMaterial}
        setValue={setSourceMaterial}
        caption={'Where the recipe is from'}
        mapData={displaySourceType}
        validation={validation2}
        validationMessage="Source Material is required"
        disabled={ignoreSource}
      />
      {sourceType !== 'personal' && sourceType !== null && (
        <Input
          required
          label="Source Name"
          placeholder={displaySourceExample}
          value={source}
          onChangeText={setSource}
          validation={sourceType !== 'personal' ? validation3 : null}
          validationMessage="Source Name is required"
          capitalize
          capitalMode="words"
          caption={
            sourceType === 'private' && 'Not Displayed Publicly. Reference Only'
          }
          disabled={ignoreSource}
        />
      )}
      {sourceType === 'online' && sourceType !== null && (
        <Input
          required={sourceType === 'online'}
          label="Source URL"
          placeholder="https://www.example.com"
          value={sourceURL}
          onChangeText={setSourceURL}
          validation={sourceType === 'online' ? validation4 : null}
          validationMessage="Source URL is required"
          capitalize
          capitalMode="none"
          disabled={ignoreSource}
        />
      )}

      <MultiDropdown
        // required
        label="Cuisine Type"
        placeholder="Select a Cuisine Type"
        caption="Ex: Italian, Mexican, etc."
        value={cuisineType}
        setValue={setCuisineType}
        mapData={displayCuisineTypes}
      />
      <MultiDropdown
        // required
        label="Dish Type"
        placeholder="Select a Dish Type"
        value={dishType}
        setValue={setDishType}
        mapData={displayDishTypes}
      />
      <MultiDropdown
        // required
        label="Diet Type"
        placeholder="Select a Diet Type"
        value={dietType}
        setValue={setDietType}
        mapData={displayDietTypes}
      />
      <View row>
        <View flex>
          <Input
            label="Servings"
            caption="Ex: 4 serv."
            value={servings}
            onChangeText={setServings}
            keyboardType="numeric"
          />
        </View>
        <View flex>
          <Input
            label="Prep Time"
            caption="Ex: 15 Min"
            value={prepTime}
            onChangeText={setPrepTime}
            keyboardType="numeric"
          />
        </View>
        <View flex>
          <Input
            label="Cook Time"
            caption="Ex: 15 Min"
            value={cookTime}
            onChangeText={setCookTime}
            keyboardType="numeric"
          />
        </View>
      </View>
    </>
  );
};
export default RecipeForm;


--- FILE: src/screens/Recipe/ImageFunctions/cropPhoto.js ---

// cropPhoto.js
import React, {useRef, useState} from 'react';
import {Platform} from 'react-native';
import RNFS from 'react-native-fs';
import ImagePicker from 'react-native-image-crop-picker';
import {imageScale} from '../../../utilities/imageScale';

export const useCropPhoto = () => {
  const [croppedData, setCroppedData] = useState(null);
  const [cropError, setCropError] = useState(null);
  const [cropView, setCropView] = useState(false);

  //   const pictureName = photoName || 'KQ_CROPPED';

  const cropPhoto = async (photoData, pictureName) => {
    setCropView(true);
    try {
      if (!photoData?.uri) {
        setCropError({
          type: 'error',
          text1: 'Crop failed',
          text2: 'No photo data available',
        });
      }

      const cropperPath =
        Platform.OS === 'android'
          ? photoData?.uri
          : photoData?.uri.replace('file://', '');

      const exists = await RNFS.exists(
        Platform.OS === 'android'
          ? cropperPath.replace('file://', '')
          : cropperPath,
      );

      if (!exists) {
        setCropError({
          type: 'error',
          text1: 'Crop failed',
          text2: 'Image path not found',
        });
        return;
      }
      const {
        width: targetW,
        height: targetH,
        quality: QUALITY,
      } = imageScale(photoData?.size);

      const image = await ImagePicker.openCropper({
        path: cropperPath,
        width: targetW,
        height: targetH,
        cropping: true,
        includeExif: false,
        mediaType: 'photo',
        forceJpg: true,
        compressImageQuality: QUALITY,
        cropperToolbarTitle: 'Crop Image',
        enableRotationGesture: true,
      });

      const croppedSrc = image.path.replace('file://', '');
      const dest =
        Platform.OS === 'ios'
          ? `${RNFS.DocumentDirectoryPath}/KQ_CROP_${Date.now()}.jpg`
          : `${
              RNFS.PicturesDirectoryPath
            }/KitchenQueue/KQ_CROP_${Date.now()}.jpg`;

      await RNFS.copyFile(croppedSrc, dest);
      if (Platform.OS === 'android') {
        try {
          await RNFS.scanFile(dest);
        } catch {}
      }
      try {
        await RNFS.unlink(croppedSrc);
      } catch {}
      try {
        const stat = await RNFS.stat(dest);
        const sizeKB = (Number(stat.size) / 1024).toFixed(2);

        setCroppedData({
          uri: `file://${dest}`,
          name: `${pictureName}.jpg`,
          width: image.width,
          height: image.height,
          size: `${sizeKB} KB`,
          imageDate: new Date().toISOString(),
          type: 'image/jpeg',
        });
      } catch {
        setCroppedData({
          uri: `file://${dest}`,
          name: `${pictureName}.jpg`,
          width: image.width,
          height: image.height,
          size: null,
          imageDate: new Date().toISOString(),
          type: 'image/jpeg',
        });
      }
    } catch (error) {
      const msg = error?.message || String(err);
      setCroppedData(null);

      //   ImagePicker.clean();
      // console.log('Crop error:', msg);
      if (msg === 'User cancelled image selection') {
        setCropError({
          type: 'info',
          text1: 'Crop Crop Cancelled',
          text2: 'Your image was not saved.',
        });
      } else {
        setCropError({
          type: 'error',
          text1: 'Crop failed',
          text2: `Error: ${msg}`,
        });
      }

      ImagePicker.clean();
    } finally {
      setCropView(false);
    }
  };

  return {
    croppedData,
    setCroppedData,
    cropError,
    setCropError,
    cropPhoto,
    cropView,
  };
};


--- FILE: src/screens/Recipe/ImageFunctions/selectPhoto.js ---

//* selectPhoto.js

import React, {useRef, useState} from 'react';
import RNFS from 'react-native-fs';
import ImagePicker from 'react-native-image-crop-picker';

export const useSelectPhoto = () => {
  const [selectedData, setSelectedData] = useState(null);
  const [selectedError, setSelectedError] = useState(null);

  const pickImageFromGallery = async () => {
    ImagePicker.openPicker({
      mediaType: 'photo',
    })
      .then(async image => {
        let finalPath;

        if (image.path) {
          finalPath = image.path.startsWith('file://')
            ? image.path
            : `file://${image.path}`;
        } else if (
          image.sourceURL &&
          image.sourceURL.startsWith('content://')
        ) {
          const destPath = `${RNFS.CachesDirectoryPath}/${Date.now()}.jpg`;
          await RNFS.copyFile(image.sourceURL, destPath);
          finalPath = `file://${destPath}`;
        } else {
          throw new Error('No valid file path from selected image.');
        }

        const sizeKB = (Number(image.size) / 1024).toFixed(2);

        setSelectedData({
          uri: finalPath,
          width: image?.width,
          height: image?.height,
          size: sizeKB,
          type: image?.mime,
        });
      })
      .catch(error => {
        const msg = error?.message || String(err);
        if (msg === 'User cancelled image selection') {
          setSelectedError({
            type: 'info',
            text1: 'Selection cancelled',
            text2: 'No image selected',
          });
        } else {
          setSelectedError({
            type: 'error',
            text1: 'Selection failed',
            text2: msg,
          });
        }
        ImagePicker.clean();
      });
  };
  return {selectedData, selectedError, pickImageFromGallery};
};


--- FILE: src/screens/Recipe/ImageFunctions/takePhoto.js ---

// takePhoto.js
import React, {useRef, useState} from 'react';
import {Platform} from 'react-native';
import RNFS from 'react-native-fs';

export const useTakePhoto = () => {
  const cameraRef = useRef(null);
  const [photoData, setPhotoData] = useState(null);
  const [photoError, setPhotoError] = useState(null);
  const [flashOption, setFlashOption] = useState('auto');

  const generateMediaStorePath = async () => {
    const dir = `${RNFS.PicturesDirectoryPath}/KitchenQueue`;
    const filename = `KQ_${Date.now()}.jpg`;
    const fullPath = `${dir}/${filename}`;

    const exists = await RNFS.exists(dir);
    if (!exists) await RNFS.mkdir(dir);

    return fullPath;
  };

  const takePhoto = async () => {
    if (!cameraRef?.current?.takePhoto) return;

    try {
      const photo = await cameraRef.current.takePhoto({flash: flashOption});

      const src = photo.path.startsWith('file://')
        ? photo.path.replace('file://', '')
        : photo.path;

      const dest =
        Platform.OS === 'ios'
          ? `${RNFS.DocumentDirectoryPath}/KQ_${Date.now()}.jpg`
          : await generateMediaStorePath();

      await RNFS.copyFile(src, dest);

      if (Platform.OS === 'android') {
        try {
          await RNFS.scanFile(dest);
        } catch {}
      }

      const stat = await RNFS.stat(dest);
      const sizeKB = (Number(stat.size) / 1024).toFixed(2);

      setPhotoData({
        uri: `file://${dest}`,
        width: photo.width,
        height: photo.height,
        size: sizeKB,
      });
      setPhotoError(null);
    } catch (error) {
      const msg = error?.message || String(err);
      setPhotoData(null);
      setPhotoError({
        type: 'warning',
        text1: 'Error taking photo.',
        text2: `Error: ${msg}`,
      });
    }
  };

  return {
    cameraRef,
    takePhoto,
    photoData,
    setPhotoData,
    photoError,
    setPhotoError,
    flashOption,
    setFlashOption,
  };
};


--- FILE: src/screens/Recipe/RecipeBox.jsx ---

//* RecipeBox.jsx

import React, {useCallback, useEffect, useMemo, useState} from 'react';
import {Button, Image, Layout, Text, View} from '../../KQ-UI';
import {ListStyles, RecipeSearchStyles} from '../../styles/Styles';
import {useNavigation} from '@react-navigation/native';
import {useDeviceInfo, useProfile, useRecipeBox} from '../../hooks/useHooks';
import {FlashList} from '@shopify/flash-list';
import {StyleSheet, TouchableOpacity} from 'react-native';
import {Icons} from '../../components/IconListRouter';
import {useColors} from '../../KQ-UI/KQUtilities';
import {capEachWord, tempImageString} from '../../utilities/helpers';
import SelectedRecipe from './SelectedRecipe';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';
import KQTempRecipe from '../../svg/KitchenQueueTempRecipe';
// import {deletePicture} from '../../utilities/checkImage';

const RecipeBox = () => {
  const navigation = useNavigation();
  const recipeBox = useRecipeBox();
  const useHaptics = setHapticFeedback();
  const profile = useProfile();
  const recipesList = recipeBox?.items || [];
  const deviceInfo = useDeviceInfo();
  const {view: deviceView, system} = deviceInfo || {};
  const deviceType = system?.device;

  const columnRows = useMemo(() => {
    if (deviceType !== 'Tablet') return 2;

    switch (deviceView) {
      case 'Portrait':
        return 3;
      case 'Landscape':
        return 4;
      default:
        return 2;
    }
  }, [deviceInfo]);

  const handleCreateRecipe = () => {
    navigation.navigate('AddRecipe');
  };

  const [showRecipeInfo, setShowRecipeInfo] = useState(false);
  const [selectedRecipe, setSelectedRecipe] = useState(null);

  const handleSelectedRecipe = item => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
    setShowRecipeInfo(true);
    setSelectedRecipe(item);
  };

  const handleCloseSelectedRecipe = () => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
    setShowRecipeInfo(false);
    setSelectedRecipe(null);
  };

  const [useOneColumn, setUseOneColumn] = useState(false);

  useEffect(() => {
    const hasLongIngredient = selectedRecipe?.ingredients?.some(
      ing => ing?.name?.length > 15,
    );
    setUseOneColumn(hasLongIngredient);
  }, [selectedRecipe]);

  // const deleteFileName = 'uqHTLaneuvSdmAKw8sY20Okfugm2'; // Example filename

  const renderItem = useCallback(({item, index}) => {
    const isLeft = index % 2 === 0;
    return (
      <TouchableOpacity
        onPress={() => handleSelectedRecipe(item)}
        style={styles.itemWrapper(isLeft)}>
        {item.imageUri ? (
          <Image
            key={`${item.id}-${item.imageDate || item.lastUpdated}`}
            image={item.imageUri || tempImageString}
            style={styles.imageListStyles}
          />
        ) : (
          <View style={[styles.imageListStyles, {borderWidth: 1.5}]}>
            <View
              style={{
                ...StyleSheet.absoluteFillObject,
                justifyContent: 'center',
                alignItems: 'center',
                zIndex: 1000,
                pointerEvents: 'none',
                transform: [{rotate: '-35deg'}],
              }}>
              <Text kqColor="dark90" size="small" font="open-7">
                Temp Image
              </Text>
            </View>

            {/* SVG background */}
            <KQTempRecipe
              width="100%"
              height="100%"
              color={useColors('dark30')}
              backgroundColor={useColors('white')}
            />
          </View>
        )}

        <View style={RecipeSearchStyles.listWrapper}>
          <View style={RecipeSearchStyles.listTitle}>
            <Text size="xSmall" numberOfLines={2}>
              {capEachWord(item?.title || '')}
            </Text>
          </View>
          <View style={RecipeSearchStyles.listSubTitleContainer}>
            <View style={RecipeSearchStyles.listReadyIn}>
              <Text size="tiny" font="open-4" kqColor="dark90">
                {item?.readyIn ? `${item.readyIn} min` : ''}
              </Text>
            </View>
            <View style={RecipeSearchStyles.listScoreContainer}>
              <View style={RecipeSearchStyles.listScoreLeft}>
                <Text size="tiny" font="open-4" kqColor="dark90">
                  {item?.ratingScore || ''}
                </Text>
              </View>

              <View style={RecipeSearchStyles.listScoreRight}>
                {!!item?.ratingScore && (
                  <Icons.Star size={12} color={useColors('dark90')} />
                )}
              </View>
            </View>
          </View>
        </View>
      </TouchableOpacity>
    );
  }, []);

  return (
    <Layout
      headerTitle="Recipe Box"
      LeftButton=""
      RightButton="Add"
      LeftAction={null}
      RightAction={handleCreateRecipe}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}>
      <View style={[RecipeSearchStyles.innerLayoutWrapper, {paddingTop: 10}]}>
        {recipesList?.length > 0 ? (
          <View flex>
            <FlashList
              data={recipesList}
              renderItem={renderItem}
              keyExtractor={(item, index) =>
                item?.id ? item.id.toString() : `id-${index}`
              }
              estimatedItemSize={300}
              extraData={recipesList}
              numColumns={columnRows}
            />
          </View>
        ) : (
          <View
            style={[
              ListStyles.viewContainer,
              {justifyContent: 'center', alignItems: 'center'},
            ]}>
            <Text>Recipe Box is Empty</Text>
          </View>
        )}
      </View>
      <SelectedRecipe
        visible={showRecipeInfo}
        selectedRecipe={selectedRecipe}
        recipesList={recipesList}
        useOneColumn={useOneColumn}
        onClose={() => handleCloseSelectedRecipe()}
        recipeBoxView
      />
      {/* {__DEV__ && (
        <Button
          onPress={() => {
            deletePicture(deleteFileName);
          }}>
          Dev cleanup
        </Button>
      )} */}
    </Layout>
  );
};

const styles = {
  itemWrapper: isLeft => ({
    flex: 1,
    marginLeft: isLeft ? 8 : 5,
    marginRight: isLeft ? 5 : 8,
    marginBottom: 20,
  }),
  imageListStyles: {
    borderWidth: 0.5,
    borderRadius: 10,
    borderColor: useColors('dark10'),
    height: 200,
    width: '100%',
    backgroundColor: useColors('white'),
  },
};

export default RecipeBox;


--- FILE: src/screens/Recipe/RecipeSearch.jsx ---

//* RecipeSearch.jsx
import React, {useCallback, useEffect, useMemo, useRef, useState} from 'react';
import {Image, Input, Layout, Text} from '../../KQ-UI';
import {
  useDeviceInfo,
  useRecipeDataLoading,
  useRecipesData,
} from '../../hooks/useHooks';
import {TouchableOpacity, View, ActivityIndicator} from 'react-native';
import {useDispatch} from 'react-redux';
import {FlashList} from '@shopify/flash-list';
import {useColors} from '../../KQ-UI/KQUtilities';

import {Icons} from '../../components/IconListRouter';
import FastImage from 'react-native-fast-image';
import SelectedRecipe from './SelectedRecipe';
import {RecipeSearchStyles} from '../../styles/Styles';
import {useCoreInfo} from '../../utilities/coreInfo';
import {dailyCheckLimit} from '../../utilities/checkLimit';
import {capEachWord} from '../../utilities/helpers';

const RecipeSearch = () => {
  const dispatch = useDispatch();
  const core = useCoreInfo();
  const deviceInfo = useDeviceInfo();
  const {view: deviceView, system} = deviceInfo || {};
  const deviceType = system?.device;

  const columnRows = useMemo(() => {
    if (deviceType !== 'Tablet') return 2;

    switch (deviceView) {
      case 'Portrait':
        return 3;
      case 'Landscape':
        return 4;
      default:
        return 2;
    }
  }, [deviceInfo]);

  const recipesFound = useRecipesData();
  const recipeLoading = useRecipeDataLoading();

  const [storedData, setStoredData] = useState([]);
  const [searchName, setSearchName] = useState('');
  const [searchCreated, setSearchCreated] = useState(true);
  const [showRecipeInfo, setShowRecipeInfo] = useState(false);
  const [selectedRecipe, setSelectedRecipe] = useState(null);

  useEffect(() => {
    if (recipesFound?.length === 0) {
      setSearchCreated(false); //
    }

    if (
      recipesFound &&
      Array.isArray(recipesFound) &&
      recipesFound.length > 0
    ) {
      const sorted = [...recipesFound].sort(
        (a, b) => (b.ratingScore ?? 0) - (a.ratingScore ?? 0),
      );
      setStoredData(sorted);
    }
  }, [recipesFound]);

  const lastSearch = useRef('');
  const counterRef = useRef(core?.dailyRecipeCounter || 0);

  useEffect(() => {
    if (core?.dailyRecipeCounter !== undefined) {
      counterRef.current = core.dailyRecipeCounter;
    }
  }, [core?.dailyRecipeCounter]);

  const handleSearch = useCallback(() => {
    const term = searchName.trim();
    if (
      !term ||
      term.length < 2 ||
      term.toLowerCase() === lastSearch.current.toLowerCase()
    )
      return;

    lastSearch.current = term.toLowerCase();

    if (counterRef.current < core?.maxRecipeSearchLimit) {
      dispatch({
        type: 'FETCH_COMMUNITY_RECIPES',
        payload: {
          keywords: term,
          allowance: core?.dailyRecipeCounter,
          profileID: core?.profileID,
          accountID: core?.accountID,
        },
      });
    } else {
      dailyCheckLimit({
        current: counterRef.current,
        max: core?.maxRecipeSearchLimit,
        label: 'Recipe',
      });
    }

    setSearchCreated(true);
  }, [searchName, dispatch]);

  useEffect(() => {
    if (storedData.length) {
      FastImage.preload(
        storedData.map(r => ({
          uri: `https://firebasestorage.googleapis.com/v0/b/kitchen-queue-fe2fe.firebasestorage.app/o/recipes%2F${encodeURIComponent(
            r.image,
          )}?alt=media`,
        })),
      );
    }
  }, [storedData]);

  useEffect(() => {
    return () => {
      setStoredData([]);
      lastSearch.current = '';
      setSearchCreated(false);
    };
  }, []);

  const handleClear = () => {
    FastImage.clearMemoryCache();
    FastImage.clearDiskCache();
    setSearchName('');
    setSearchCreated(false);
    setStoredData([]);
    lastSearch.current = '';
    dispatch({type: 'RESET_COMMUNITY_RECIPES'});
  };

  const handleSelectedRecipe = item => {
    setShowRecipeInfo(true);
    setSelectedRecipe(item);
  };

  const handleCloseSelectedRecipe = () => {
    setShowRecipeInfo(false);
    setSelectedRecipe(null);
  };

  const [useOneColumn, setUseOneColumn] = useState(false);

  useEffect(() => {
    const hasLongIngredient = selectedRecipe?.ingredients?.some(
      ing => ing?.name?.length > 15,
    );
    setUseOneColumn(hasLongIngredient);
  }, [selectedRecipe]);
  // --- End

  const renderItem = useCallback(({item, index}) => {
    const isLeft = index % 2 === 0;
    return (
      <TouchableOpacity
        onPress={() => handleSelectedRecipe(item)}
        style={styles.itemWrapper(isLeft)}>
        {item.imageUri ? (
          <Image
            key={`${item.id}-${item.imageDate || item.lastUpdated}`}
            image={item.imageUri || tempImageString}
            style={styles.imageListStyles}
          />
        ) : (
          <View style={[styles.imageListStyles, {borderWidth: 1.5}]}>
            <View
              style={{
                ...StyleSheet.absoluteFillObject,
                justifyContent: 'center',
                alignItems: 'center',
                zIndex: 1000,
                pointerEvents: 'none',
                transform: [{rotate: '-35deg'}],
              }}>
              <Text kqColor="dark90" size="small" font="open-7">
                Temp Image
              </Text>
            </View>

            {/* SVG background */}
            <KQTempRecipe
              width="100%"
              height="100%"
              color={useColors('dark30')}
              backgroundColor={useColors('white')}
            />
          </View>
        )}

        <View style={RecipeSearchStyles.listWrapper}>
          <View style={RecipeSearchStyles.listTitle}>
            <Text size="xSmall" numberOfLines={2}>
              {capEachWord(item?.title || '')}
            </Text>
          </View>
          <View style={RecipeSearchStyles.listSubTitleContainer}>
            <View style={RecipeSearchStyles.listReadyIn}>
              <Text size="tiny" font="open-4" kqColor="dark90">
                {item?.readyIn ? `${item.readyIn} min` : ''}
              </Text>
            </View>
            <View style={RecipeSearchStyles.listScoreContainer}>
              <View style={RecipeSearchStyles.listScoreLeft}>
                <Text size="tiny" font="open-4" kqColor="dark90">
                  {item?.ratingScore || ''}
                </Text>
              </View>

              <View style={RecipeSearchStyles.listScoreRight}>
                {!!item?.ratingScore && (
                  <Icons.Star size={12} color={useColors('dark90')} />
                )}
              </View>
            </View>
          </View>
        </View>
      </TouchableOpacity>
    );
  }, []);

  const RecipesFound = useMemo(() => {
    if (searchCreated && !recipeLoading) {
      if (storedData?.length > 0) {
        return (
          <Text centered size="tiny" kqColor="dark70">
            Recipes Found: {storedData?.length || 0}
          </Text>
        );
      } else {
        return (
          <Text centered size="tiny" kqColor="dark70">
            No Recipes Found
          </Text>
        );
      }
    } else {
      return null;
    }
  }, [storedData, searchCreated, recipeLoading]);

  return (
    <Layout
      headerTitle="Recipe Search"
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 5}}
      innerViewStyles={{}}>
      <View style={RecipeSearchStyles.innerLayoutWrapper}>
        <View style={{flex: 1}}>
          <View style={RecipeSearchStyles.inputWrapper}>
            <View style={{flex: 1}}>
              <Input
                placeholder="Search Recipes"
                value={searchName}
                onChangeText={setSearchName}
                capitalize
                capitalMode="words"
                returnKeyType="search"
                onSubmitEditing={handleSearch}
                wrapperStyles={RecipeSearchStyles.wrapperStyles}
                accessoryRight={() => (
                  <TouchableOpacity
                    onPress={handleSearch}
                    style={RecipeSearchStyles.iconStyles}>
                    <Icons.Search size={25} color={useColors('dark50')} />
                  </TouchableOpacity>
                )}
              />
            </View>
            <View>
              <View style={RecipeSearchStyles.clearButtonWrapper}>
                <TouchableOpacity
                  disabled={storedData?.length <= 0}
                  style={RecipeSearchStyles.clearButton}
                  onPress={() => handleClear()}>
                  <Icons.XCircle
                    size={30}
                    color={
                      storedData?.length <= 0
                        ? useColors('dark30')
                        : useColors('orange')
                    }
                  />
                </TouchableOpacity>
              </View>
            </View>
          </View>
          <View
            style={{
              marginBottom: 10,
              borderColor: useColors('dark30'),
            }}>
            {RecipesFound}
          </View>
          <View style={{flex: 1}}>
            {recipeLoading ? (
              <View style={RecipeSearchStyles.loadingWrapper}>
                <View style={RecipeSearchStyles.loadingContainer}>
                  <ActivityIndicator size="large" color="#29856c" />
                </View>
                <View style={RecipeSearchStyles.loadingText}>
                  <Text size="small">Searching...</Text>
                </View>
              </View>
            ) : (
              <FlashList
                data={storedData}
                renderItem={renderItem}
                keyExtractor={(item, index) =>
                  item?.id ? item.id.toString() : `id-${index}`
                }
                estimatedItemSize={300}
                extraData={renderItem}
                numColumns={columnRows}
              />
            )}
          </View>
        </View>
      </View>
      <SelectedRecipe
        visible={showRecipeInfo}
        selectedRecipe={selectedRecipe}
        useOneColumn={useOneColumn}
        onClose={() => handleCloseSelectedRecipe()}
      />
    </Layout>
  );
};

const styles = {
  itemWrapper: isLeft => ({
    flex: 1,
    marginLeft: isLeft ? 8 : 5,
    marginRight: isLeft ? 5 : 8,
    marginBottom: 20,
  }),
  imageListStyles: {
    borderWidth: 0.5,
    borderRadius: 10,
    borderColor: useColors('dark10'),
    height: 200,
    width: '100%',
    backgroundColor: useColors('white'),
  },
};

export default RecipeSearch;


--- FILE: src/screens/Recipe/SelectedRecipe.jsx ---

//* SelectedRecips.jsx

import React, {useMemo, useState} from 'react';
import {
  ActionSheetIOS,
  Alert,
  Platform,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import {Modal, Text, Image, View} from '../../KQ-UI';
import {Icons} from '../../components/IconListRouter';
import {useColors} from '../../KQ-UI/KQUtilities';
import {
  capEachWord,
  endWithPeriod,
  formatParagraph,
} from '../../utilities/helpers';
import {toFraction} from '../../utilities/fractionUnit';
import {formatPluralUnit} from '../../utilities/formatPluralUnit';
import {SelectedRecipeStyles} from '../../styles/Styles';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';
import {useProfile, useRecipeBox} from '../../hooks/useHooks';
import {useCoreInfo} from '../../utilities/coreInfo';
import {useDispatch} from 'react-redux';
import {useNavigation} from '@react-navigation/native';
import KQTempRecipe from '../../svg/KitchenQueueTempRecipe';

const SelectedRecipe = ({
  selectedRecipe,
  visible,
  useOneColumn,
  recipeBoxView,
  onClose,
}) => {
  const useHaptics = setHapticFeedback();
  const dispatch = useDispatch();
  const navigation = useNavigation();
  const coreInfo = useCoreInfo();
  // console.log('coreInfo:', coreInfo);

  const profile = useProfile();
  // console.log('profile:', profile);
  const recipeBox = useRecipeBox();
  const recipesListIDs = recipeBox?.items?.map(rec => rec?.id) || [];
  const [isProcessing, setIsProcessing] = useState(false);

  const isBookmarked = useMemo(() => {
    return recipesListIDs.includes(selectedRecipe?.id);
  }, [recipesListIDs, selectedRecipe]);

  const [showAboutRecipe, setShowAboutRecipe] = useState(false);

  const SectionHead = ({title, value, style}) => {
    if (value) {
      return (
        <View style={[SelectedRecipeStyles.sectionWrapper, {...style}]}>
          <View style={SelectedRecipeStyles.sectionEnd} />
          <View style={SelectedRecipeStyles.sectionTitle}>
            <Text size="xSmall" numberOfLines={1} font="open-7">
              {title}:
            </Text>
          </View>
          <View style={SelectedRecipeStyles.sectionEnd} />
        </View>
      );
    }
    return null;
  };

  const handleShowOptions = () => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
    if (Platform.OS === 'ios') {
      ActionSheetIOS.showActionSheetWithOptions(
        {
          options: ['Cancel', 'Edit', 'Delete'],
          destructiveButtonIndex: 2, // Delete in red
          cancelButtonIndex: 0,
        },
        buttonIndex => {
          if (buttonIndex === 1) handleEditRec?.(selectedRecipe);
          if (buttonIndex === 2) handleDeleteRec?.(selectedRecipe);
        },
      );
    } else {
      Alert.alert(
        'More Options',
        'Choose an option below:',
        [
          {text: 'Cancel', style: 'cancel'},
          {text: 'Edit', onPress: () => handleEditRec?.(selectedRecipe)},
          {
            text: 'Delete',
            style: 'destructive',
            onPress: () => handleDeleteRec?.(selectedRecipe),
          },
        ],
        {cancelable: true},
      );
    }
  };

  const handleRequestEditDelete = () => {};

  const handleEditRec = () => {
    onClose();
    navigation.navigate('EditRecipe', {
      recipeToEdit: selectedRecipe,
      editingRecipe: true,
      fromCommunity: recipeBoxView ? false : true,
    });
  };

  const handleShareRec = () => {
    // console.log('Share recipe', selectedRecipe?.title);
  };

  const handleDeleteRec = () => {
    Alert.alert(
      'Delete Recipe',
      'Are you sure you want to delete this recipe?',
      [
        {text: 'Cancel', style: 'cancel'},
        {
          text: 'Delete',
          style: 'destructive',
          onPress: () => {
            onClose();
            if (recipeBoxView) {
              dispatch({
                type: 'DELETE_ITEM_FROM_RECIPE_BOX',
                payload: {
                  recipeBoxID: coreInfo?.recipeBoxID,
                  selectedRecipe: selectedRecipe,
                  profileID: coreInfo?.userID,
                  owner: selectedRecipe?.accountID === coreInfo?.accountID,
                },
              });
            } else {
              dispatch({
                type: 'DELETE_FROM_COMMUNITY_RECIPES',
                payload: {
                  recipeBoxID: coreInfo?.recipeBoxID,
                  selectedRecipe: selectedRecipe,
                  profileID: coreInfo?.userID,
                  owner: selectedRecipe?.accountID === coreInfo?.accountID,
                },
              });
            }
          },
        },
      ],
    );
  };

  const handleAddBM = () => {
    if (isProcessing) return;
    setIsProcessing(true);

    onClose();
    dispatch({
      type: 'BOOKMARK_TO_RECIPE_BOX',
      payload: {
        recipeBoxID: coreInfo?.recipeBoxID,
        selectedRecipe: selectedRecipe,
        profileID: coreInfo?.userID,
      },
    });
    setTimeout(() => setIsProcessing(false), 500);
  };

  const handleRemoveBM = () => {
    if (isProcessing) return;
    setIsProcessing(true);
    onClose();
    dispatch({
      type: 'DELETE_ITEM_FROM_RECIPE_BOX',
      payload: {
        recipeBoxID: coreInfo?.recipeBoxID,
        selectedRecipe: selectedRecipe,
        profileID: coreInfo?.userID,
        owner: selectedRecipe?.accountID === coreInfo?.accountID,
      },
    });
    setTimeout(() => setIsProcessing(false), 500);
  };

  const handleAdminEditRecipe = () => {};
  const handleAdminDeleteRecipe = () => {};

  const renderButtons = useMemo(() => {
    const admin = coreInfo?.admin;
    const btAccount = selectedRecipe?.accountID === coreInfo?.accountID; // belongs to account
    const btAuthor = selectedRecipe?.authorID === coreInfo?.userID; // belongs to author
    const bookmarked = isBookmarked;

    if (selectedRecipe === null) return null;

    console.log('selectedRecipe:', selectedRecipe);
    // console.log('recipeBoxView:', recipeBoxView);

    // 1. Recipe Box View
    if (recipeBoxView) {
    }

    // 2. Community / Search View
    if (!recipeBoxView) {
    }

    // // 1. Recipe Box View
    if (recipeBoxView) {
      if (btAccount) {
        // Account owns this recipe → edit/delete/share
        return (
          <>
            <TouchableOpacity
              style={SelectedRecipeStyles.selectedTRButton}
              onPress={handleShowOptions}>
              <Icons.Options size={25} color={useColors('white')} />
            </TouchableOpacity>
            <TouchableOpacity
              style={SelectedRecipeStyles.selectedBRButton}
              onPress={handleShareRec}>
              <View style={{position: 'relative', top: -2}}>
                <Icons.Share size={25} color={useColors('white')} />
              </View>
            </TouchableOpacity>
          </>
        );
      } else {
        // Not account owner → just bookmark toggle
        return (
          <TouchableOpacity
            style={SelectedRecipeStyles.selectedTRButton}
            onPress={bookmarked ? handleRemoveBM : handleAddBM}>
            {bookmarked ? (
              <Icons.BookmarkMinus size={25} color={useColors('white')} />
            ) : (
              <Icons.BookmarkPlus size={25} color={useColors('white')} />
            )}
          </TouchableOpacity>
        );
      }
    }

    // // 2. Community / Search View
    if (!recipeBoxView) {
      if (btAuthor) {
        // Author of recipe → request edit/delete
        return (
          <>
            <TouchableOpacity
              style={SelectedRecipeStyles.selectedBRButton}
              onPress={handleRequestEditDelete}>
              <Icons.Account size={25} color={useColors('white')} />
            </TouchableOpacity>
            {admin && (
              <TouchableOpacity
                style={SelectedRecipeStyles.selectedBLButton}
                onPress={handleShowOptions}>
                <Icons.AdminEdit size={25} color={useColors('white')} />
              </TouchableOpacity>
            )}
            <TouchableOpacity
              style={SelectedRecipeStyles.selectedTRButton}
              onPress={bookmarked ? handleRemoveBM : handleAddBM}>
              {bookmarked ? (
                <Icons.BookmarkMinus size={25} color={useColors('white')} />
              ) : (
                <Icons.BookmarkPlus size={25} color={useColors('white')} />
              )}
            </TouchableOpacity>
          </>
        );
      } else {
        // Not author → just bookmark toggle
        return (
          <>
            <TouchableOpacity
              style={SelectedRecipeStyles.selectedTRButton}
              onPress={bookmarked ? handleRemoveBM : handleAddBM}>
              {bookmarked ? (
                <Icons.BookmarkMinus size={25} color={useColors('white')} />
              ) : (
                <Icons.BookmarkPlus size={25} color={useColors('white')} />
              )}
            </TouchableOpacity>
            {admin && (
              <TouchableOpacity
                style={SelectedRecipeStyles.selectedBLButton}
                onPress={handleShowOptions}>
                <Icons.AdminEdit size={25} color={useColors('white')} />
              </TouchableOpacity>
            )}
          </>
        );
      }
    }

    // return null;
  }, [coreInfo, selectedRecipe, isBookmarked, recipeBoxView]);

  return (
    <Modal
      visible={visible}
      title={capEachWord(selectedRecipe?.title)}
      headerFont="open-6"
      headerSize="small"
      height="99.5%"
      width="96%"
      hideClose
      headerColor="orange"
      onClose={onClose}>
      <View style={{borderBottomWidth: 1, borderColor: useColors('dark10')}}>
        {selectedRecipe?.imageUri ? (
          <Image
            image={selectedRecipe?.imageUri}
            style={SelectedRecipeStyles.imageSelectedStyles}
          />
        ) : (
          <View style={[SelectedRecipeStyles.imageSelectedStyles]}>
            <View
              style={{
                ...StyleSheet.absoluteFillObject,
                justifyContent: 'center',
                alignItems: 'center',
                zIndex: 1000,
                pointerEvents: 'none',
                transform: [{rotate: '-35deg'}],
              }}>
              <Text kqColor="dark90" size="small" font="open-7">
                Temp Image
              </Text>
            </View>
            <KQTempRecipe
              width={'100%'}
              height={200}
              color={useColors('dark30')}
              backgroundColor={useColors('white')}
            />
          </View>
        )}
      </View>

      <TouchableOpacity
        style={SelectedRecipeStyles.selectedCloseButton}
        onPress={onClose}>
        <Icons.Close size={25} color={useColors('white')} />
      </TouchableOpacity>

      {renderButtons}

      <View style={SelectedRecipeStyles.selectedViewWrapper} ph5>
        {/* {!recipeBoxView && (
          <Text size="tiny" centered font="open-7" kqColor="dark90">
            {providedBy}
          </Text>
        )} */}
        <ScrollView>
          {!recipeBoxView &&
            selectedRecipe?.publicAuthor &&
            selectedRecipe?.aboutRecipe && (
              <>
                <View style={SelectedRecipeStyles.aboutRecipe}>
                  <Text size="xSmall" font="open-7">
                    About this Recipe:
                  </Text>
                  <Text
                    size="tiny"
                    font="open-6"
                    numberOfLines={showAboutRecipe ? 10 : 1}>
                    {endWithPeriod(selectedRecipe?.aboutRecipe)}
                  </Text>
                </View>
                <TouchableOpacity
                  style={SelectedRecipeStyles.aboutRecipeButton}
                  onPress={() => setShowAboutRecipe(!showAboutRecipe)}>
                  <Text size="tiny" font="open-5" kqColor="rgb(56, 71, 234)">
                    {showAboutRecipe ? 'Show Less' : 'Show More'}
                  </Text>
                </TouchableOpacity>
              </>
            )}

          <SectionHead
            title="Ingredients"
            value={selectedRecipe?.ingredients?.length > 0}
            style={{
              marginTop: recipeBoxView
                ? 10
                : selectedRecipe?.publicAuthor
                ? 5
                : 10,
            }}
          />
          <View style={SelectedRecipeStyles.ingWrapper}>
            {selectedRecipe?.ingredients?.map((ing, index) => (
              <View
                key={index}
                style={
                  useOneColumn
                    ? SelectedRecipeStyles.ingColOne
                    : SelectedRecipeStyles.ingColTwo
                }>
                <View row>
                  <View style={SelectedRecipeStyles.ingDot}>
                    <Icons.Dot size={4} />
                  </View>
                  <View flex>
                    <Text size="xSmall" font="open-7" numberOfLines={3}>
                      {(() => {
                        if (ing.amount != null) {
                          const pluralUnit = formatPluralUnit(
                            ing.amount,
                            ing.unit,
                          );
                          return `${toFraction(ing.amount)}${
                            pluralUnit ? ` ${pluralUnit}` : ''
                          } `;
                        }
                        return '';
                      })()}
                      {capEachWord(ing.name)}
                    </Text>
                  </View>
                </View>
              </View>
            ))}
          </View>
          <SectionHead
            title="Instructions"
            value={selectedRecipe?.instructions?.length > 0}
          />
          <View m={5} mb={10}>
            {Array.isArray(selectedRecipe?.instructions) &&
              selectedRecipe.instructions.length > 0 &&
              selectedRecipe.instructions.map((group, gIndex) => (
                <View key={`group-${gIndex}`} mb={25}>
                  {group.name ? (
                    <View pl={10} pb={2}>
                      <Text size="small" font="open-7">
                        {capEachWord(group.name)}
                      </Text>
                    </View>
                  ) : null}
                  {group.steps.map((ins, sIndex) => (
                    <View
                      key={`${gIndex}-${sIndex}`}
                      style={SelectedRecipeStyles.stepWrapper}>
                      <View style={SelectedRecipeStyles.stepNumber}>
                        <Text size="xSmall" font="open-7">
                          Step {ins.step + 1}:
                        </Text>
                      </View>
                      <View style={SelectedRecipeStyles.stepText}>
                        <Text size="xSmall">{formatParagraph(ins.action)}</Text>
                      </View>
                    </View>
                  ))}
                </View>
              ))}
          </View>
        </ScrollView>
      </View>
    </Modal>
  );
};

export default __DEV__ ? SelectedRecipe : React.memo(SelectedRecipe);


--- FILE: src/screens/Recipe/UploadPicture.jsx ---

//* UploadPicture.jsx

import React, {useEffect, useMemo, useState} from 'react';
import {Button, Text, View} from '../../KQ-UI';
import {Camera, useCameraDevice} from 'react-native-vision-camera';
import FastImage from 'react-native-fast-image';
import {TouchableOpacity} from 'react-native';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';
import {useDeviceInfo, useProfile} from '../../hooks/useHooks';
import {useColors, useFontSizes} from '../../KQ-UI/KQUtilities';
import {Icons} from '../../components/IconListRouter';
import {capFirst} from '../../utilities/helpers';
import Toast from 'react-native-toast-message';
import {useTakePhoto} from './ImageFunctions/takePhoto';
import {useCropPhoto} from './ImageFunctions/cropPhoto';
import {UploadPictureStyles} from '../../styles/Styles';
import {useSelectPhoto} from './ImageFunctions/selectPhoto';

const UploadPicture = props => {
  const profile = useProfile();
  const useHaptics = setHapticFeedback();
  const deviceInfo = useDeviceInfo();
  const buttonWidth = deviceInfo?.dimensions?.width / 6;

  const {
    handleCloseUploadPicture,
    cameraStyles,
    pictureName,
    finalImage,
    setFinalImage,
  } = props;

  const {
    cameraRef,
    takePhoto,
    photoData,
    photoError,
    flashOption,
    setFlashOption,
  } = useTakePhoto();

  const {selectedData, selectedError, pickImageFromGallery} = useSelectPhoto();
  const {croppedData, cropError, cropPhoto, cropView} = useCropPhoto();
  const [cameraActive, setCameraActive] = useState(false);
  const [tempImage, setTempImage] = useState(null);
  const [screenView, setScreenView] = useState('action');
  const [isCropping, setIsCropping] = useState(false);

  const toastProps = {
    fontSize1: useFontSizes('small')?.fontSize,
    fontSize2: useFontSizes('xSmall')?.fontSize,
  };

  const toggleFlash = () => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
    setFlashOption(prev => {
      if (prev === 'off') return 'on';
      if (prev === 'on') return 'auto';
      return 'off';
    });
  };

  useEffect(() => {
    return () => {
      setCameraActive(false);
    };
  }, []);

  useEffect(() => {
    if (screenView === 'crop' && tempImage?.uri && !isCropping && !cropView) {
      setIsCropping(true);
      cropPhoto(tempImage, pictureName);
    }
    if (croppedData) {
      setFinalImage(croppedData);
      setScreenView('final');
      setIsCropping(false);
    }
    if (cropError) {
      handleCloseUploadPicture();
      setScreenView('action');
      setIsCropping(false);

      Toast.show({
        type: cropError?.type || 'error',
        text1: cropError?.text1 || 'Crop Error',
        text2:
          cropError?.text2 || 'An error occurred while cropping the image.',
        props: toastProps,
      });
    }
  }, [
    screenView,
    tempImage?.uri,
    isCropping,
    cropView,
    croppedData,
    cropError,
  ]);

  const flashColor = useMemo(() => {
    if (flashOption === 'on') return 'success';
    if (flashOption === 'off') return 'danger';
    return 'info';
  }, [flashOption]);

  const device = useCameraDevice('back', {
    physicalDevices: [
      'ultra-wide-angle-camera',
      'wide-angle-camera',
      'telephoto-camera',
    ],
  });

  useEffect(() => {
    const imageSource = photoData || selectedData;
    const errorSource = photoError || selectedError;

    if (imageSource) {
      setTempImage(imageSource);
      setScreenView('crop');
    }

    if (errorSource) {
      handleCloseUploadPicture();
      setScreenView('action');
      setTempImage(null);
      setFinalImage(null);
      Toast.show({
        type: errorSource.type || 'error',
        text1: errorSource.text1,
        text2: errorSource.text2,
        props: toastProps,
      });
    }
  }, [photoData, photoError, selectedData, selectedError]);

  const handleOnPress = pressType => {
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
    if (pressType === 'cameraUpload') {
      setCameraActive(true);
      setScreenView(pressType);
    }
    if (pressType === 'storageUpload') {
      pickImageFromGallery(pictureName);
      setScreenView('crop');
    }
    if (pressType === 'takePhoto') {
      takePhoto(flashOption);
    }
    if (pressType === 'cancelPhoto') {
      setCameraActive(false);
      setScreenView('action');
      setTempImage(null);
    }
    if (pressType === 'finalize') {
      if (!pictureName) {
        Toast.show({
          type: 'error',
          text1: 'Missing name',
          text2: 'Add a recipe name first.',
          props: toastProps,
        });
        return;
      }
      handleCloseUploadPicture();
    }
  };

  const UploadActionButton = ({action, icon, label}) => (
    <TouchableOpacity
      style={UploadPictureStyles.button}
      onPress={() => handleOnPress(action)}>
      <View column flex>
        <View flex={1.25} pb={2.5} centerH bottomAlign>
          {icon}
        </View>
        <View flex pt={2.5} centerH>
          <Text centered size="small">
            {label}
          </Text>
        </View>
      </View>
    </TouchableOpacity>
  );

  if (screenView === 'action') {
    return (
      <View ph5 flex>
        <View mt5 mb15>
          <Text centered>Choose an Action</Text>
        </View>
        <View row>
          <View flex>
            <UploadActionButton
              action="storageUpload"
              icon={<Icons.Upload size={30} color={useColors('dark70')} />}
              label="Upload Image"
            />
          </View>
          <View flex>
            <UploadActionButton
              action="cameraUpload"
              icon={<Icons.Camera size={30} color={useColors('dark70')} />}
              label="Take Photo"
            />
          </View>
        </View>
        {finalImage && (
          <View flex mt25>
            <Text centered size="small" italic>
              Image Found: Preview
            </Text>
            <View style={UploadPictureStyles.finalizedWrapper} mt10>
              <FastImage
                style={{width: '100%', height: '100%', index: 2000}}
                source={{
                  uri: finalImage?.uri,
                  priority: FastImage.priority.normal,
                  cache: FastImage.cacheControl.immutable,
                }}
                resizeMode={FastImage.resizeMode.cover}
              />
            </View>
          </View>
        )}
      </View>
    );
  }

  if (screenView === 'cameraUpload') {
    if (!device) {
      return (
        <View flex centerVH style={{backgroundColor: 'white'}}>
          <Text>No Camera Found</Text>
        </View>
      );
    }
    return (
      <View style={UploadPictureStyles.cameraWrapper}>
        <View flex>
          <Camera
            ref={cameraRef}
            style={[{flex: 1, zIndex: 1}, cameraStyles]}
            device={device}
            isActive={cameraActive}
            photo={true}
            autoFocus="on"
            frameColor="white"
            zoom={1.5}
            enableZoomGesture={false}
            enableShutterSound={true}
          />
        </View>
        <View row style={UploadPictureStyles.btWrapper}>
          <View flex mh20 row>
            <View mh5>
              <Text kqColor="white" size="small" font="open-7">
                Flash:
              </Text>
            </View>
            <View>
              <TouchableOpacity onPress={toggleFlash}>
                <Text kqColor={flashColor} size="small" font="open-7">
                  {capFirst(flashOption)}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
          <View flex rightAlign mh15>
            <TouchableOpacity onPress={() => handleOnPress('cancelPhoto')}>
              <Icons.XCircleOutline size={25} color={useColors('white')} />
            </TouchableOpacity>
          </View>
        </View>
        <View row style={UploadPictureStyles.bbWrapper}>
          <View flex />
          <View centerVH>
            <TouchableOpacity
              onPress={() => handleOnPress('takePhoto')}
              style={UploadPictureStyles.cameraButton(buttonWidth)}>
              <View flex style={UploadPictureStyles.redDot} />
            </TouchableOpacity>
          </View>
          <View flex />
        </View>
      </View>
    );
  }

  if (screenView === 'crop' && tempImage) {
    return (
      <View flex centerVH>
        <Text centered italic size="xSmall">
          Loading Crop Screen, Please Wait
        </Text>
      </View>
    );
  }

  if (screenView === 'final' && finalImage) {
    return (
      <View flex>
        <View style={UploadPictureStyles.previewWrapper}>
          <FastImage
            style={{width: '100%', height: '100%', index: 2000}}
            source={{
              uri: finalImage?.uri,
              priority: FastImage.priority.normal,
              cache: FastImage.cacheControl.immutable,
            }}
            resizeMode={FastImage.resizeMode.cover}
          />
        </View>
        <View mt15>
          <Button
            type="outline"
            onPress={() => {
              setScreenView('crop');
            }}>
            Reset
          </Button>
        </View>
        <View mt5>
          <Button onPress={() => handleOnPress('finalize')}>Done</Button>
        </View>
      </View>
    );
  }
};

export default UploadPicture;


--- FILE: src/screens/Shopping/ShoppingCart.jsx ---

//* ShoppingCart.jsx
import React, {useCallback, useEffect, useState} from 'react';
import {useFocusEffect, useNavigation} from '@react-navigation/native';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useAccount, useShoppingCart} from '../../hooks/useHooks';
import {Alert, View} from 'react-native';
import {ListStyles} from '../../styles/Styles';
import SwipeableItem from '../../components/SwipeableItem';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';
import SelectedItemInfo from '../../components/SelectedItemInfo';

const ShoppingCart = () => {
  const core = useCoreInfo();
  const account = useAccount();
  const shopping = useShoppingCart();
  const navigation = useNavigation();
  const dispatch = useDispatch();

  const [refreshFlag, setRefreshFlag] = useState(false);

  useFocusEffect(
    useCallback(() => {
      setRefreshFlag(prev => !prev);
    }, [shopping?.items]),
  );

  const shoppingCart = Array.isArray(shopping?.items)
    ? shopping.items.filter(item => item.status === 'shopping-cart')
    : [];

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  useEffect(() => {
    if (showItemInfo === false) {
      setSelectedItem(null);
    }
  }, [showItemInfo]);

  const handleReturnToList = useCallback(
    itemId => {
      const item =
        selectedItem?.itemId === itemId
          ? selectedItem
          : shoppingCart.find(item => item.itemId === itemId);

      if (item && core.profileID) {
        const updatedItem = {
          ...item,
          status: 'shopping-list',
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: core.profileID,
        };
        dispatch({
          type: 'UPDATE_ITEM_IN_SHOP_CART',
          payload: {
            shoppingCartID: core.shoppingCartID,
            updatedItem,
            profileID: core.profileID,
            updateType: 'toList',
          },
        });
      }
    },
    [dispatch, core, shoppingCart],
  );

  const handleUpdateItem = itemId => {
    navigation.navigate('ShoppingItems', {
      title: 'Update Item',
      itemId,
      navigateBackTo: 'ShoppingCart',
      statusTo: 'shopping-cart',
    });
  };

  const handleDeleteItem = useCallback(
    itemId => {
      if (core.profileID) {
        const item = shoppingCart.find(item => item.itemId === itemId);
        if (item) {
          dispatch({
            type: 'DELETE_ITEM_FROM_SHOP_CART',
            payload: {
              shoppingCartID: core.shoppingCartID,
              itemId: item.itemId,
              itemName: item.itemName,
              profileID: core.profileID,
            },
          });
        }
      }
    },
    [dispatch, core, shoppingCart],
  );

  const handleAddToFavorites = itemId => {
    const latestItem = shopping?.items?.find(i => i.itemId === itemId);

    const newItem = {
      itemName: latestItem?.itemName || '',
      brandName: latestItem?.brandName || '',
      description: latestItem?.description || '',
      packageSize: Number(latestItem?.packageSize),
      measurement: latestItem?.measurement || '',
      category: latestItem?.category || '',
      notes: latestItem?.notes || '',
    };

    dispatch({
      type: 'ADD_ITEM_TO_FAVORITES',
      payload: {
        favoriteItemsID: core.favoriteItemsID,
        newItem: newItem,
        profileID: core.profileID,
      },
    });
  };

  const AddToCupboard = () => {
    if (shoppingCart?.length > 0) {
      Alert.alert(
        'Confirm Checkout',
        'Are you ready to move your shopping cart items to your cupboard?',
        [
          {
            text: 'Cancel',
            style: 'destructive',
          },
          {
            text: 'Confirm',
            onPress: () => {
              dispatch({
                type: 'BATCH_TO_CUPBOARD',
                payload: {
                  cupboardID: core?.cupboardID,
                  items: shoppingCart,
                  profileID: core?.profileID,
                },
              });

              navigation.navigate('CupboardList-Single');
            },
          },
        ],
      );
    }
  };

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
        navigate={{to: 'ShoppingItems', backTo: 'ShoppingCart'}}
      />
    </BottomSheet>
  );

  return (
    <Layout
      headerTitle="Shopping Cart"
      LeftButton="To-List"
      RightButton="Checkout"
      LeftAction={null}
      RightAction={AddToCupboard}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}>
      {shoppingCart.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Shopping List is Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            key={refreshFlag}
            list={shoppingCart}
            core={core}
            showItemInfo={showItemInfo}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            rightButtons={[
              {
                action: itemId => handleReturnToList(itemId),
                text1: 'Return',
                text2: 'to List',
                style: ListStyles.addButton,
              },
              {
                action: itemId => handleUpdateItem(itemId),
                navigateBackTo: 'InCart',
                text1: 'Update',
                text2: 'Item',
                style: ListStyles.updateButton,
              },
              {
                action: itemId => handleDeleteItem(itemId),
                text1: 'Delete',
                style: ListStyles.deleteButton,
              },
            ]}
            leftButtons={[
              {
                action: itemId => handleAddToFavorites(itemId),
                starIcon: true,
                style: ListStyles.favButton,
              },
            ]}
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default ShoppingCart;


--- FILE: src/screens/Shopping/ShoppingItems.jsx ---

//* ShoppingItems.jsx

import {
  useFocusEffect,
  useNavigation,
  useRoute,
} from '@react-navigation/native';
import React, {useCallback, useEffect, useState} from 'react';
import {
  Button,
  Camera,
  Dropdown,
  Input,
  Layout,
  Modal,
  ScrollView,
  Text,
} from '../../KQ-UI';
import {
  useDeviceInfo,
  useFoodData,
  useFoodDataError,
  useShoppingCart,
} from '../../hooks/useHooks';
import {displayMeasurements} from '../../utilities/measurements';
import {displayCategories} from '../../utilities/categories';
import {
  displayDropField,
  setNumericValue,
  titleCase,
} from '../../utilities/helpers';
import {View, Image, TouchableOpacity} from 'react-native';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';
import useBarcodeScanner from '../../hooks/useBarcodeScanner';
import {ListStyles} from '../../styles/Styles';
import EdamamAttribution from '../../components/EdamanBadge';
import Toast from 'react-native-toast-message';
import {transformNutritionFacts} from '../../utilities/transformNutritionFacts';
import {formatPluralUnit} from '../../utilities/formatPluralUnit';
import {useColors} from '../../KQ-UI/KQUtilities';
import {dailyCheckLimit} from '../../utilities/checkLimit';

const ShoppingItems = () => {
  const route = useRoute();
  const {itemId, statusTo} = route.params || {};

  const dispatch = useDispatch();
  const core = useCoreInfo();
  const navigation = useNavigation();
  const shopping = useShoppingCart();
  const device = useDeviceInfo();
  const foodData = useFoodData();
  const foodError = useFoodDataError();
  const [showAttModal, setShowAttModal] = useState(false);
  const [storedData, setStoredData] = useState(null);
  const [showAsContainer, setShowAsContainer] = useState(false);

  const count = core?.dailyUPCCounter || 0;
  const limit = core?.maxUPCSearchLimit || 0;

  const {
    showScanner,
    setShowScanner,
    torchEnabled,
    toggleTorch,
    scannedData,
    onReadCode,
    resetScanner,
  } = useBarcodeScanner(core);

  const itemToUpdate =
    shopping?.items?.find(item => item.itemId === itemId) ?? null;

  const [itemName, setItemName] = useState(itemToUpdate?.itemName ?? null);
  const [brandName, setBrandName] = useState(itemToUpdate?.brandName ?? '');
  const [description, setDescription] = useState(
    itemToUpdate?.description ?? '',
  );
  const [packageSize, setPackageSize] = useState(
    String(itemToUpdate?.packageSize ?? '1'),
  );
  const [quantity, setQuantity] = useState(
    String(itemToUpdate?.quantity ?? '1'),
  );
  const [measurement, setMeasurement] = useState(
    displayDropField(itemToUpdate?.measurement, displayMeasurements) ?? null,
  );
  const [category, setCategory] = useState(
    displayDropField(itemToUpdate?.category, displayCategories) ?? null,
  );
  const [notes, setNotes] = useState(itemToUpdate?.notes ?? '');
  const [validation, setValidation] = useState(false);
  const [canSave, setCanSave] = useState(false);

  useEffect(() => {
    if (foodData) {
      if (!foodData?.hints || foodData?.hints.length === 0) {
        setStoredData(null);
      } else {
        setStoredData(foodData?.hints[0]);
      }
    }
  }, [foodData]);

  useEffect(() => {
    if (foodError !== null) {
      Toast.show({
        type: 'warning',
        text1: 'UPC Not Found in Database.',
        text2: `Please enter the item manually.`,
      });
      dispatch({type: 'RESET_FOOD_DATA'});
    }
  }, [foodError]);

  useEffect(() => {
    if (scannedData) {
      dispatch({
        type: 'FETCH_FOOD_DATA',
        payload: {
          barcode: scannedData?.value,
          allowance: core?.dailyUPCCounter,
          profileID: core?.profileID,
          accountID: core?.accountID,
        },
      });
      resetScanner();
    }
  }, [scannedData]);

  useEffect(() => {
    if (storedData) {
      setItemName(titleCase(storedData?.food?.label));
      setBrandName(titleCase(storedData?.food?.brand));
      setDescription('');
      setPackageSize('1');
      setQuantity('1');
      setMeasurement(null);
      setCategory(null);
      setNotes('');
      const timer = setTimeout(() => {
        setShowAttModal(true);
      }, 1000);

      return () => clearTimeout(timer);
    }
  }, [storedData]);

  useEffect(() => {
    if (itemName === null) {
      setValidation(false);
      setCanSave(false);
    } else if (itemName === '') {
      setValidation(true);
      setCanSave(false);
    } else {
      setValidation(false);
      setCanSave(true);
    }
  }, [itemName]);

  const handlePackageChange = value => {
    const safeValue = value.replace(/[^0-9.]/g, '');

    const parts = safeValue.split('.');
    if (parts.length > 2) return;

    setPackageSize(safeValue);
  };

  const resetForm = () => {
    setItemName(null);
    setBrandName('');
    setDescription('');
    setPackageSize('1');
    setQuantity('1');
    setMeasurement(null);
    setCategory(null);
    setNotes('');
    setShowAttModal(false);
  };

  const SaveItem = () => {
    if (itemName === '' || itemName === null) {
      setValidation(true);
    } else {
      setValidation(false);

      const newItem = {
        itemName: itemName || '',
        brandName: brandName || '',
        description: description || '',
        packageSize: Number(packageSize) > 0 ? Number(packageSize) : 1,
        quantity: Number(quantity) > 0 ? Number(quantity) : 1,
        measurement: measurement?.key?.trim() || 'each',
        category: category?.key?.trim() || 'na',
        notes: notes || '',
        status: itemToUpdate?.status ?? statusTo ?? 'shopping-list',
      };

      const updatedItem = {
        ...itemToUpdate,
        ...newItem,
      };

      if (itemToUpdate) {
        dispatch({
          type: 'UPDATE_ITEM_IN_SHOP_CART',
          payload: {
            shoppingCartID: core.shoppingCartID,
            updatedItem,
            updateType:
              itemToUpdate.status === 'shopping-cart'
                ? 'updateCart'
                : 'updateList',
            profileID: core.profileID,
          },
        });
      } else {
        dispatch({
          type: 'ADD_ITEM_TO_SHOP_CART',
          payload: {
            shoppingCartID: core.shoppingCartID,
            newItem: newItem,
            profileID: core.profileID,
          },
        });
      }

      resetForm();
    }
  };

  const handleClose = () => {
    dispatch({type: 'RESET_FOOD_DATA'});
    resetForm();
    setStoredData(null);
    navigation.goBack();
  };

  const handleClear = () => {
    dispatch({type: 'RESET_FOOD_DATA'});
    resetForm();
    setStoredData(null);
  };

  useFocusEffect(useCallback(() => () => resetForm(), []));

  const ScanAction = () => {
    if (count < limit) {
      if (showScanner) {
        toggleTorch();
      } else {
        setShowScanner(true);
      }
    } else {
      dailyCheckLimit({
        current: count,
        max: limit,
        label: 'UPC',
      });
    }
  };

  const CloseScanner = () => {
    setShowScanner(false);
  };

  const RenderModalContent = () => {
    if (storedData) {
      let foodObject = transformNutritionFacts(storedData?.food) || {};

      return (
        <View style={ListStyles.rmcContainer}>
          <View
            style={{borderBottomWidth: 1, borderColor: useColors('dark10')}}>
            {foodObject.image ? (
              <Image
                source={{uri: `${foodObject.image}`}}
                style={{
                  width: '100%',
                  height: 250,
                }}
              />
            ) : (
              <View
                style={{
                  width: '100%',
                  height: 150,
                  justifyContent: 'center',
                  alignItems: 'center',
                }}>
                <Text>No Image Available</Text>
              </View>
            )}
          </View>
          <ScrollView style={ListStyles.rmcScroll}>
            <View style={ListStyles.rmcScrollShellTop} />
            <View style={[ListStyles.rmcScrollWrapper]}>
              <TouchableOpacity
                style={{
                  marginTop: 2,
                  marginBottom: 10,
                  marginHorizontal: 15,
                }}
                onPress={() => setShowAsContainer(!showAsContainer)}>
                <Text
                  size="tiny"
                  font="open-5"
                  kqColor="rgb(56, 71, 234)"
                  centered>
                  {showAsContainer ? 'Show Per Serving' : 'Show Per Container'}
                </Text>
              </TouchableOpacity>
              <View style={{flexDirection: 'row'}}>
                <View style={ListStyles.rmcNutrientLabel}>
                  <Text size="xSmall" numberOfLines={1}>
                    Container Size:
                  </Text>
                </View>
                <View style={ListStyles.rmcNutrientValue}>
                  <Text size="xSmall">
                    {foodObject?.packageSize?.quantity}{' '}
                    {formatPluralUnit(
                      foodObject?.packageSize?.quantity,
                      foodObject?.packageSize?.unit,
                    )}
                  </Text>
                </View>
              </View>
              <View style={{flexDirection: 'row'}}>
                <View style={ListStyles.rmcNutrientLabel}>
                  <Text size="xSmall" numberOfLines={1}>
                    Serving Size:
                  </Text>
                </View>
                <View style={ListStyles.rmcNutrientValue}>
                  <Text size="xSmall">
                    {foodObject?.servingSizes[0]?.quantity}{' '}
                    {formatPluralUnit(
                      foodObject?.servingSizes[0]?.quantity,
                      foodObject?.servingSizes[0]?.label,
                    )}
                  </Text>
                </View>
              </View>

              {showAsContainer
                ? Object.entries(foodObject.nutrients?.perContainer).map(
                    ([key, value]) => (
                      <View key={key} style={{flexDirection: 'row'}}>
                        <View style={ListStyles.rmcNutrientLabel}>
                          <Text size="xSmall" numberOfLines={1}>
                            {value.label}:
                          </Text>
                        </View>
                        <View style={ListStyles.rmcNutrientValue}>
                          <Text size="xSmall">
                            {Math.round(value.value * 100) / 100}
                            {value.unit ? ` ${value.unit}` : null}
                          </Text>
                        </View>
                      </View>
                    ),
                  )
                : Object.entries(foodObject.nutrients?.perServing).map(
                    ([key, value]) => (
                      <View key={key} style={{flexDirection: 'row'}}>
                        <View style={ListStyles.rmcNutrientLabel}>
                          <Text size="xSmall" numberOfLines={1}>
                            {value.label}:
                          </Text>
                        </View>
                        <View style={ListStyles.rmcNutrientValue}>
                          <Text size="xSmall">
                            {Math.round(value.value * 100) / 100}
                            {value.unit ? ` ${value.unit}` : null}
                          </Text>
                        </View>
                      </View>
                    ),
                  )}
            </View>
            <View style={ListStyles.rmcDisclaimer}>
              <Text size="tiny" italic justified>
                The nutritional information displayed is based on data provided
                by Edamam and is intended for reference purposes only. This
                information may not reflect the exact values on the current
                product label, as manufacturers may have updated or changed the
                product's formulation or packaging since the data was recorded.
                For the most accurate and up-to-date information, please refer
                to the actual product label.
              </Text>
            </View>
            <View style={ListStyles.rmcContents}>
              <Text size="xSmall">
                Contains: {titleCase(foodObject.foodContentsLabel)}
              </Text>
            </View>
          </ScrollView>
          <View style={ListStyles.rmcButtonWrapper}>
            <View style={ListStyles.rmcButtonContainer}>
              <Button
                color="danger"
                type="outline"
                size="small"
                onPress={handleClear}>
                Clear
              </Button>
            </View>
            <View style={ListStyles.rmcButtonContainer}>
              <Button
                size="small"
                status="success"
                onPress={() => setShowAttModal(false)}>
                Confirm
              </Button>
            </View>
          </View>
          <View style={{alignItems: 'center', paddingBottom: 10}}>
            <EdamamAttribution
              width={device?.dimensions.width - 50}
              height={device?.dimensions.width / 10}
            />
          </View>
        </View>
      );
    }
  };

  return (
    <Layout
      headerTitle="Shopping Item"
      LeftButton={showScanner ? 'Cancel-Scan' : 'Close'}
      RightButton={
        canSave
          ? 'Save'
          : showScanner
          ? torchEnabled
            ? 'Torch-On'
            : 'Torch-Off'
          : 'Scan'
      }
      LeftAction={showScanner ? CloseScanner : handleClose}
      RightAction={canSave ? SaveItem : ScanAction}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}
      mode={showScanner ? 'keyboard-static' : 'keyboard-scroll'}>
      {showScanner ? (
        <Camera
          torchEnabled={torchEnabled}
          onReadCode={onReadCode}
          height={device?.dimensions?.height}
        />
      ) : (
        <>
          <Input
            required
            label="Item Name"
            value={itemName}
            onChangeText={setItemName}
            validation={validation}
            validationMessage="Item Name is required"
            capitalize
            capitalMode="words"
          />
          <Input
            label="Brand Name"
            value={brandName}
            onChangeText={setBrandName}
            capitalize
            capitalMode="words"
          />
          <Input
            label="Description"
            value={description}
            onChangeText={setDescription}
            capitalize
            capitalMode="sentences"
          />
          <View style={{flexDirection: 'row'}}>
            <View style={{flex: 1}}>
              <Input
                label="Quantity"
                value={quantity}
                onChangeText={setNumericValue(setQuantity)}
                caption="Number of Packages"
                // capitalMode="sentences"
              />
            </View>
            <View style={{flex: 1}}>
              <Input
                label="Package Size"
                value={packageSize}
                onChangeText={handlePackageChange}
                caption="Total in a package"
                capitalMode="sentences"
              />
            </View>
          </View>
          <Dropdown
            label="Measurement"
            // customLabel="Custom Measurement"
            placeholder="Select a measurement"
            value={measurement}
            setValue={setMeasurement}
            caption={'Single is for individual items. Ex: Eggs'}
            mapData={displayMeasurements}
          />
          <Dropdown
            label="Category"
            customLabel="Custom Category"
            placeholder="Select a category"
            value={category}
            setValue={setCategory}
            mapData={displayCategories}
          />
          <Input
            label="Notes"
            value={notes}
            onChangeText={setNotes}
            multiline
            multiHeight="large"
            caption="Add notes here"
            counter
            maxCount={250}
          />
        </>
      )}
      <Modal
        title={storedData?.food?.label}
        visible={showAttModal}
        headerFont="open-6"
        headerSize="small"
        height="99.5%"
        width="96%"
        headerColor="orange"
        hideClose
        onClose={handleClose}>
        <RenderModalContent />
      </Modal>
    </Layout>
  );
};

export default ShoppingItems;


--- FILE: src/screens/Shopping/ShoppingList.jsx ---

//* ShoppingList.jsx
import React, {useCallback, useEffect, useState} from 'react';
import {useFocusEffect, useNavigation} from '@react-navigation/native';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useShoppingCart} from '../../hooks/useHooks';
import {View} from 'react-native';
import {ListStyles} from '../../styles/Styles';
import SwipeableItem from '../../components/SwipeableItem';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';
import SelectedItemInfo from '../../components/SelectedItemInfo';

const ShoppingList = () => {
  const shopping = useShoppingCart();
  const navigation = useNavigation();
  const core = useCoreInfo();
  const dispatch = useDispatch();
  const [refreshFlag, setRefreshFlag] = useState(false);

  useFocusEffect(
    useCallback(() => {
      setRefreshFlag(prev => !prev);
    }, [shopping?.items]),
  );

  const shoppingList = Array.isArray(shopping?.items)
    ? shopping.items.filter(item => item.status === 'shopping-list')
    : [];

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  useEffect(() => {
    if (showItemInfo === false) {
      setSelectedItem(null);
    }
  }, [showItemInfo]);

  const handleAddToCart = itemId => {
    const latestItem = shopping?.items?.find(i => i.itemId === itemId);
    const fallbackItem = selectedItem?.itemId === itemId ? selectedItem : null;
    const item = latestItem || fallbackItem;

    if (item && core.profileID) {
      const updatedItem = {
        ...item,
        status: 'shopping-cart',
        lastUpdated: new Date().toISOString(),
        lastUpdatedBy: core.profileID,
      };

      dispatch({
        type: 'UPDATE_ITEM_IN_SHOP_CART',
        payload: {
          shoppingCartID: core.shoppingCartID,
          updatedItem,
          profileID: core.profileID,
          updateType: 'toCart',
        },
      });
    }
  };

  const handleUpdateItem = itemId => {
    navigation.navigate('ShoppingItems', {
      title: 'Update Item',
      itemId,
      navigateBackTo: 'ShoppingList',
      statusTo: 'shopping-list',
    });
  };

  const handleDeleteItem = useCallback(
    itemId => {
      if (core.profileID) {
        const item = shoppingList.find(item => item.itemId === itemId);
        if (item) {
          dispatch({
            type: 'DELETE_ITEM_FROM_SHOP_CART',
            payload: {
              shoppingCartID: core.shoppingCartID,
              itemId: item.itemId,
              itemName: item.itemName,
              profileID: core.profileID,
            },
          });
        }
      }
    },
    [dispatch, core.profileID, shoppingList],
  );

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
        navigate={{
          to: 'ShoppingItems',
          backTo: 'ShoppingList',
          statusTo: 'shopping-list',
        }}
      />
    </BottomSheet>
  );

  return (
    <Layout
      headerTitle="Shopping List"
      LeftButton=""
      RightButton="To-Cart"
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}>
      {shoppingList.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Shopping List is Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            list={shoppingList}
            key={refreshFlag}
            core={core}
            showItemInfo={showItemInfo}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            rightButtons={[
              {
                action: itemId => handleAddToCart(itemId),
                text1: 'Add',
                text2: 'to Cart',
                style: ListStyles.addButton,
              },
              {
                action: itemId => handleUpdateItem(itemId),
                text1: 'Update',
                text2: 'Item',
                style: ListStyles.updateButton,
              },
              {
                action: itemId => handleDeleteItem(itemId),
                text1: 'Delete',
                style: ListStyles.deleteButton,
              },
            ]}
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default ShoppingList;


--- FILE: src/styles/Styles.jsx ---

//* Styles.jsx
import {StyleSheet} from 'react-native';
import {useColors} from '../KQ-UI/KQUtilities';

export const AppStyles = StyleSheet.create({
  navMenu: {
    height: 90,
  },
  safeArea: {
    flex: 1,
    margin: 5,
  },
  globalContainer: {
    flex: 1,
  },
});

export const NavMenuStyles = StyleSheet.create({
  container: {flex: 1},
  wrapper: {
    height: '100%',
    width: '100%',
    position: 'absolute',
    backgroundColor: 'transparent',
    flexDirection: 'row',
    padding: 5,
  },
});

export const CurvedBarStyles = StyleSheet.create({
  fillColor: '#f7f7f7',
  strokeColor: '#373d4340',
  strokeWidth: 1.5,
  shadowStroke: '#373d4320',
  shadowStrokeWidth: 4,
});

export const MenuButtonStyles = StyleSheet.create({
  wrapper: {
    height: '100%',
    width: '100%',
    position: 'absolute',
    flexDirection: 'row',
    zIndex: 2000, // Bottom Layer
    paddingHorizontal: 5,
  },
  container: {
    flex: 1,
    height: 65,
    position: 'relative',
    top: -21,
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    zIndex: 2100, // Middle Layer
  },
  button: {
    borderWidth: 1,
    height: 55,
    width: 55,
    borderRadius: 30,
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    borderColor: '#c4c4c480',
    backgroundColor: '#29856c',
    zIndex: 2300, // Over Layer
  },
  menuButton: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2200, // Top Layer
  },
});

export const ListStyles = StyleSheet.create({
  rightActionButton: {
    alignItems: 'center',
    borderRadius: 5,
    justifyContent: 'center',
    marginHorizontal: 3,
    width: 90,
    // height: 60,
  },
  rightActionsContainer: {
    alignItems: 'top',
    flexDirection: 'row',
    justifyContent: 'flex-end',
    paddingRight: 10,
    paddingLeft: 0,
    paddingVertical: 5,
    // borderBottomWidth: 1,
    borderColor: '#c4c4c4',
  },
  addButton: {
    backgroundColor: '#44B3B3',
  },
  favButton: {
    backgroundColor: '#FFAE42',
  },
  bottomInnerContainer: {
    borderColor: '#c4c4c4',
    borderTopWidth: 1,
    height: 58,
    justifyContent: 'center',
    marginHorizontal: -5,
  },
  bottomLeft: {
    flex: 1,
    paddingLeft: 10,
    paddingRight: 5,
  },
  bottomRight: {
    flex: 1,
    paddingLeft: 5,
    paddingRight: 10,
  },
  bottomCenter: {width: '50%', paddingLeft: 5, paddingRight: 5},
  buttonContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    // padding: 2,
    width: '100%',
    height: '100%',
    backgroundColor: 'transparent',
  },
  buttonText: {
    color: '#fff',
    textAlign: 'center',
  },
  container: {
    backgroundColor: '#ffffff',
    width: '100%',
    flex: 1,
  },
  deleteButton: {
    backgroundColor: '#fE4949',
  },
  viewContainer: {
    flex: 1,
    backgroundColor: '#ffffff',
    width: '100%',
  },
  updateButton: {
    backgroundColor: '#0077A2',
  },
  bottomSheet: {
    zIndex: 9000,
    borderColor: 'transparent',
    borderRadius: 18,
  },

  rmcContainer: {flex: 1},
  rmcImage: {alignItems: 'center', justifyContent: 'center'},
  rmcTitle: {
    marginHorizontal: 5,
    marginVertical: 2,
    alignItems: 'center',
    paddingVertical: 2,
  },
  rmcBrand: {
    marginHorizontal: 5,
    marginTop: 2,
    marginBottom: 5,
    alignItems: 'center',
    paddingVertical: 2,
  },
  rmcScroll: {
    flex: 1,
    paddingVertical: 5,
    paddingHorizontal: 5,
  },
  rmcScrollShellTop: {height: 5},
  rmcScrollShellBottom: {height: 15},
  rmcScrollWrapper: {
    paddingVertical: 2,
    paddingHorizontal: 5,
  },
  rmcNutrientLabel: {
    flex: 1,
    borderBottomWidth: 1,
    padding: 2,
    paddingBottom: 1,
    justifyContent: 'center',
  },
  rmcNutrientValue: {
    borderBottomWidth: 1,
    alignItems: 'flex-end',
    padding: 2,
    paddingBottom: 1,
    justifyContent: 'center',
  },
  rmcContents: {borderWidth: 0, marginTop: 10, paddingHorizontal: 5},
  rmcButtonWrapper: {flexDirection: 'row', paddingHorizontal: 5},
  rmcButtonContainer: {flex: 1, marginHorizontal: 5},
  rmcDisclaimer: {marginTop: 3, marginHorizontal: 5, paddingHorizontal: 2},
});

export const NavHeaderStyles = StyleSheet.create({
  header: {
    alignItems: 'center',
    backgroundColor: '#fff',
    borderColor: '#c4c4c490',
    borderBottomWidth: 1,
    elevation: 4,
    shadowColor: '#c4c4c490',
    shadowOffset: {width: 0, height: 4},
    shadowOpacity: 0.8,
  },
  titleContainer: {
    position: 'absolute',
    top: 0,
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2000,
  },
  buttonContainer: {
    position: 'absolute',
    top: 0,
    width: '100%',
    height: '100%',
    zIndex: 2001,
  },
  buttonRows: {flexDirection: 'row', height: '100%'},
  sideContainers: {
    flex: 1,
    justifyContent: 'center',
    paddingLeft: 15,
  },
  leftWrapper: {flexDirection: 'row', marginLeft: 0},
  leftContainer: {flex: 1, justifyContent: 'center'},
  rightWrapper: {flexDirection: 'row', marginRight: 10},
  rightContainer: {
    flex: 1,
    justifyContent: 'center',
    alignContent: 'flex-end',
    alignItems: 'flex-end',
  },
  rightContainerAlt: {
    flex: 1,
    justifyContent: 'center',
    alignContent: 'flex-end',
    alignItems: 'flex-end',
    marginRight: 5,
  },
  iconPosition: {position: 'relative', top: 1},
  textStyles: {
    fontSize: 16,
  },
});

export const ScreenStyles = StyleSheet.create({
  container: {
    backgroundColor: '#ffffff',
    flex: 1,
  },
  error: {
    color: 'red',
    flex: 1,
    fontSize: 18,
    textAlign: 'center',
  },
  errorContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  success: {
    color: 'green',
    flex: 1,
    fontSize: 22,
    marginBottom: 20,
    marginTop: 20,
    textAlign: 'center',
  },
  successContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  viewContainer: {
    flex: 1,
    paddingBottom: 2,
    padding: 5,
  },
  viewInnerTopContainer: {
    alignItems: 'center',
    paddingTop: 20,
    paddingBottom: 5,
    paddingHorizontal: 15,
  },
  scrollContainer: {
    marginTop: 5,
    flex: 0,
  },
});

export const SelectItemStyles = StyleSheet.create({
  container: {
    marginHorizontal: 2.5,
    flex: 1,
  },
  imageContainer: {
    flex: 0.3,
    alignItems: 'center',
    justifyContent: 'center',
  },
  updateContainer: {
    padding: 0,
    marginVertical: -5,
  },
  infoContainer: {
    flex: 0.7,
    paddingHorizontal: 5,
  },
  itemContainer: {
    flexDirection: 'row',
    borderBottomWidth: 1.5,
    borderRadius: 8,
    borderBottomColor: '#c4c4c490',
    paddingBottom: 6,
    paddingTop: 3,
    marginLeft: 5,
  },
  itemNoteContainer: {
    borderRadius: 8,
    borderBottomColor: '#c4c4c4',
    paddingBottom: 3,
    paddingTop: 7,
    marginLeft: 5,
  },
  titleWrap: {paddingTop: 3, paddingHorizontal: 3},
  infoWrap: {
    flex: 1,
    paddingTop: 3,
    paddingHorizontal: 4,
  },
  infoNoteWrap: {
    paddingTop: 3,
    paddingHorizontal: 4,
  },
  textStyles: {textAlign: 'right'},
  textNoteStyles: {letterSpacing: 0.2, textAlign: 'justify'},
  addToContainer: {flexDirection: 'row', marginVertical: 15},
  quantityWrapper: {
    flex: 2,
    flexDirection: 'row',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 5,
    margin: 5,
  },
  quantityContainer: {flex: 2},
  quantityText: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  bannerFieldWrapper: backgroundColor => ({
    marginHorizontal: 5,
    marginBottom: 5,
    borderRadius: 10,
    backgroundColor: backgroundColor || '#29856c',
    alignItems: 'center',
    justifyContent: 'center',
  }),
});

export const LegalStyles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'column',
    paddingVertical: 15,
  },
  body: {
    flex: 1,
  },
  buttonWrapper: {
    flexDirection: 'row',
  },
  buttonCells: {
    flex: 1,
    paddingHorizontal: 5,
  },
  sectionWrapper: {
    marginVertical: 5,
  },
  sectionHeader: {
    flexDirection: 'row',
  },
  sectionIndex: {
    width: 40,
    alignItems: 'flex-end',
    paddingRight: 3,
    paddingVertical: 3,
  },
  sectionTitle: {
    flex: 1,
    alignItems: 'flex-start',
    paddingLeft: 3,
    paddingVertical: 3,
  },
  clauseWrapper: {},
  clauseHeader: {
    flexDirection: 'row',
  },
  clauseIndexSpacing: {width: 39},
  clauseTextWrapper: {
    flex: 1,
    paddingVertical: 3,
    paddingLeft: 3,
    paddingRight: 20,
    paddingBottom: 5,
  },
  subClauseWrapper: {},
  subClauseHeader: {flexDirection: 'row'},
  bulletWrapper: {
    width: 55,
    alignItems: 'flex-end',
    paddingRight: 3,
  },
  subClauseTextWrapper: {
    flex: 1,
    paddingVertical: 2,
    paddingLeft: 3,
    paddingRight: 25,
    paddingBottom: 10,
  },
  clauseInfo: {},
});

export const SettingsStyles = StyleSheet.create({
  card: {
    marginTop: 15,
    marginHorizontal: 15,
    backgroundColor: '#29856c',
    borderTopRightRadius: 8,
    borderTopLeftRadius: 8,
    borderWidth: 1,
    borderBottomWidth: 0.5,
    borderColor: '#c4c4c4',
  },
  cardTitle: {marginVertical: 10, color: '#fff'},
  topContainer: {
    borderTopWidth: 1,
    borderColor: '#c4c4c4',
    height: 70,
    backgroundColor: '#fff',
    flexDirection: 'row',
    height: 70,
  },
  innerTopContainer: {
    width: 70,
    padding: 8,
  },
  quantityCell: {
    borderWidth: 1,
    borderRadius: 8,
    borderColor: '#c4c4c4',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  infoCell: {
    flex: 1,
    marginVertical: 5,
    marginRight: 5,
    justifyContent: 'center',
    padding: 0,
  },
  bottomContainer: {
    marginHorizontal: 15,
    borderWidth: 1,
    borderTopWidth: 0.5,
    borderBottomRightRadius: 8,
    borderBottomLeftRadius: 8,
    paddingVertical: 7,
    borderColor: '#c4c4c4',
  },
  buttonContainer: {alignContent: 'center', alignItems: 'center'},

  listContainer: {
    paddingHorizontal: 10,
  },
  itemContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 15,
    marginVertical: 5,
    borderRadius: 5,
    borderWidth: 1,
    borderColor: '#dcdcdc',
  },
  description: {
    marginVertical: 10,
  },
  segmentedButtonContainer: {
    flexDirection: 'row',
    paddingHorizontal: 15,
    gap: 10,
  },
  hapticButton: {
    elevation: 4,
    shadowColor: '#373d43',
    shadowOffset: {width: 1, height: 2},
    shadowOpacity: 0.3,
    borderRadius: 5,
    marginVertical: 10,
    marginHorizontal: 5,
    alignContent: 'center',
    alignItems: 'center',
    justifyContent: 'center',
    borderColor: '#29856c',
    height: 45,
  },
  hbInner: {
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    flex: 1,
    width: '100%',
    flexDirection: 'row',
  },
});

export const KQDropStyles = StyleSheet.create({
  dropdownContainer: {
    marginVertical: 5,
    marginHorizontal: 7,
  },
  labelContainer: {
    marginBottom: 4,
    marginLeft: 5,
  },
  dropdown: {
    borderWidth: 1,
    borderRadius: 5,
    borderColor: '#c4c4c4',
    minHeight: 40,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 8,
  },
  iconContainer: {
    width: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  sheetContentContainer: {
    paddingVertical: 16,
  },
  sheetItem: {
    paddingVertical: 16,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  sheetItemText: {
    fontSize: 18,
  },
  bottomSheet: {
    zIndex: 9000,
    borderColor: 'transparent',
    borderWidth: 4,
    borderRadius: 18,
  },
  captionWrap: {marginHorizontal: 10, marginBottom: 5},
  captionText: {
    color: '#373d4390',
  },
});

export const AvatarStyles = StyleSheet.create({
  avatarCard: {
    // width: 80,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'transparent',
  },
  avatarView: {
    width: 100,
    height: 100,
    borderWidth: 1,
    borderRadius: 50,
    overflow: 'hidden',
  },
});

export const ProfileStyles = StyleSheet.create({
  FTCenter: {textAlign: 'center'},
  FTLeft: {
    // fontWeight: 700,
    textAlign: 'right',
    marginRight: 5,
  },
  FTRight: {marginLeft: 5},
  optionContainer: {height: 35, flexDirection: 'row', marginVertical: 4},
  optionLeft: {
    borderWidth: 1,
    borderColor: '#373d43',
    borderTopLeftRadius: 8,
    borderBottomLeftRadius: 8,
    width: 40,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 1, height: 2},
    shadowOpacity: 0.3,
    elevation: 4,
  },
  olInner: {
    position: 'relative',
    left: 5,
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
  optionRight: {
    borderWidth: 1,
    borderColor: '#373d43',
    borderTopRightRadius: 8,
    borderBottomRightRadius: 8,
    width: 40,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 2, height: 3},
    shadowOpacity: 0.3,
    elevation: 4,
  },
  orInner: {
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
  optionView: {
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: '#373d43',
    justifyContent: 'center',
    alignItems: 'center',
    width: 150,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 2, height: 3},
    shadowOpacity: 0.3,
    elevation: 4,
  },
});

export const AccountStyles = StyleSheet.create({
  topSection: {
    backgroundColor: '#fff',
    marginTop: 10,
    marginBottom: 5,
    marginHorizontal: 5,
  },
  midSection: {
    minHeight: 125,
    backgroundColor: '#fff',
    marginTop: 5,
    marginBottom: 5,
    marginHorizontal: 10,
    borderWidth: 1,
    borderColor: '#c4c4c4',
    borderRadius: 5,
    backgroundColor: '#fff',
    shadowColor: '#373d4380',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 4,
  },
  userSection: {
    backgroundColor: '#fff',
    marginTop: 5,
    marginBottom: 5,
    marginHorizontal: 10,
  },
  sectionNav: {flexDirection: 'row'},
  sectionUsers: {
    borderWidth: 1,
    borderColor: '#c4c4c4',
    borderRadius: 5,
    backgroundColor: '#fff',
    shadowColor: '#373d4380',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 4,
  },
  usersHeader: {
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
    paddingVertical: 5,
    paddingHorizontal: 10,
  },
  avatarWrapper: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
  },
  subWrapper: {
    height: 65,
    borderWidth: 1,
    borderColor: '#c4c4c4',
    borderRadius: 5,
    backgroundColor: '#fff',
    shadowColor: '#373d4380',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 4,
    marginHorizontal: 5,
  },
  subIcon: {
    flex: 1,
    justifyContent: 'flex-end',
    alignItems: 'center',
    alignContent: 'center',
  },
  subTextWrap: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
});

export const CMStyles = StyleSheet.create({
  shContainer: {height: 35, borderWidth: 0},
  shLine: {
    borderBottomWidth: 1,
    position: 'relative',
    top: 16,
    marginLeft: 15,
    marginRight: 50,
    zIndex: 1,
  },
  shTWrap: {alignItems: 'flex-end', marginRight: 1},
  shTO: {
    height: 30,
    width: 50,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
  shTitleWrap: {
    zIndex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    top: -7,
  },
  shTitle: {
    backgroundColor: '#fff',
    paddingHorizontal: 15,
    paddingVertical: 2,
  },
  sectionExpanded: {paddingHorizontal: 25, paddingVertical: 5, marginTop: -10},
  sectionCollapsed: {
    paddingHorizontal: 25,
    paddingTop: 3,
    paddingBottom: 10,
    alignItems: 'center',
    marginTop: -10,
  },
  sectionTO: {
    flexDirection: 'row',
    paddingVertical: 5,
    alignItems: 'center',
  },
  sectionIcon: {marginRight: 20},
});

export const RecipeSearchStyles = StyleSheet.create({
  loadingWrapper: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingContainer: {
    paddingTop: 6,
    paddingBottom: 3,
    paddingLeft: 6,
    paddingRight: 3,
  },
  loadingText: {
    paddingVertical: 2,
    paddingHorizontal: 4,
  },
  listWrapper: {marginTop: 2},
  listTitle: {paddingHorizontal: 3, paddingBottom: 2},
  listSubTitleContainer: {
    flex: 1,
    flexDirection: 'row',
    paddingHorizontal: 3,
  },
  listReadyIn: {flex: 1, justifyContent: 'center'},
  listScoreContainer: {flex: 1, flexDirection: 'row'},
  listScoreLeft: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
  listScoreRight: {justifyContent: 'center'},
  wrapperStyles: {
    borderBottomWidth: 1.5,
    borderWidth: 1.5,
    borderRadius: 20,
    padding: 1,
    paddingLeft: 15,
    paddingRight: 10,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 2,
    marginHorizontal: 0,
  },
  iconStyles: {padding: 5, paddingRight: 0},
  innerLayoutWrapper: {flex: 1, justifyContent: 'center'},
  inputWrapper: {
    margin: 5,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
  clearButton: {
    paddingLeft: 8,
    paddingRight: 5,
  },
  clearButtonWrapper: {
    marginLeft: -5,
  },
});

export const SelectedRecipeStyles = StyleSheet.create({
  aboutRecipe: {marginTop: 10, marginBottom: 2, marginHorizontal: 15},
  aboutRecipeButton: {
    alignItems: 'flex-end',
    marginBottom: 10,
    marginHorizontal: 20,
  },
  ingWrapper: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  ingDot: {
    position: 'relative',
    top: 8,
    paddingHorizontal: 3,
  },
  ingColOne: {
    // borderWidth: 1,
    width: '100%',
    // marginVertical: 3,
    // marginHorizontal: 4,
    paddingVertical: 3,
    justifyContent: 'center',
    paddingLeft: 15,
    paddingRight: 15,
  },
  ingColTwo: {
    width: '50%',
    justifyContent: 'center',
    paddingVertical: 2,
    paddingLeft: 7,
    paddingRight: 5,
  },
  noteWrapper: {marginBottom: 10, marginHorizontal: 15},
  imageSelectedStyles: {
    width: '100%',
    height: 200,
  },
  selectedCloseButton: {
    position: 'absolute',
    top: 50,
    left: 10,
    height: 35,
    width: 35,
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.2)',
  },
  selectedTRButton: {
    position: 'absolute',
    top: 50,
    right: 10,
    height: 35,
    width: 35,
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.2)',
  },
  selectedBRButton: {
    position: 'absolute',
    top: 195,
    right: 10,
    height: 35,
    width: 35,
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.2)',
  },
  selectedBLButton: {
    position: 'absolute',
    top: 195,
    left: 10,
    height: 35,
    width: 35,
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.2)',
  },
  selectedViewWrapper: {
    flex: 1,
    paddingTop: 1,
    marginBottom: 0,
    borderBottomLeftRadius: 15,
    borderBottomRightRadius: 15,
  },
  sectionWrapper: {
    flexDirection: 'row',
    marginTop: 15,
    marginBottom: 7,
    justifyContent: 'center',
    alignItems: 'center',
  },
  sectionEnd: {
    flex: 1,
    borderBottomWidth: 1.5,
    borderColor: useColors('dark30'),
  },
  sectionTitle: {
    marginHorizontal: 10,
    position: 'relative',
    top: -1.5,
  },
  stepWrapper: {
    // borderWidth: 0.2,
    flexDirection: 'row',
    marginLeft: 5,
    marginRight: 5,
    marginVertical: 5,
    marginTop: 5,
  },
  stepNumber: {
    width: 60,
    justifyContent: 'flex-start',
    alignItems: 'flex-end',
  },
  stepText: {
    flex: 1,
    marginLeft: 5,
    justifyContent: 'flex-start',
    alignItems: 'flex-start',
    paddingRight: 5,
  },
  toolWrapper: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 0,
    paddingHorizontal: 5,
  },
  toolText: {
    width: '50%',
    marginVertical: 2,
    paddingLeft: 15,
    paddingRight: 5,
    justifyContent: 'center',
  },
});

export const UploadPictureStyles = StyleSheet.create({
  button: {
    height: 90,
    borderWidth: 1.5,
    borderColor: useColors('dark50'),
    borderRadius: 5,
    backgroundColor: '#fff',
    shadowColor: '#373d4380',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 4,
    marginHorizontal: 10,
  },
  bbWrapper: {
    position: 'absolute',
    bottom: 0,
    width: '100%',
    zIndex: 1000,
    backgroundColor: 'rgba(0, 0, 0, 0.4)',
  },
  cameraButton: buttonWidth => ({
    borderWidth: 4,
    borderColor: '#ffffff90',
    borderRadius: 50,
    width: buttonWidth,
    height: buttonWidth,
    marginHorizontal: 20,
    marginVertical: 10,
  }),
  redDot: {
    margin: 3,
    backgroundColor: '#da2c4390',
    borderRadius: 50,
  },
  btWrapper: {
    position: 'absolute',
    top: 0,
    width: '100%',
    zIndex: 1000,
    backgroundColor: 'rgba(0, 0, 0, 0.4)',
    height: 50,
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  cameraWrapper: {
    height: '98%',
    width: '98%',
    borderWidth: 0.5,
    borderRadius: 25,
    overflow: 'hidden',
    alignSelf: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
  },
  previewWrapper: {
    height: '48%',
    width: '98%',
    borderWidth: 0.5,
    borderRadius: 25,
    overflow: 'hidden',
    alignSelf: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
  },
  finalizedWrapper: {
    height: 170,
    width: 275,
    borderWidth: 0.5,
    borderRadius: 25,
    overflow: 'hidden',
    alignSelf: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
  },
});


--- FILE: src/svg/KitchenQueueTempRecipe.jsx ---

import * as React from 'react';
import Svg, {G, Path, Rect} from 'react-native-svg';
const KQTempRecipe = ({
  color = '#000', // silhouette color
  backgroundColor = '#fff', // background color
  ...props
}) => (
  <Svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 600 600"
    width={600}
    height={600}
    color="#000"
    backgroundColor="#fff"
    {...props}>
    <Rect width={600} height={600} fill={backgroundColor} />
    <G fill={color}>
      <Path d="M 104,503 Z" />
      <Path d="M 267,493 Z" />
      <Path d="M 383,492 Z" />
      <Path d="M 381,492 Z" />
      <Path d="M 369,492 Z" />
      <Path d="M 105,491 L 105,492 Z" />
      <Path d="M 448,489 L 449,489 Z" />
      <Path d="M 236,486 Z" />
      <Path d="M 238,485 L 239,486 Z" />
      <Path d="M 374,484 L 375,485 Z" />
      <Path d="M 287,484 L 288,484 Z" />
      <Path d="M 235,484 Z" />
      <Path d="M 321,482 Z" />
      <Path d="M 318,482 Z" />
      <Path d="M 372,481 L 371,482 Z" />
      <Path d="M 278,481 Z" />
      <Path d="M 367,476 Z" />
      <Path d="M 233,476 Z" />
      <Path d="M 358,471 Z" />
      <Path d="M 356,470 Z" />
      <Path d="M 275,468 Z" />
      <Path d="M 272,465 Z" />
      <Path d="M 316,458 Z" />
      <Path d="M 139,455 L 138,456 L 136,456 L 134,458 L 134,459 L 131,462 L 131,463 L 128,466 L 128,467 L 126,469 L 125,468 L 126,469 L 126,470 L 123,473 L 123,474 L 121,476 L 121,477 L 120,478 L 120,479 L 118,481 L 117,480 L 116,481 L 117,480 L 118,481 L 118,482 L 116,484 L 116,485 L 115,486 L 115,487 L 113,489 L 113,490 L 112,491 L 112,492 L 111,493 L 111,494 L 110,495 L 110,496 L 109,497 L 109,498 L 108,499 L 108,500 L 106,502 L 106,504 L 105,505 L 105,506 L 104,507 L 104,508 L 103,509 L 103,510 L 102,511 L 102,512 L 101,513 L 101,514 L 100,515 L 100,517 L 99,518 L 99,519 L 98,520 L 98,522 L 97,523 L 97,524 L 96,525 L 96,527 L 95,528 L 95,529 L 94,530 L 94,532 L 93,533 L 93,535 L 92,536 L 92,538 L 91,539 L 91,541 L 90,542 L 90,545 L 89,546 L 89,548 L 88,549 L 88,552 L 87,553 L 87,556 L 86,557 L 86,560 L 85,561 L 85,565 L 84,566 L 84,568 L 509,568 L 509,567 L 510,566 L 511,566 L 513,564 L 514,564 L 518,560 L 519,560 L 521,558 L 521,557 L 525,553 L 525,552 L 526,551 L 527,551 L 527,550 L 528,549 L 528,548 L 529,547 L 529,546 L 530,545 L 530,544 L 531,543 L 532,543 L 532,541 L 533,540 L 533,539 L 534,538 L 534,534 L 533,533 L 534,532 L 535,532 L 486,532 L 485,531 L 485,529 L 486,528 L 486,525 L 487,524 L 487,523 L 488,522 L 488,519 L 489,518 L 489,515 L 490,514 L 490,511 L 491,510 L 491,507 L 492,506 L 492,502 L 493,501 L 493,496 L 494,495 L 494,492 L 495,491 L 500,491 L 501,490 L 506,490 L 507,489 L 512,489 L 513,488 L 515,488 L 516,487 L 519,487 L 520,486 L 521,486 L 522,485 L 523,485 L 526,482 L 527,483 L 526,482 L 526,481 L 527,480 L 527,476 L 526,475 L 526,474 L 527,473 L 526,472 L 525,473 L 524,473 L 522,471 L 506,471 L 505,472 L 501,472 L 500,473 L 497,473 L 496,474 L 493,471 L 492,471 L 491,470 L 490,470 L 489,469 L 488,469 L 487,468 L 485,468 L 484,467 L 482,467 L 481,466 L 477,466 L 476,465 L 472,465 L 471,464 L 467,464 L 466,463 L 460,463 L 459,462 L 453,462 L 452,461 L 444,461 L 443,460 L 432,460 L 431,459 L 417,459 L 416,458 L 348,458 L 347,459 L 346,458 L 345,458 L 347,460 L 348,460 L 350,462 L 351,462 L 353,464 L 354,464 L 356,466 L 357,466 L 358,467 L 359,467 L 362,470 L 361,471 L 362,470 L 363,470 L 367,474 L 368,474 L 374,480 L 374,481 L 377,484 L 377,485 L 379,487 L 379,489 L 380,490 L 414,490 L 415,489 L 430,489 L 431,488 L 432,489 L 433,488 L 441,488 L 442,487 L 450,487 L 451,486 L 458,486 L 459,485 L 464,485 L 465,484 L 469,484 L 470,483 L 474,483 L 475,482 L 478,482 L 479,481 L 482,481 L 483,480 L 485,480 L 486,479 L 488,479 L 489,480 L 488,481 L 488,482 L 487,483 L 486,483 L 485,484 L 484,484 L 483,485 L 480,485 L 479,486 L 476,486 L 475,487 L 472,487 L 471,488 L 467,488 L 466,489 L 461,489 L 460,490 L 456,490 L 455,491 L 446,491 L 445,492 L 436,492 L 435,493 L 424,493 L 423,494 L 394,494 L 393,495 L 373,495 L 372,494 L 344,494 L 343,493 L 330,493 L 329,492 L 320,492 L 319,491 L 311,491 L 310,490 L 304,490 L 303,489 L 299,489 L 298,488 L 294,488 L 293,487 L 290,487 L 289,486 L 286,486 L 285,485 L 282,485 L 281,484 L 279,484 L 278,483 L 277,483 L 275,481 L 275,480 L 276,479 L 279,479 L 280,480 L 282,480 L 283,481 L 285,481 L 286,482 L 289,482 L 290,483 L 294,483 L 295,484 L 300,484 L 301,485 L 305,485 L 306,486 L 313,486 L 314,487 L 318,487 L 317,486 L 317,484 L 316,483 L 316,480 L 315,479 L 315,466 L 316,465 L 316,463 L 317,462 L 316,461 L 315,461 L 314,462 L 308,462 L 307,463 L 300,463 L 299,464 L 294,464 L 293,465 L 290,465 L 289,466 L 286,466 L 285,467 L 282,467 L 281,468 L 279,468 L 278,469 L 277,469 L 276,470 L 275,470 L 274,471 L 273,471 L 271,473 L 266,473 L 265,472 L 261,472 L 260,471 L 254,471 L 253,470 L 246,470 L 245,471 L 241,471 L 240,472 L 239,472 L 238,473 L 237,472 L 238,473 L 238,474 L 237,475 L 237,476 L 236,477 L 237,478 L 237,481 L 240,484 L 241,484 L 242,485 L 243,485 L 244,486 L 245,486 L 246,487 L 248,487 L 249,488 L 252,488 L 253,489 L 258,489 L 259,490 L 265,490 L 266,491 L 268,491 L 269,492 L 269,493 L 270,494 L 270,498 L 271,499 L 271,503 L 272,504 L 272,509 L 273,510 L 273,513 L 274,514 L 274,517 L 275,518 L 275,521 L 276,522 L 276,524 L 277,525 L 277,527 L 278,528 L 278,531 L 277,532 L 276,531 L 275,532 L 273,532 L 272,531 L 271,532 L 124,532 L 123,531 L 123,530 L 124,529 L 124,525 L 125,524 L 125,520 L 126,519 L 126,517 L 127,516 L 127,513 L 128,512 L 128,509 L 129,508 L 129,505 L 130,504 L 130,501 L 131,500 L 131,498 L 132,497 L 132,495 L 133,494 L 133,491 L 134,490 L 134,488 L 135,487 L 135,485 L 136,484 L 136,482 L 137,481 L 137,479 L 138,478 L 138,476 L 139,475 L 139,474 L 140,473 L 140,471 L 141,470 L 141,468 L 142,467 L 142,465 L 143,464 L 143,463 L 144,462 L 144,460 L 145,459 L 145,458 L 146,457 L 146,456 L 143,456 L 142,455 Z" />
      <Path d="M 337,452 Z" />
      <Path d="M 333,452 Z" />
      <Path d="M 343,451 Z" />
      <Path d="M 306,446 Z" />
      <Path d="M 55,446 Z" />
      <Path d="M 48,446 Z" />
      <Path d="M 330,444 Z" />
      <Path d="M 49,444 Z" />
      <Path d="M 151,443 Z" />
      <Path d="M 329,442 Z" />
      <Path d="M 369,438 Z" />
      <Path d="M 326,438 Z" />
      <Path d="M 259,431 Z" />
      <Path d="M 286,430 Z" />
      <Path d="M 274,429 Z" />
      <Path d="M 321,428 Z" />
      <Path d="M 289,426 L 287,428 Z" />
      <Path d="M 294,425 Z" />
      <Path d="M 390,420 L 389,421 Z" />
      <Path d="M 397,414 Z" />
      <Path d="M 400,411 Z" />
      <Path d="M 403,409 Z" />
      <Path d="M 315,408 Z" />
      <Path d="M 502,398 Z" />
      <Path d="M 502,391 Z" />
      <Path d="M 430,389 Z" />
      <Path d="M 427,389 Z" />
      <Path d="M 501,388 Z" />
      <Path d="M 309,388 Z" />
      <Path d="M 331,386 Z" />
      <Path d="M 496,385 Z" />
      <Path d="M 494,382 Z" />
      <Path d="M 306,382 Z" />
      <Path d="M 511,381 Z" />
      <Path d="M 303,381 Z" />
      <Path d="M 226,381 Z" />
      <Path d="M 493,380 Z" />
      <Path d="M 301,380 Z" />
      <Path d="M 189,379 Z" />
      <Path d="M 508,378 Z" />
      <Path d="M 229,378 Z" />
      <Path d="M 493,377 Z" />
      <Path d="M 490,377 Z" />
      <Path d="M 301,377 Z" />
      <Path d="M 233,377 Z" />
      <Path d="M 506,369 Z" />
      <Path d="M 294,369 Z" />
      <Path d="M 510,368 L 511,369 L 510,370 L 511,369 Z" />
      <Path d="M 504,368 Z" />
      <Path d="M 325,367 Z" />
      <Path d="M 249,367 Z" />
      <Path d="M 251,366 Z" />
      <Path d="M 399,363 Z" />
      <Path d="M 260,363 L 261,363 Z" />
      <Path d="M 263,362 Z" />
      <Path d="M 494,361 Z" />
      <Path d="M 283,359 Z" />
      <Path d="M 261,359 Z" />
      <Path d="M 488,356 Z" />
      <Path d="M 258,355 Z" />
      <Path d="M 324,354 Z" />
      <Path d="M 471,349 Z" />
      <Path d="M 65,347 Z" />
      <Path d="M 431,346 Z" />
      <Path d="M 277,344 Z" />
      <Path d="M 80,321 Z" />
      <Path d="M 285,313 Z" />
      <Path d="M 91,300 Z" />
      <Path d="M 301,276 Z" />
      <Path d="M 106,268 Z" />
      <Path d="M 270,255 Z" />
      <Path d="M 278,250 Z" />
      <Path d="M 276,250 Z" />
      <Path d="M 270,249 L 271,250 L 271,251 L 272,252 L 272,253 L 273,254 L 273,255 L 274,256 L 274,257 L 275,258 L 275,259 L 276,260 L 276,261 L 277,262 L 277,263 L 278,264 L 278,266 L 279,267 L 279,268 L 280,269 L 280,271 L 281,272 L 281,273 L 282,274 L 282,275 L 283,276 L 283,278 L 284,279 L 284,281 L 285,282 L 285,284 L 286,285 L 286,287 L 287,288 L 287,289 L 288,290 L 288,292 L 289,293 L 289,296 L 290,297 L 290,300 L 291,301 L 291,303 L 292,304 L 292,305 L 293,306 L 293,308 L 294,309 L 294,311 L 295,312 L 295,314 L 296,315 L 296,317 L 297,318 L 297,320 L 298,321 L 298,324 L 299,325 L 299,327 L 300,328 L 300,332 L 301,333 L 301,337 L 302,338 L 302,343 L 303,344 L 303,351 L 304,352 L 304,367 L 303,368 L 303,376 L 304,377 L 303,378 L 304,377 L 308,381 L 308,382 L 309,383 L 309,384 L 310,385 L 310,386 L 311,387 L 311,388 L 312,389 L 312,391 L 313,392 L 313,393 L 314,394 L 314,395 L 315,396 L 315,397 L 316,398 L 316,400 L 317,401 L 317,402 L 318,403 L 318,404 L 319,405 L 319,407 L 320,408 L 320,409 L 321,410 L 321,412 L 322,413 L 322,416 L 321,417 L 321,418 L 320,419 L 320,422 L 321,423 L 321,424 L 322,425 L 322,426 L 324,428 L 324,429 L 325,430 L 325,431 L 327,433 L 327,434 L 329,436 L 329,437 L 331,439 L 331,440 L 333,442 L 333,443 L 335,445 L 335,446 L 337,448 L 337,449 L 338,450 L 340,450 L 341,449 L 343,449 L 344,448 L 345,448 L 346,447 L 348,447 L 349,446 L 350,446 L 351,445 L 352,445 L 353,444 L 354,444 L 355,443 L 356,443 L 357,442 L 358,442 L 360,440 L 361,440 L 362,439 L 363,439 L 365,437 L 366,437 L 367,436 L 368,436 L 371,433 L 372,433 L 375,430 L 376,430 L 381,425 L 382,425 L 386,421 L 387,422 L 386,421 L 389,418 L 390,418 L 402,406 L 403,406 L 423,386 L 424,386 L 424,385 L 425,384 L 426,384 L 427,385 L 426,384 L 426,383 L 427,382 L 428,382 L 429,383 L 428,382 L 428,381 L 430,379 L 431,379 L 432,380 L 435,380 L 436,381 L 440,381 L 441,382 L 445,382 L 446,383 L 457,383 L 458,382 L 459,382 L 460,381 L 461,381 L 462,382 L 460,384 L 461,385 L 462,385 L 463,386 L 464,386 L 466,388 L 465,389 L 466,388 L 467,388 L 476,397 L 477,397 L 478,398 L 479,398 L 480,399 L 484,399 L 485,398 L 485,396 L 484,395 L 484,393 L 483,392 L 484,391 L 485,391 L 488,394 L 489,394 L 491,396 L 492,396 L 493,397 L 499,397 L 500,396 L 501,396 L 501,393 L 500,392 L 500,391 L 499,390 L 498,390 L 483,375 L 484,374 L 485,374 L 486,375 L 485,374 L 484,374 L 483,373 L 484,374 L 483,375 L 482,375 L 480,373 L 479,373 L 477,371 L 476,371 L 475,370 L 474,370 L 473,369 L 472,369 L 470,367 L 469,367 L 468,366 L 467,366 L 466,365 L 467,364 L 471,364 L 472,365 L 476,365 L 477,366 L 478,366 L 479,367 L 480,367 L 481,368 L 482,368 L 483,369 L 484,369 L 486,371 L 487,371 L 488,372 L 489,372 L 491,374 L 492,374 L 493,375 L 494,375 L 495,376 L 497,376 L 498,377 L 501,377 L 502,378 L 503,377 L 505,377 L 506,376 L 507,376 L 508,375 L 508,374 L 507,373 L 507,372 L 506,372 L 504,370 L 503,370 L 501,368 L 500,368 L 499,367 L 498,367 L 495,364 L 496,363 L 495,364 L 494,364 L 489,359 L 488,359 L 487,358 L 486,358 L 485,357 L 484,357 L 483,356 L 482,356 L 481,355 L 480,355 L 479,354 L 478,354 L 477,353 L 475,353 L 474,352 L 472,352 L 471,351 L 470,351 L 469,350 L 468,350 L 467,349 L 452,349 L 451,348 L 439,348 L 438,347 L 436,347 L 435,348 L 430,348 L 429,349 L 428,349 L 426,351 L 425,351 L 424,350 L 425,351 L 424,352 L 423,352 L 421,354 L 420,354 L 419,355 L 418,355 L 417,356 L 416,356 L 415,357 L 414,357 L 413,358 L 412,358 L 411,359 L 410,359 L 409,360 L 408,360 L 406,362 L 405,362 L 404,363 L 403,363 L 402,364 L 401,364 L 400,365 L 399,365 L 397,367 L 396,367 L 395,368 L 394,368 L 393,369 L 392,369 L 390,371 L 389,371 L 387,373 L 386,373 L 385,374 L 384,374 L 383,375 L 382,375 L 380,377 L 379,377 L 377,379 L 376,379 L 375,380 L 374,380 L 373,381 L 372,381 L 370,383 L 369,383 L 368,384 L 367,384 L 366,385 L 365,385 L 364,386 L 363,386 L 362,387 L 361,387 L 359,389 L 357,389 L 356,390 L 355,390 L 354,391 L 353,391 L 352,392 L 351,392 L 350,393 L 349,393 L 348,394 L 347,394 L 346,395 L 345,395 L 344,396 L 343,396 L 342,397 L 340,397 L 339,396 L 340,397 L 339,398 L 338,398 L 337,399 L 336,399 L 335,400 L 333,398 L 333,397 L 332,396 L 332,394 L 331,393 L 331,392 L 330,391 L 330,389 L 329,388 L 329,386 L 328,385 L 328,383 L 327,382 L 327,380 L 326,379 L 326,376 L 325,375 L 325,373 L 324,372 L 324,370 L 323,369 L 323,366 L 324,365 L 323,366 L 322,365 L 322,364 L 324,362 L 324,358 L 323,357 L 323,356 L 322,355 L 322,352 L 321,351 L 321,350 L 320,349 L 320,347 L 319,346 L 319,344 L 318,343 L 318,340 L 317,339 L 317,336 L 316,335 L 316,333 L 315,332 L 315,329 L 314,328 L 314,325 L 313,324 L 313,321 L 312,320 L 312,316 L 311,315 L 311,312 L 310,311 L 310,308 L 309,307 L 309,304 L 308,303 L 308,300 L 307,299 L 307,296 L 306,295 L 306,293 L 305,292 L 305,289 L 304,288 L 304,286 L 303,285 L 303,284 L 302,283 L 302,282 L 301,281 L 301,279 L 299,277 L 299,276 L 298,275 L 298,274 L 295,271 L 295,270 L 289,264 L 288,264 L 282,258 L 281,258 L 277,254 L 276,254 L 271,249 Z" />
      <Path d="M 322,234 Z" />
      <Path d="M 136,234 Z" />
      <Path d="M 151,228 Z" />
      <Path d="M 190,224 Z" />
      <Path d="M 332,222 Z" />
      <Path d="M 332,220 Z" />
      <Path d="M 176,219 Z" />
      <Path d="M 182,218 L 181,219 L 180,219 L 179,220 L 178,220 L 177,221 L 175,221 L 174,222 L 173,222 L 172,223 L 171,223 L 170,224 L 168,224 L 167,225 L 166,225 L 165,226 L 163,226 L 162,227 L 161,227 L 160,228 L 158,228 L 157,229 L 155,229 L 154,230 L 153,230 L 152,231 L 150,231 L 149,232 L 148,232 L 147,233 L 146,233 L 145,234 L 144,234 L 143,235 L 142,235 L 141,236 L 140,236 L 138,238 L 137,238 L 136,237 L 137,236 L 136,237 L 137,238 L 135,240 L 134,240 L 130,244 L 129,244 L 124,249 L 123,248 L 124,249 L 121,252 L 121,253 L 117,257 L 117,258 L 115,260 L 115,261 L 113,263 L 113,264 L 111,266 L 111,267 L 110,268 L 110,269 L 108,271 L 108,272 L 107,273 L 107,274 L 106,275 L 106,276 L 104,278 L 104,279 L 103,280 L 103,281 L 102,282 L 102,283 L 101,284 L 101,285 L 100,286 L 100,287 L 99,288 L 99,289 L 98,290 L 98,291 L 97,292 L 97,293 L 96,294 L 96,295 L 95,296 L 95,297 L 94,298 L 94,299 L 93,300 L 93,301 L 91,303 L 91,304 L 90,305 L 90,306 L 89,307 L 89,308 L 88,309 L 88,310 L 87,311 L 87,312 L 86,313 L 86,314 L 85,315 L 85,316 L 84,317 L 84,318 L 83,319 L 83,320 L 82,321 L 82,322 L 80,324 L 80,325 L 79,326 L 79,327 L 78,328 L 78,329 L 76,331 L 76,332 L 75,333 L 75,334 L 74,335 L 74,336 L 73,337 L 73,338 L 71,340 L 71,341 L 70,342 L 70,343 L 69,344 L 70,345 L 72,345 L 73,346 L 74,346 L 75,347 L 75,349 L 74,350 L 74,351 L 73,352 L 73,354 L 72,355 L 72,356 L 71,357 L 71,359 L 69,361 L 69,363 L 68,364 L 68,365 L 67,366 L 67,367 L 66,368 L 66,370 L 65,371 L 65,372 L 64,373 L 64,375 L 63,376 L 63,377 L 62,378 L 62,379 L 61,380 L 61,382 L 60,383 L 60,385 L 59,386 L 59,387 L 58,388 L 58,389 L 57,390 L 57,392 L 56,393 L 56,395 L 55,396 L 55,397 L 54,398 L 54,400 L 53,401 L 52,400 L 53,401 L 53,403 L 52,404 L 52,407 L 51,408 L 51,410 L 50,411 L 50,414 L 49,415 L 49,421 L 48,422 L 48,428 L 49,429 L 49,433 L 50,434 L 50,437 L 51,438 L 51,439 L 54,442 L 54,443 L 55,444 L 56,444 L 57,445 L 58,445 L 59,446 L 73,446 L 74,447 L 87,447 L 88,448 L 108,448 L 109,447 L 119,447 L 120,446 L 127,446 L 128,445 L 133,445 L 134,444 L 138,444 L 139,443 L 143,443 L 144,442 L 148,442 L 149,441 L 151,441 L 152,440 L 156,440 L 157,439 L 160,439 L 161,438 L 164,438 L 165,437 L 167,437 L 168,436 L 171,436 L 172,435 L 175,435 L 176,434 L 178,434 L 179,433 L 181,433 L 182,432 L 185,432 L 186,431 L 188,431 L 189,430 L 191,430 L 192,429 L 195,429 L 196,428 L 198,428 L 199,427 L 201,427 L 202,426 L 204,426 L 205,425 L 208,425 L 209,424 L 211,424 L 212,423 L 214,423 L 215,422 L 216,422 L 217,423 L 219,423 L 220,424 L 223,424 L 224,425 L 233,425 L 234,424 L 238,424 L 239,423 L 241,423 L 242,422 L 243,422 L 244,421 L 245,421 L 246,420 L 247,420 L 248,419 L 249,419 L 251,417 L 252,417 L 253,416 L 254,417 L 258,417 L 259,418 L 260,418 L 261,419 L 260,420 L 260,421 L 259,422 L 259,423 L 258,424 L 258,427 L 259,428 L 272,428 L 273,427 L 274,427 L 275,426 L 276,426 L 277,425 L 279,425 L 280,426 L 281,426 L 282,427 L 283,427 L 284,426 L 285,426 L 286,425 L 287,425 L 289,423 L 290,423 L 291,424 L 290,423 L 291,422 L 291,418 L 292,417 L 293,418 L 292,417 L 292,409 L 291,408 L 291,405 L 290,404 L 290,403 L 289,402 L 289,401 L 288,400 L 288,399 L 289,398 L 288,399 L 286,397 L 287,396 L 285,394 L 286,393 L 287,393 L 292,398 L 292,399 L 293,400 L 293,401 L 294,402 L 294,404 L 295,405 L 295,407 L 296,408 L 296,410 L 297,411 L 297,412 L 298,413 L 298,416 L 297,417 L 297,419 L 296,420 L 296,421 L 295,422 L 293,422 L 293,423 L 294,423 L 295,422 L 298,425 L 298,426 L 297,427 L 298,426 L 301,429 L 301,430 L 304,433 L 304,434 L 306,436 L 306,437 L 307,438 L 307,439 L 309,441 L 309,442 L 310,443 L 310,444 L 311,445 L 311,446 L 313,448 L 313,449 L 314,450 L 314,451 L 315,452 L 315,453 L 317,455 L 317,456 L 318,457 L 318,458 L 319,459 L 319,460 L 320,461 L 320,462 L 322,464 L 322,466 L 321,467 L 321,475 L 322,476 L 322,479 L 323,480 L 323,482 L 324,483 L 324,484 L 326,486 L 326,487 L 327,487 L 328,488 L 331,488 L 332,489 L 354,489 L 355,490 L 372,490 L 372,489 L 371,488 L 371,487 L 369,485 L 369,484 L 363,478 L 364,477 L 363,478 L 361,476 L 362,475 L 361,474 L 360,475 L 359,475 L 356,472 L 355,472 L 353,470 L 352,470 L 351,469 L 350,469 L 348,467 L 347,467 L 346,466 L 345,466 L 344,465 L 343,465 L 342,464 L 341,464 L 340,463 L 341,462 L 340,463 L 336,459 L 337,458 L 336,459 L 333,456 L 333,455 L 331,453 L 331,452 L 328,449 L 328,448 L 326,446 L 326,445 L 324,443 L 324,442 L 322,440 L 322,439 L 321,438 L 321,437 L 319,435 L 319,434 L 317,432 L 317,431 L 316,430 L 316,429 L 314,427 L 314,426 L 313,425 L 313,424 L 311,422 L 311,421 L 310,420 L 313,417 L 313,412 L 312,411 L 312,410 L 311,409 L 311,407 L 310,406 L 310,405 L 309,404 L 309,403 L 308,402 L 308,400 L 307,399 L 307,398 L 306,397 L 306,395 L 305,394 L 305,393 L 304,392 L 304,391 L 303,390 L 303,388 L 302,387 L 302,386 L 301,385 L 301,384 L 300,383 L 300,382 L 298,380 L 298,379 L 297,378 L 296,378 L 294,376 L 293,376 L 292,375 L 291,375 L 287,371 L 287,370 L 288,369 L 287,370 L 286,369 L 286,368 L 284,366 L 284,365 L 283,364 L 283,363 L 282,362 L 282,361 L 280,359 L 280,358 L 278,356 L 278,355 L 276,353 L 276,352 L 274,350 L 274,349 L 272,347 L 272,346 L 270,344 L 270,343 L 268,341 L 262,341 L 261,342 L 260,342 L 259,343 L 258,343 L 258,344 L 257,345 L 257,350 L 258,351 L 258,352 L 260,354 L 260,355 L 263,358 L 263,359 L 266,362 L 266,363 L 265,364 L 266,363 L 269,366 L 269,367 L 268,368 L 267,368 L 266,367 L 264,367 L 263,366 L 262,366 L 261,365 L 256,365 L 254,367 L 253,367 L 252,368 L 251,368 L 249,370 L 248,370 L 247,371 L 246,371 L 244,373 L 243,373 L 242,374 L 241,374 L 239,376 L 238,376 L 237,377 L 236,377 L 234,379 L 233,379 L 232,380 L 231,380 L 230,381 L 229,381 L 227,383 L 226,383 L 225,384 L 224,384 L 222,386 L 221,386 L 220,387 L 219,387 L 218,388 L 217,388 L 215,390 L 214,390 L 213,391 L 211,391 L 210,392 L 208,392 L 207,393 L 202,393 L 201,394 L 193,394 L 192,395 L 180,395 L 179,396 L 175,396 L 174,395 L 175,394 L 175,393 L 178,390 L 178,389 L 180,387 L 180,386 L 182,384 L 182,383 L 184,381 L 184,380 L 185,379 L 185,378 L 187,376 L 187,375 L 188,374 L 188,373 L 189,372 L 189,371 L 191,369 L 191,368 L 192,367 L 192,366 L 193,365 L 193,363 L 194,362 L 194,360 L 195,359 L 195,358 L 196,357 L 196,355 L 197,354 L 197,352 L 198,351 L 198,348 L 199,347 L 199,344 L 200,343 L 200,339 L 201,338 L 201,331 L 202,330 L 202,306 L 201,305 L 201,296 L 200,295 L 200,288 L 199,287 L 199,282 L 198,281 L 198,276 L 197,275 L 197,270 L 196,269 L 196,266 L 195,265 L 195,261 L 194,260 L 194,256 L 193,255 L 193,252 L 192,251 L 192,248 L 191,247 L 191,243 L 190,242 L 190,240 L 189,239 L 189,236 L 188,235 L 188,232 L 187,231 L 187,229 L 186,228 L 186,227 L 185,226 L 185,224 L 184,223 L 184,222 L 183,221 L 183,220 L 182,219 Z" />
      <Path d="M 180,217 Z" />
      <Path d="M 194,214 Z" />
      <Path d="M 195,210 Z" />
      <Path d="M 132,205 Z" />
      <Path d="M 129,205 Z" />
      <Path d="M 131,201 Z" />
      <Path d="M 359,194 Z" />
      <Path d="M 134,194 Z" />
      <Path d="M 210,193 Z" />
      <Path d="M 130,191 Z" />
      <Path d="M 200,190 L 201,191 Z" />
      <Path d="M 201,188 Z" />
      <Path d="M 132,180 Z" />
      <Path d="M 147,168 Z" />
      <Path d="M 375,147 Z" />
      <Path d="M 373,146 Z" />
      <Path d="M 378,142 Z" />
      <Path d="M 380,136 Z" />
      <Path d="M 381,100 Z" />
      <Path d="M 375,93 Z" />
      <Path d="M 366,83 Z" />
      <Path d="M 176,58 Z" />
      <Path d="M 334,52 Z" />
      <Path d="M 331,49 Z" />
      <Path d="M 248,45 Z" />
      <Path d="M 309,42 Z" />
      <Path d="M 306,41 L 307,41 Z" />
      <Path d="M 277,40 L 276,41 L 270,41 L 269,42 L 266,42 L 265,43 L 262,43 L 261,44 L 260,44 L 259,45 L 257,45 L 256,46 L 254,46 L 253,47 L 252,47 L 251,46 L 252,47 L 251,48 L 250,48 L 248,50 L 247,50 L 246,51 L 245,51 L 243,53 L 242,53 L 239,56 L 238,56 L 228,66 L 228,67 L 227,68 L 224,65 L 223,65 L 222,64 L 221,64 L 219,62 L 218,62 L 217,61 L 216,61 L 215,60 L 214,60 L 213,59 L 212,59 L 211,58 L 209,58 L 208,57 L 205,57 L 204,56 L 193,56 L 192,57 L 189,57 L 188,58 L 186,58 L 185,59 L 184,59 L 183,60 L 182,60 L 181,61 L 180,61 L 178,63 L 177,63 L 167,73 L 166,72 L 167,73 L 167,74 L 165,76 L 165,77 L 164,78 L 164,79 L 162,81 L 162,82 L 161,83 L 161,85 L 160,86 L 160,87 L 159,88 L 159,91 L 158,92 L 158,94 L 157,95 L 157,100 L 156,101 L 156,129 L 157,130 L 157,140 L 158,141 L 158,149 L 157,150 L 157,157 L 156,158 L 156,162 L 155,163 L 155,165 L 154,166 L 154,168 L 153,169 L 153,170 L 152,171 L 152,172 L 150,174 L 150,175 L 146,179 L 145,179 L 143,181 L 142,181 L 141,182 L 139,182 L 138,183 L 133,183 L 132,182 L 131,182 L 129,180 L 128,180 L 128,181 L 129,182 L 129,183 L 130,184 L 130,185 L 131,186 L 131,187 L 133,189 L 132,190 L 133,189 L 134,190 L 135,190 L 137,192 L 138,192 L 139,193 L 140,193 L 141,194 L 143,194 L 144,195 L 147,195 L 148,196 L 147,197 L 136,197 L 135,196 L 136,195 L 134,197 L 133,196 L 132,196 L 131,195 L 129,195 L 130,196 L 130,197 L 133,200 L 133,201 L 136,204 L 137,204 L 139,206 L 140,206 L 142,208 L 144,208 L 145,209 L 147,209 L 148,210 L 153,210 L 154,211 L 161,211 L 162,210 L 168,210 L 169,209 L 171,209 L 172,208 L 174,208 L 175,207 L 176,207 L 177,206 L 179,206 L 181,204 L 182,204 L 183,203 L 184,203 L 186,201 L 187,201 L 191,197 L 192,197 L 192,196 L 196,192 L 197,193 L 196,192 L 197,191 L 197,190 L 199,188 L 199,187 L 200,186 L 200,185 L 201,184 L 201,183 L 202,182 L 202,181 L 203,180 L 203,178 L 204,177 L 204,174 L 205,173 L 205,169 L 206,168 L 206,155 L 205,154 L 205,147 L 204,146 L 204,141 L 203,140 L 203,134 L 202,133 L 202,115 L 203,114 L 203,110 L 204,109 L 204,106 L 205,105 L 205,104 L 206,103 L 206,101 L 207,100 L 207,99 L 208,98 L 208,97 L 209,96 L 209,95 L 211,93 L 212,94 L 212,96 L 211,97 L 211,100 L 210,101 L 210,104 L 209,105 L 209,128 L 210,129 L 210,134 L 211,135 L 211,138 L 212,139 L 212,142 L 213,143 L 213,145 L 214,146 L 214,148 L 215,149 L 215,151 L 216,152 L 216,153 L 217,154 L 217,155 L 218,156 L 218,157 L 219,158 L 219,159 L 220,160 L 220,161 L 221,162 L 221,163 L 220,164 L 221,163 L 223,165 L 223,166 L 224,167 L 224,170 L 223,171 L 223,175 L 222,176 L 222,178 L 221,179 L 221,181 L 220,182 L 220,183 L 219,184 L 219,186 L 217,188 L 217,189 L 216,190 L 216,191 L 214,193 L 214,194 L 207,201 L 207,202 L 203,206 L 202,206 L 196,212 L 196,214 L 197,215 L 197,217 L 198,218 L 198,220 L 199,221 L 199,223 L 200,224 L 200,226 L 201,227 L 201,230 L 202,231 L 202,233 L 203,234 L 203,237 L 204,238 L 204,241 L 205,242 L 205,245 L 206,246 L 206,249 L 207,250 L 207,253 L 208,254 L 208,257 L 209,258 L 209,261 L 210,262 L 210,265 L 211,266 L 211,269 L 212,270 L 212,273 L 213,274 L 213,277 L 214,278 L 214,281 L 215,282 L 215,285 L 216,286 L 216,290 L 217,291 L 217,297 L 218,298 L 218,299 L 220,299 L 221,300 L 222,300 L 223,301 L 225,301 L 226,302 L 228,302 L 229,303 L 231,303 L 232,304 L 234,304 L 235,305 L 237,305 L 238,306 L 241,306 L 242,307 L 245,307 L 246,308 L 249,308 L 250,309 L 253,309 L 254,310 L 258,310 L 259,311 L 263,311 L 264,312 L 271,312 L 272,313 L 280,313 L 281,312 L 283,312 L 283,310 L 282,309 L 282,305 L 281,304 L 281,301 L 280,300 L 280,297 L 279,296 L 279,294 L 278,293 L 278,290 L 277,289 L 277,286 L 276,285 L 276,283 L 275,282 L 275,280 L 274,279 L 274,276 L 273,275 L 273,273 L 272,272 L 272,269 L 271,268 L 271,266 L 270,265 L 270,262 L 269,261 L 269,259 L 268,258 L 268,256 L 267,255 L 267,254 L 266,253 L 266,251 L 265,250 L 265,248 L 264,247 L 264,245 L 263,244 L 263,243 L 262,242 L 262,241 L 261,240 L 261,239 L 260,238 L 261,237 L 261,236 L 265,232 L 265,231 L 269,227 L 269,226 L 272,223 L 272,222 L 275,219 L 275,218 L 278,215 L 279,215 L 280,214 L 281,214 L 282,215 L 281,216 L 282,215 L 283,215 L 284,216 L 283,217 L 284,218 L 285,217 L 286,217 L 292,223 L 293,223 L 294,224 L 294,225 L 295,225 L 298,228 L 299,228 L 302,231 L 303,231 L 305,233 L 307,233 L 308,234 L 317,234 L 318,233 L 319,233 L 320,232 L 321,232 L 322,231 L 322,230 L 324,228 L 324,227 L 325,226 L 325,225 L 326,224 L 326,222 L 329,219 L 330,219 L 331,218 L 332,218 L 333,217 L 334,217 L 335,218 L 334,219 L 335,218 L 334,217 L 335,216 L 335,214 L 336,213 L 336,212 L 335,211 L 335,209 L 336,208 L 337,209 L 338,208 L 339,209 L 340,208 L 341,208 L 342,207 L 342,200 L 343,199 L 343,198 L 344,197 L 346,197 L 347,196 L 348,197 L 352,197 L 353,196 L 354,196 L 355,195 L 356,195 L 356,194 L 357,193 L 357,191 L 356,190 L 356,187 L 355,186 L 355,184 L 354,183 L 354,181 L 353,180 L 353,176 L 352,175 L 352,167 L 353,166 L 354,167 L 356,167 L 353,164 L 353,161 L 355,159 L 355,158 L 356,157 L 356,156 L 359,153 L 359,152 L 361,150 L 361,149 L 362,148 L 362,146 L 363,145 L 363,144 L 364,143 L 364,141 L 365,140 L 365,139 L 366,138 L 366,137 L 367,136 L 367,135 L 368,134 L 368,133 L 369,132 L 369,131 L 370,130 L 370,129 L 371,128 L 371,127 L 372,126 L 373,127 L 373,129 L 372,130 L 372,135 L 371,136 L 371,138 L 370,139 L 370,141 L 369,142 L 369,144 L 368,145 L 368,146 L 367,147 L 368,147 L 370,145 L 371,145 L 375,141 L 375,140 L 377,138 L 377,137 L 378,136 L 378,135 L 379,134 L 379,132 L 380,131 L 380,129 L 381,128 L 381,124 L 382,123 L 382,114 L 381,113 L 381,109 L 380,108 L 380,106 L 379,105 L 379,103 L 378,102 L 378,101 L 377,100 L 377,99 L 376,98 L 376,97 L 369,90 L 370,89 L 369,90 L 368,90 L 367,89 L 367,88 L 366,87 L 366,86 L 363,83 L 363,82 L 360,79 L 360,78 L 356,74 L 355,74 L 351,70 L 350,70 L 348,68 L 349,67 L 348,68 L 347,68 L 346,67 L 345,67 L 344,66 L 343,66 L 341,64 L 341,63 L 342,62 L 341,63 L 336,58 L 335,58 L 332,55 L 333,54 L 332,55 L 331,55 L 329,53 L 328,53 L 327,52 L 326,52 L 325,51 L 324,51 L 322,49 L 321,49 L 320,48 L 319,48 L 318,47 L 316,47 L 315,46 L 314,46 L 313,45 L 311,45 L 310,44 L 308,44 L 307,43 L 305,43 L 304,42 L 301,42 L 300,41 L 294,41 L 293,40 Z" />
    </G>
  </Svg>
);
export default KQTempRecipe;


--- FILE: src/utilities/avatarOptions.js ---

//* avatarOptions.js

export const categoryOptions = [
  'Background',
  'Skin',
  'Hair',
  'Shirt',
  'Glasses',
];

export const skinColorOptions = [
  'FFE2C5',
  'F9CBA8',
  'F3B28C',
  'E3A977',
  'D19A75',
  'C6885E',
  'B6764C',
  '9C6654',
  '6A3A2A',
];

export const hairColorOptions = [
  '1C1C1C',
  '3A2A20',
  '6B4B31',
  '9A5835',
  'C58644',
  'D4A763',
  'E7BF82',
  'F4D3A2',
  'B2B2B2',
];

export const colorOptions = [
  'FFFFFF',
  'F7EFEF',
  'F0E6E6',
  'E8D6C0',
  'DAE6F2',
  'D8BFD8',
  'B89BCF',
  'C7A7D9',
  '9E84B5',
  '8364A1',
  '7B92D6',
  '6DADD4',
  '56A7D3',
  '63B79C',
  '6DA78A',
  '88B76C',
  'A3B071',
  'D9CE6F',
  'EDD884',
  'F6C87A',
  'F9C88F',
  'F6A97A',
  'E27A74',
  'DA6A6A',
  'C56A60',
  'A57885',
  '8B5A4A',
  '4F4141',
  '373D43',
  '2C2F36',
];

export const hairStyleOptions = [
  'bigHair',
  'bob',
  'bun',
  'curly',
  'curvy',
  'dreads',
  'dreads01',
  'dreads02',
  'frizzle',
  'fro',
  'froBand',
  'longButNotTooLong',
  'miaWallace',
  'shaggy',
  'shaggyMullet',
  'shavedSides',
  'shortCurly',
  'shortFlat',
  'shortRound',
  'shortWaved',
  'sides',
  '',
  'straight01',
  'straight02',
  'straightAndStrand',
  'theCaesar',
  'hat',
  'turban',
  'hijab',
];

export const bgColorOptions = [
  'FFFFFF',
  'C4C4C4',
  'FCC945',
  '63B76C',
  '009DC4',
  'A781D5',
  '8364A1',
  'DA2C43',
  '373D43',
];

export const shirtOptions = [
  'blazerAndShirt',
  'blazerAndSweater',
  'collarAndSweater',
  'graphicShirt',
  'hoodie',
  'overall',
  'shirtCrewNeck',
  'shirtScoopNeck',
  'shirtVNeck',
];

export const graphicOptions = [
  '',
  'bat',
  'bear',
  'deer',
  'diamond',
  'pizza',
  'skull',
  'skullOutline',
];

export const glassesOptions = [
  '',
  'kurt',
  'prescription01',
  'prescription02',
  'round',
  'sunglasses',
  'wayfarers',
];

export const facialHairOptions = [
  '',
  'beardLight',
  'beardMajestic',
  'beardMedium',
  'moustacheFancy',
  'moustacheMagnum',
];

export const avatarConfig = {
  Background: [
    {text: 'BG Color', optionKey: 'bgColor', optionsArray: bgColorOptions},
  ],
  Skin: [
    {
      text: 'Skin Tone',
      optionKey: 'skinColor',
      optionsArray: skinColorOptions,
    },
  ],
  Hair: [
    {
      text: 'Hair Style',
      optionKey: 'hairStyle',
      optionsArray: hairStyleOptions,
    },
    {
      text: 'Hair Color',
      optionKey: 'hairColor',
      optionsArray: hairColorOptions,
    },
    {
      text: 'Facial Hair',
      optionKey: 'facialHair',
      optionsArray: facialHairOptions,
    },
  ],
  Shirt: [
    {
      text: 'Shirt Style',
      optionKey: 'shirtStyle',
      optionsArray: shirtOptions,
    },
    {
      text: 'Shirt Color',
      optionKey: 'shirtColor',
      optionsArray: colorOptions,
    },
    {
      text: 'Graphic',
      optionKey: 'clothingGraphic',
      optionsArray: graphicOptions,
    },
  ],
  Glasses: [
    {
      text: 'Glasses Style',
      optionKey: 'glasses',
      optionsArray: glassesOptions,
    },
    {
      text: 'Glasses Color',
      optionKey: 'glassesColor',
      optionsArray: colorOptions,
    },
  ],
};


--- FILE: src/utilities/cameraRequest.js ---

//* cameraRequest.js

import {Camera} from 'react-native-vision-camera';

export const requestCameraPermission = async () => {
  const status = await Camera.getCameraPermissionStatus(); // ✅ Add await

  if (status === 'authorized') return true;

  const newStatus = await Camera.requestCameraPermission();

  return newStatus === 'authorized' || newStatus === 'granted';
};


--- FILE: src/utilities/categories.js ---

//* categories.js

export const displayCategories = [
  {index: 0, key: 'custom', label: 'Custom (Enter Your Own)', bg: '#29856c'},
  {index: 1, key: 'na', label: 'No Category', bg: '#29856c'},
  {index: 2, key: 'meats-seafood', label: 'Meat & Seafood', bg: '#8B0000'},
  {index: 3, key: 'dairy', label: 'Dairy & Eggs', bg: '#437aa8'},
  {index: 4, key: 'produce', label: 'Produce', bg: '#2E8B57'},
  {index: 5, key: 'frozen', label: 'Frozen Goods', bg: '#437aa8'},
  {index: 6, key: 'baked', label: 'Baked Goods', bg: '#a27444'},
  {index: 7, key: 'dry-pasta', label: 'Dry Goods & Pasta', bg: '#a27444'},
  {index: 8, key: 'condiments', label: 'Condiments & Sauces', bg: '#A0522D'},
  {index: 9, key: 'canned', label: 'Canned Goods', bg: '#687887'},
  {index: 10, key: 'spices', label: 'Oils, Vinegars & Spices', bg: '#cf6c2a'},
  {index: 11, key: 'baking', label: 'Baking Ingredients', bg: '#a27444'},
  {index: 12, key: 'cereals', label: 'Breakfast & Cereal', bg: '#946e47'},
  {index: 13, key: 'snacks', label: 'Snacks & Candy', bg: '#be506c'},
  {index: 14, key: 'beverages', label: 'Beverages', bg: '#437aa8'},
  {index: 15, key: 'other', label: 'Other', bg: '#29856c'},
];

export const formatCategories = category => {
  if (!category) return '';

  // Check if category exists in displayCategories
  const match = displayCategories.find(c => c.key === category);
  if (match) return match.label;

  // Fallback: Format the raw string (for custom inputs)
  return category
    .replace(/-/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};

export const categoryColors = category => {
  const found = displayCategories.find(cat => cat.key === category);

  if (category === undefined || category === null) {
    return '#29856c';
  } else if (found) {
    return found.bg;
  } else {
    return '#29856c';
  }
};


--- FILE: src/utilities/checkImage.js ---

import storage from '@react-native-firebase/storage';

export const checkImage = async path => {
  console.log('📦 checkImage got path:', path);
  try {
    const ref = storage().ref(path);
    // console.log('📦 got ref, fetching download URL...');
    const url = await ref.getDownloadURL();
    // console.log('📦 success, URL:', url);
    return url;
  } catch (error) {
    // console.log('📦 checkImage error:', error);
    if (error.code === 'storage/object-not-found') {
      return null;
    }
    throw error;
  }
};

export const deletePicture = async fileName => {
  if (!fileName) {
    console.error('❌ No filename provided to deletePicture');
    return;
  }

  try {
    const ref = storage().ref(`recipes/${fileName}`);

    // Try to get metadata first (confirms it exists)
    await ref.getMetadata();
    // console.log(`📂 Found image: ${fileName}`);

    // Delete the file
    await ref.delete();
    // console.log(`🗑️ Successfully deleted image: ${fileName}`);
  } catch (error) {
    if (error.code === 'storage/object-not-found') {
      // console.error(`❌ File not found in storage: ${fileName}`);
    } else {
      // console.error(`❌ Failed to delete image ${fileName}:`, error);
    }
  }
};


--- FILE: src/utilities/checkLimit.js ---

import Toast from 'react-native-toast-message';

/**
 * Checks if the current count has reached the max allowed limit.
 * If the limit is exceeded, shows a friendly upgrade suggestion toast and returns false.
 *
 * @param {Object} params
 * @param {number} params.current - Current number of items
 * @param {number} params.max - Maximum allowed items
 * @param {string} params.label - Label for UI display ("Favorites", "Shopping Items", etc)
 * @returns {boolean} - false if over limit, true otherwise
 */
export const checkLimit = ({current, incoming = 0, max, label}) => {
  if (current >= max) {
    Toast.show({
      type: 'info',
      text1: `${label} Limit Reached`,
      text2: `You’ve reached your limit of ${max} ${label.toLowerCase()}. Please upgrade your subscription or remove some items to continue.`,
      visibilityTime: 5000,
    });
    return false;
  }

  if (current + incoming > max) {
    Toast.show({
      type: 'info',
      text1: `This will Exceed ${label} Limits`,
      text2: `This action would exceed your limit of ${max} ${label.toLowerCase()}. Please upgrade your subscription or remove some items to continue.`,
      visibilityTime: 8000,
    });
    return false;
  }

  return true;
};

export const dailyCheckLimit = ({current, max, label}) => {
  if (current >= max) {
    Toast.show({
      type: 'info',
      text1: `Daily ${label} Search Reached`,
      text2: `You’ve reached your limit of ${max} daily ${label.toLowerCase()} searches. Please upgrade your subscription or wait until it resets tomorrow.`,
      visibilityTime: 8000,
    });
    return false;
  }

  return true;
};


--- FILE: src/utilities/coreInfo.js ---

//* coreInfo.js
import {
  useUser,
  useAccount,
  useCupboard,
  useProfile,
  useShoppingCart,
  useFavorites,
  useRecipeBox,
} from '../hooks/useHooks';

export const useCoreInfo = () => {
  const user = useUser();
  const profile = useProfile();
  const account = useAccount();
  const shopping = useShoppingCart();
  const cupboard = useCupboard();
  const favorites = useFavorites();
  const recipeBox = useRecipeBox();

  return {
    // User
    userID: user?.uid,
    userEmail: user?.email,

    // Profile
    profileID: profile?.id || null,
    firstName: profile?.firstName || null,
    lastName: profile?.lastName || null,
    onlineName: profile?.onlineName || null,
    role: profile?.role || null,
    isActive: profile?.isActive || null,
    pictureApproved: profile?.pictureApproved || null,
    pictureUrl: profile?.pictureUrl || null,
    profileCreatedOn: profile?.createdOn || null,
    profileLastUpdated: profile?.lastUpdated || null,
    ppVersion: profile?.ppVersion || null,
    tosVersion: profile?.tosVersion || null,
    userSettings: profile?.userSettings || null,
    onboarding: profile?.onboarding || null,
    permissionsGranted: profile?.permissionsGranted || false,
    permissionsRequested: profile?.permissionsRequested || false,
    admin: profile?.admin || false,

    // Account
    accountID: account?.id || null,
    allowedUsers: account?.allowedUsers || null,
    shoppingCartID: account?.shoppingCartID || null,
    cupboardID: account?.cupboardID || null,
    recipeBoxID: account?.recipeBoxID || null,
    favoriteItemsID: account?.favoriteItemsID || null,
    accountCreatedOn: account?.createdOn || null,
    accountLastUpdated: account?.lastUpdated || null,
    accountLastUpdatedBy: account?.lastUpdatedBy || null,
    accountOwner: account?.owner || null,
    subType: account?.subType || null,
    maxShoppingItems: account?.shoppingCartLimit || null,
    maxCupboardItems: account?.cupboardLimit || null,
    maxRecipeBoxItems: account?.recipeBoxLimit || null,
    maxFavoriteItems: account?.favoriteItemsLimit || null,
    maxRecipeSearchLimit: account?.recipeSearchLimit || null,
    maxUPCSearchLimit: account?.upcSearchLimit || null,
    accountStatus: account?.isActive || null,

    // Shopping Cart Metadata
    shoppingCartLength:
      shopping?.items?.filter(item => item.status === 'shopping-cart').length ||
      0,
    shoppingListLength:
      shopping?.items?.filter(item => item.status === 'shopping-list').length ||
      0,
    shoppingAllItemsLength: shopping?.items?.length || 0,
    shoppingCreatedOn: shopping?.createdOn || null,
    shoppingLastUpdated: shopping?.lastUpdated || null,
    shoppingLastUpdatedBy: shopping?.lastUpdatedBy || null,

    // Cupboard Metadata
    cupboardLength: cupboard?.items?.length || 0,
    cupboardCreatedOn: cupboard?.createdOn || null,
    cupboardLastUpdated: cupboard?.lastUpdated || null,
    cupboardLastUpdatedBy: cupboard?.lastUpdatedBy || null,

    // Favorites Metadata - feature not yet implemented
    favoritesLength: favorites?.items?.length || 0,
    favoriteItemsCreatedOn: favorites?.createdOn || null,
    favoriteItemsLastUpdated: favorites?.lastUpdated || null,
    favoriteItemsLastUpdatedBy: favorites?.lastUpdatedBy || null,

    // Recipe Box Metadata
    recipeBoxLength: recipeBox?.items?.length || 0,
    recipeBoxCreatedOn: recipeBox?.createdOn || null,
    recipeBoxLastUpdated: recipeBox?.lastUpdated || null,
    recipeBoxLastUpdatedBy: recipeBox?.lastUpdatedBy || null,

    // Recipes Metadata - feature not yet implemented
    dailyRecipeCounter: account?.dailyRecipeCounter || 0,
    dailyUPCCounter: account?.dailyUPCCounter || 0,
  };
};


--- FILE: src/utilities/cuisineType.js ---

//* cuisineType.js
export const displayCuisineTypes = [
  {index: 0, label: 'African', value: 'african'},
  {index: 1, label: 'American', value: 'american'},
  {index: 2, label: 'British', value: 'british'},
  {index: 3, label: 'Cajun', value: 'cajun'},
  {index: 4, label: 'Caribbean', value: 'caribbean'},
  {index: 5, label: 'Chinese', value: 'chinese'},
  {index: 6, label: 'Eastern European', value: 'eastern european'},
  {index: 7, label: 'European', value: 'european'},
  {index: 8, label: 'French', value: 'french'},
  {index: 9, label: 'German', value: 'german'},
  {index: 10, label: 'Greek', value: 'greek'},
  {index: 11, label: 'Indian', value: 'indian'},
  {index: 12, label: 'Irish', value: 'irish'},
  {index: 13, label: 'Italian', value: 'italian'},
  {index: 14, label: 'Japanese', value: 'japanese'},
  {index: 15, label: 'Jewish', value: 'jewish'},
  {index: 16, label: 'Korean', value: 'korean'},
  {index: 17, label: 'Latin American', value: 'latin american'},
  {index: 18, label: 'Mediterranean', value: 'mediterranean'},
  {index: 19, label: 'Mexican', value: 'mexican'},
  {index: 20, label: 'Middle Eastern', value: 'middle eastern'},
  {index: 21, label: 'Nordic', value: 'nordic'},
  {index: 22, label: 'Southern', value: 'southern'},
  {index: 23, label: 'Spanish', value: 'spanish'},
  {index: 24, label: 'Thai', value: 'thai'},
  {index: 25, label: 'Vietnamese', value: 'vietnamese'},
  {index: 26, label: 'Other', value: 'other'},
];

export const formatCuisineType = cuisine => {
  if (!cuisine) return 'All';

  const match = displayCuisineTypes.find(c => c.value === cuisine);
  if (match) return match.label;

  return toTitleCase(cuisine);
};

const toTitleCase = str =>
  str
    .replace(/-/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');


--- FILE: src/utilities/dateTime.js ---

//* dateTime.js
import moment from 'moment';

export const getToday = () => {
  return moment(new Date()).format();
};

export const rawDateTime = timestamp => {
  if (!timestamp || !timestamp.toDate) return null;
  return moment(timestamp.toDate().toISOString()).format();
};

export const dateTimeStringDate = timestamp => {
  if (!timestamp || !timestamp.toDate) return null;
  return moment(timestamp.toDate().toISOString()).format('MMDDYYYY');
};

export const dateTimeStringTime = timestamp => {
  if (!timestamp || !timestamp.toDate) return null;
  return moment(timestamp.toDate().toISOString()).format('HHmmss');
};

export const dateTimeStringMDYT = timestamp => {
  if (!timestamp || !timestamp.toDate) return null;
  return moment(timestamp.toDate().toISOString()).format('MMDDYYYYYTHHmmss');
};

export const dateTimeDisplay = timestamp => {
  if (!timestamp || !timestamp.toDate) return null;
  return moment(timestamp.toDate().toISOString()).format('MM-DD-YYYY HH:mm:ss');
};

export const dateDisplay = timestamp => {
  if (!timestamp || !timestamp.toDate) return null;
  return moment(timestamp.toDate().toISOString()).format('MM-DD-YYYY');
};

export const timeDisplay = timestamp => {
  if (!timestamp || !timestamp.toDate) return null;
  return moment(timestamp.toDate().toISOString()).format('HH:mm:ss');
};


--- FILE: src/utilities/deviceUtils.js ---

import {useEffect, useRef, useState} from 'react';
import NavigationMode from 'react-native-navigation-mode';

// deviceUtils.js
export const hbDevices = [
  'iPhone SE',
  'iPad Air 3rd Gen (WiFi)',
  'iPad Air 3rd Gen (Cellular)',
  // Add other home-button models here as needed
];

export const isHBDevice = model => hbDevices.includes(model);

export const isAndroidPhone = device =>
  device?.system?.os === 'Android' && device?.system?.device === 'Handset';

export const isAndroidTablet = device =>
  device?.system?.os === 'Android' && device?.system?.device === 'Tablet';

export const isiOSPhone = device =>
  device?.system?.os === 'iOS' && device?.system?.device === 'Handset';

export const isiOSTablet = device =>
  device?.system?.os === 'iOS' && device?.system?.device === 'Tablet';

export const getMenuButtonHeight = (device, mode) => {
  const hasButtons = mode?.type !== 'gesture';

  const {deviceSize, model, os} = device?.system || {};
  const isHomeButton = isHBDevice(model);

  let baseHeight = 75; // Fallback for unknown devices (just to be safe)

  switch (deviceSize) {
    case 'xLarge':
      baseHeight = 75;
      break;
    case 'large':
      baseHeight = 75;
      break;
    case 'medium':
      baseHeight = 75;
      break;
    case 'small':
      baseHeight = 75;
      break;
    case 'xSmall':
      baseHeight = 65;
      break;
    default:
      baseHeight = 65; // Unknown devices default to xSmall
      break;
  }

  // Special adjustment for iOS devices
  if (os === 'iOS') {
    baseHeight -= 5;
  }

  if (os === 'Android' && hasButtons) {
    baseHeight -= 0;
  }

  // Special adjustment for home button devices
  if (isHomeButton) {
    baseHeight -= 10;
  }

  return baseHeight;
};

export const getNavMenuHeight = (device, mode) => {
  const hasButtons = mode?.type !== 'gesture';

  const {deviceSize, model, os} = device?.system || {};
  const isHomeButton = isHBDevice(model);

  let baseHeight = 90; // Fallback for unknown devices (just to be safe)

  switch (deviceSize) {
    case 'xLarge':
      baseHeight = 100;
      break;
    case 'large':
      baseHeight = 100;
      break;
    case 'medium':
      baseHeight = 100;
      break;
    case 'small':
      baseHeight = 100;
      break;
    case 'xSmall':
      baseHeight = 100;
      break;
    default:
      baseHeight = 90; // Unknown devices default to xSmall
      break;
  }

  // Special adjustment for iOS devices
  if (os === 'iOS') {
    baseHeight -= 5;
  }

  if (os === 'Android' && hasButtons) {
    baseHeight -= 40;
  }

  // Special adjustment for home button devices
  if (isHomeButton) {
    baseHeight -= 30;
  }

  return baseHeight;
};

export const getNavBarHeight = (device, baseHeight, navMode) => {
  const hasButtons = navMode?.type !== 'gesture';
  const {os} = device?.system || {};
  if (isHBDevice(device?.system?.model)) {
    return baseHeight;
  } else if (os === 'Android' && hasButtons) {
    return baseHeight;
  } else if (os === 'Android' && !hasButtons) {
    return baseHeight - 25;
  } else {
    return baseHeight - 20;
  }
};


--- FILE: src/utilities/dietType.js ---

//* dietType.js
export const displayDietTypes = [
  {value: 'diet-header-general', label: 'General Diets', isHeader: true},
  {index: 0, value: 'low-carb', label: 'Low Carb'},
  {index: 1, value: 'low-fat', label: 'Low Fat'},
  {index: 2, value: 'high-protein', label: 'High Protein'},
  {index: 3, value: 'low-sugar', label: 'Low Sugar'},

  {
    value: 'diet-header-lifestyle',
    label: 'Lifestyle & Philosophical',
    isHeader: true,
  },
  {index: 4, value: 'vegetarian', label: 'Vegetarian'},
  {index: 5, value: 'lacto-vegetarian', label: 'Lacto-Vegetarian'},
  {index: 6, value: 'ovo-vegetarian', label: 'Ovo-Vegetarian'},
  {index: 7, value: 'vegan', label: 'Vegan'},
  {index: 8, value: 'pescetarian', label: 'Pescetarian'},
  {index: 9, value: 'flexitarian', label: 'Flexitarian'},
  {index: 10, value: 'raw', label: 'Raw'},
  {index: 11, value: 'whole30', label: 'Whole30'},

  {
    value: 'diet-header-medical',
    label: 'Medical / Allergen Related',
    isHeader: true,
  },
  {index: 12, value: 'gluten-free', label: 'Gluten Free'},
  {index: 13, value: 'dairy-free', label: 'Dairy Free'},
  {index: 14, value: 'nut-free', label: 'Nut Free'},
  {index: 15, value: 'soy-free', label: 'Soy Free'},
  {index: 16, value: 'egg-free', label: 'Egg Free'},
  {index: 17, value: 'low-sodium', label: 'Low Sodium'},
  {index: 18, value: 'low-fodmap', label: 'Low FODMAP'},

  {value: 'diet-header-weight', label: 'Weight & Metabolic', isHeader: true},
  {index: 19, value: 'ketogenic', label: 'Ketogenic (Keto)'},
  {index: 20, value: 'paleo', label: 'Paleo'},
  {index: 21, value: 'atkins', label: 'Atkins'},
  {index: 22, value: 'mediterranean', label: 'Mediterranean'},
  {index: 23, value: 'dash', label: 'DASH'},
  {index: 24, value: 'diabetic', label: 'Diabetic Friendly'},

  {
    value: 'diet-header-cultural',
    label: 'Cultural / Religious',
    isHeader: true,
  },
  {index: 25, value: 'halal', label: 'Halal'},
  {index: 26, value: 'kosher', label: 'Kosher'},
];

export const formatDietType = diet => {
  if (!diet) return 'All';

  const match = displayDietTypes.find(d => d.value === diet);
  if (match) return match.label;

  return toTitleCase(diet);
};

const toTitleCase = str =>
  str
    .replace(/-/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');


--- FILE: src/utilities/dishType.js ---

export const displayDishTypes = [
  {index: 0, label: 'Breakfast', value: 'breakfast'},
  {index: 1, label: 'Brunch', value: 'brunch'},
  {index: 2, label: 'Lunch', value: 'lunch'},
  {index: 3, label: 'Supper', value: 'supper'},
  {index: 4, label: 'Dinner', value: 'dinner'},
  {index: 5, label: 'Snack', value: 'snack'},
  {index: 6, label: 'Dessert', value: 'dessert'},
  {index: 7, label: 'Breads / Baking', value: 'bread-baking'},
  {index: 8, label: 'Sauces', value: 'sauces'},
  {index: 9, label: 'Rubs', value: 'rubs'},
  {index: 10, label: 'Dips', value: 'dips'},
];

export const formatDishType = dish => {
  if (!dish) return 'All';

  const match = displayDishTypes.find(d => d.value === dish);
  if (match) return match.label;

  return toTitleCase(dish);
};

const toTitleCase = str =>
  str
    .replace(/-/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');


--- FILE: src/utilities/formatPluralUnit.js ---

//* formatPluralUnit.js
import pluralize from 'pluralize';
import {shortenUnit} from './shortenUnit';

// units we do NOT pluralize even when quantity > 1
const noPluralUnits = [
  'oz',
  'g',
  'ml',
  'kg',
  'mg',
  'l',
  'tsp',
  'tbsp',
  'fl oz',
];

export const formatPluralUnit = (amount, unit) => {
  if (!unit || typeof unit !== 'string') return '';

  const shortUnit = shortenUnit(unit); // display version
  if (!shortUnit || typeof shortUnit !== 'string') return '';

  const normalized = shortUnit.toLowerCase().trim();

  // If unit is intentionally removed (like 'each'), just return ''
  if (!normalized) return '';

  if (amount > 1 && !noPluralUnits.includes(normalized)) {
    return pluralize(shortUnit);
  }

  return shortUnit;
};


--- FILE: src/utilities/fractionUnit.js ---

//* fractionUnit.js

const fractionMap = {
  0.125: '⅛',
  0.167: '⅙',
  0.2: '⅕',
  0.25: '¼',
  0.333: '⅓',
  0.375: '⅜',
  0.4: '⅖',
  0.5: '½',
  0.6: '⅗',
  0.625: '⅝',
  0.667: '⅔',
  0.75: '¾',
  0.8: '⅘',
  0.833: '⅚',
  0.875: '⅞',
};

const roundTo = (value, step = 0.01) => Math.round(value / step) * step;

export const toFraction = amount => {
  if (typeof amount !== 'number') return amount;

  const whole = Math.floor(amount);
  const decimal = roundTo(amount - whole);

  let fraction = Object.entries(fractionMap).find(
    ([num]) => Math.abs(decimal - parseFloat(num)) < 0.02,
  );

  if (!fraction) return amount.toString(); // fallback

  const fractionStr = fraction[1];
  if (whole === 0) return fractionStr;
  return `${whole} ${fractionStr}`;
};


--- FILE: src/utilities/helpers.js ---

// helpers.js
import moment from 'moment';
import {displayMeasurements, formatMeasurement} from './measurements';
import pluralize from 'pluralize';

export const tempImageString = 'KitchenQueueTempRecipe.jpg';

//*helpers.js
export function displayDropField(value, mapData = []) {
  if (!value || typeof value !== 'string') return null;

  const lowerVal = value.trim().toLowerCase();
  const found = mapData.find(item => item.key === lowerVal);
  if (found) return found;

  const cleaned = lowerVal.replace(/\s+/g, '-');
  const label = cleaned
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');

  return {
    index: -1,
    key: cleaned,
    label,
  };
}

export function displayDropArray(valueArray, mapData = []) {
  if (!Array.isArray(valueArray)) return [];

  return valueArray
    .map(value => {
      if (!value || typeof value !== 'string') return null;

      const lowerVal = value.trim().toLowerCase();
      const found = mapData.find(item => item.key === lowerVal);
      if (found) return found;

      const cleaned = lowerVal.replace(/\s+/g, '-');
      const label = cleaned
        .split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');

      return {
        index: -1,
        key: cleaned,
        value: cleaned,
        label,
      };
    })
    .filter(Boolean);
}

export const setNumericValue = setter => value => {
  const cleaned = value.replace(/[^0-9.]/g, '');
  setter(cleaned);
};

export const titleCase = str => {
  if (!str) return ''; // Handle null or undefined inputs gracefully

  return str
    .toLowerCase() // Convert the entire string to lowercase first
    .split(' ') // Split the string into words
    .map(word => {
      // Capitalize the first letter and preserve the rest
      return word.charAt(0).toUpperCase() + word.slice(1);
    })
    .join(' '); // Rejoin the words into a single string
};

export const capFirst = str => {
  if (!str) return ''; // Handle null or undefined inputs gracefully

  const lowerCaseStr = str.toLowerCase(); // Convert entire string to lowercase
  return lowerCaseStr.charAt(0).toUpperCase() + lowerCaseStr.slice(1);
};

export const capEachWord = str => {
  if (!str) return '';
  return str
    .toLowerCase()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};

export const limitToThreeDecimals = value => {
  if (!value) return '';
  const num = parseFloat(value);
  if (isNaN(num)) return '';
  return num.toFixed(3).replace(/\.?0+$/, ''); // trims trailing zeros
};

export const endWithPeriod = str => {
  if (typeof str !== 'string') return '';
  return str.trim().endsWith('.') ? str.trim() : str.trim() + '.';
};

export const compareByDate = (date1, date2) => {
  if (!date1 || !date2) return false;

  return date1 === date2;
};

export const formatMeasurementWithPlural = (
  packageSize,
  quantity,
  unit,
  itemName,
) => {
  if (packageSize == null || unit == null) return '';

  // 'each' → always show PACK SIZE + SINGULAR item name (e.g., "1 Tomato", "6 Onion")
  if (unit === 'each') {
    const base = (
      pluralize?.singular ? pluralize.singular(itemName || '') : itemName || ''
    ).trim();
    const name =
      packageSize === 1
        ? base
        : pluralize?.plural
        ? pluralize.plural(base)
        : `${base}s`;
    return `${packageSize} ${name}`;
  }

  // measured units
  const match = displayMeasurements.find(m => m.key === unit);
  if (match) {
    const label = match.label;
    return `${packageSize} ${packageSize > 1 ? pluralize(label) : label}`;
  }

  // custom fallback
  const formatted = formatMeasurement(unit);
  return `${packageSize} ${packageSize > 1 ? pluralize(formatted) : formatted}`;
};

export const formatParagraph = (str = '') => {
  if (typeof str !== 'string') return '';

  // Step 1: normalize spacing + lowercase everything
  let text = str.trim().toLowerCase();

  // Step 2: split into sentences using punctuation marks
  const sentences = text
    .split(/([.!?])/)
    .map(s => s.trim())
    .filter(s => s.length > 0);

  // Step 3: rebuild sentences with capitalization
  let formatted = '';
  for (let i = 0; i < sentences.length; i++) {
    let part = sentences[i];
    if (/[.!?]/.test(part)) {
      // if it's just punctuation, append directly
      formatted += part + ' ';
    } else {
      // capitalize first letter of sentence text
      formatted += part.charAt(0).toUpperCase() + part.slice(1);
    }
  }

  // Step 4: trim trailing spaces
  formatted = formatted.trim();

  // Step 5: enforce final punctuation
  if (!/[.!?]$/.test(formatted)) {
    formatted += '.';
  }

  return formatted;
};

const UNIT_DISPLAY = {
  oz: 'Ounce',
  g: 'Gram',
  ml: 'mMilliliter',
  kg: 'Kilogram',
  mg: 'Milligram',
  l: 'Liter',
  tsp: 'Teaspoon',
  tbsp: 'Tablespoon',
  'fl oz': 'Fluid Ounce',
};

export const formatMeasurementWithPluralRec = (packageSize, unit, itemName) => {
  if (packageSize !== undefined && unit !== undefined) {
    // special-case "each"
    if (unit === 'each') {
      const name = packageSize > 1 ? pluralize(itemName) : itemName;
      return `${packageSize} ${capEachWord(name)}`;
    }

    // 🔑 check mapping first
    if (UNIT_DISPLAY[unit]) {
      const base = UNIT_DISPLAY[unit];
      const label = packageSize > 1 ? pluralize(base) : base;
      return `${packageSize} ${label} ${capEachWord(itemName)}`;
    }

    // fallback to displayMeasurements
    const match = displayMeasurements.find(m => m.key === unit);
    if (match) {
      const label = packageSize > 1 ? pluralize(match.label) : match.label;
      return `${packageSize} ${label} ${capEachWord(itemName)}`;
    }

    // ultimate fallback
    const formatted = formatMeasurement(unit);
    const label = packageSize > 1 ? pluralize(formatted) : formatted;
    return `${packageSize} ${label} ${capEachWord(itemName)}`;
  }

  return '';
};

const UNIT_REPLACEMENT = {
  oz: 'ounce',
  g: 'gram',
  ml: 'milliliter',
  kg: 'kilogram',
  mg: 'milligram',
  l: 'liter',
  tsp: 'teaspoon',
  tbsp: 'tablespoon',
  'fl oz': 'fluid ounce',
};

export const unitReplacement = unit => {
  if (!unit || typeof unit !== 'string') return unit ?? null;

  const key = unit.toLowerCase().trim();
  if (!key) return unit; // empty string, just return original

  return UNIT_REPLACEMENT[key] || unit;
};

// Logger function to handle console output with color coding and time stamps
// Use this function as a normal kqconsole.log using kqconsole.log('message', data);
// Be sure to import it from the helpers file to use this functionality

const makeLogger =
  type =>
  (...args) => {
    if (!__DEV__) return;

    const time = moment().format('HH:mm:ss:SSS');
    const color =
      {
        log: '#63b76C',
        warn: '#E6B800',
        error: '#D32F2F',
        debug: '#009DC4', // Alias for log
      }[type] || '#63b76C';

    const [first, ...rest] = args;
    const prefix = `%c[${time}]`;
    const style = `color: ${color};`;

    if (type === 'table') {
      const dataArgs = typeof first === 'object' && first?.title ? rest : args;

      const validTables = dataArgs.filter(
        item =>
          (Array.isArray(item) && item.length && typeof item[0] === 'object') ||
          (typeof item === 'object' && !Array.isArray(item) && item !== null),
      );

      if (!validTables.length) {
        kqconsole.log(prefix, style, 'Table (invalid data):', ...dataArgs);
      } else {
        validTables.forEach((item, index) => {
          const label = validTables.length > 1 ? `Table ${index + 1}` : 'Table';
          kqconsole.log(prefix, style, `${label}:`);
          console.table(item);
        });
      }

      return;
    } else {
      console[type](prefix, style, `${capEachWord(type)}:`, first, ...rest);
    }
  };

export const kqconsole = (...args) => makeLogger('log')(...args);

kqconsole.log = makeLogger('log');
kqconsole.warn = makeLogger('warn');
kqconsole.error = makeLogger('error');
kqconsole.table = makeLogger('table');


--- FILE: src/utilities/imageScale.js ---

// imageScale.js
import {Platform} from 'react-native';

export const imageScale = (origKB, opts = {}) => {
  const BASE_W = opts.baseW ?? 400;
  const BASE_H = opts.baseH ?? 400;
  const SCALE = opts.scale ?? 1.5; // ~688x425

  const TARGET_KB = opts.targetKB ?? 45;

  const ENC_KB_PER_QPX =
    opts.encKbPerQpx ?? (Platform.OS === 'android' ? 0.00022 : 0.00028);

  const MIN_Q = opts.minQ ?? (Platform.OS === 'android' ? 0.65 : 0.5);
  const MAX_Q = opts.maxQ ?? 0.95;

  // Parse original size (KB)
  const orig =
    Number(
      typeof origKB === 'string' ? origKB.replace(/[^\d.]/g, '') : origKB,
    ) || 0;

  // Small bias for very large originals (slightly more compression)
  const bias = orig >= 2600 ? 3 : orig >= 2000 ? 2 : 0;

  const width = Math.round(BASE_W * SCALE);
  const height = Math.round(BASE_H * SCALE);
  const area = width * height;

  let quality = (TARGET_KB - bias) / (ENC_KB_PER_QPX * area);
  quality = Math.max(MIN_Q, Math.min(MAX_Q, quality));
  const estimatedKB = Number((ENC_KB_PER_QPX * area * quality).toFixed(2));

  return {width, height, quality, estimatedKB};
};


--- FILE: src/utilities/materialSource.js ---

//* materialSource.js

export const displaySourceType = [
  {key: 'source-header-private', label: 'Private', isHeader: true},
  {index: 0, key: 'personal', label: 'Personal (Your Creatation)'},
  {index: 1, key: 'family', label: 'Family (Handed Down)'},
  {index: 2, key: 'friend', label: 'Friend (Shared in Person)'},
  {key: 'source-header-online', label: 'Online', isHeader: true},
  {index: 3, key: 'app', label: 'Mobile / Web App (Ex: Tasty,  ChatGPT etc.)'},
  {index: 4, key: 'social', label: 'Social Media (TikTok, Facebook, etc.)'},
  {index: 5, key: 'website', label: 'Website or Blog'},
  {key: 'source-header-published', label: 'Published', isHeader: true},
  {index: 6, key: 'cookbook', label: 'Cookbook (Betty Crocker, etc.)'},
  {index: 7, key: 'magazine', label: 'Magazine or Article'},
  {index: 8, key: 'package', label: 'Product Label (Bag, Box, etc.)'},
  {index: 9, key: 'restaurant', label: 'Restaurant (Inspired by)'},
  {index: 10, key: 'tv', label: 'TV Show (Food Network, PBS, etc.)'},
  {
    index: 11,
    key: 'event',
    label: 'Event/Class (Cooking demo, etc.)',
  },
];

export const formatSource = source => {
  if (!source) return '';

  const match = displaySourceType.find(m => m.key === source);
  if (match) return match.label;

  return source
    .replace(/-/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};


--- FILE: src/utilities/measurements.js ---

//* measurements.js

export const displayMeasurements = [
  {key: 'volume-header', label: 'Default', isHeader: true},
  {index: 0, key: 'custom', label: 'Custom (Enter Your Own)'},
  {index: 1, key: 'each', label: 'Single (Each)'},
  {key: 'volume-header', label: '─ Volume ─', isHeader: true},

  {index: 2, key: 'cup', label: 'Cup'},
  {index: 3, key: 'fluidounce', label: 'Fluid Ounce'},
  {index: 4, key: 'gallon', label: 'Gallon'},
  {index: 5, key: 'liter', label: 'Liter'},
  {index: 6, key: 'milliliter', label: 'Milliliter'},
  {index: 7, key: 'pint', label: 'Pint'},
  {index: 8, key: 'quart', label: 'Quart'},
  {index: 9, key: 'tablespoon', label: 'Tablespoon'},
  {index: 10, key: 'teaspoon', label: 'Teaspoon'},
  {key: 'weight-header', label: '─ Weight ─', isHeader: true},
  {index: 11, key: 'gram', label: 'Gram'},
  {index: 12, key: 'kilogram', label: 'Kilogram'},
  {index: 13, key: 'ounce', label: 'Ounce'},
  {index: 14, key: 'pound', label: 'Pound'},
  {key: 'single-header', label: '─ Single Unit ─', isHeader: true},
  {index: 15, key: 'bunch', label: 'Bunch'},
  {index: 16, key: 'clove', label: 'Clove'},
  {index: 17, key: 'dozen', label: 'Dozen'},
  {index: 18, key: 'head', label: 'Head'},
  {index: 19, key: 'piece', label: 'Piece'},
  {index: 20, key: 'serving', label: 'Serving'},
  {index: 21, key: 'stalk', label: 'Stalk'},
  {key: 'package-header', label: '─ Package / Form ─', isHeader: true},
  {index: 22, key: 'bag', label: 'Bag'},
  {index: 23, key: 'bar', label: 'Bar'},
  {index: 24, key: 'bottle', label: 'Bottle'},
  {index: 25, key: 'box', label: 'Box'},
  {index: 26, key: 'can', label: 'Can'},
  {index: 27, key: 'carton', label: 'Carton'},
  {index: 28, key: 'jar', label: 'Jar'},
  {index: 29, key: 'pack', label: 'Pack'},
  {index: 30, key: 'package', label: 'Package'},
  {index: 31, key: 'roll', label: 'Roll'},
  {index: 32, key: 'slice', label: 'Slice'},
  {index: 33, key: 'stick', label: 'Stick'},
  {index: 34, key: 'tube', label: 'Tube'},
];

export const formatMeasurement = measurement => {
  if (!measurement) return '';

  // Check if measurement exists in displayMeasurements
  const match = displayMeasurements.find(m => m.key === measurement);
  if (match) return match.label;

  // Fallback: Format the raw string (for custom inputs)
  return measurement
    .replace(/-/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};


--- FILE: src/utilities/normalizeTitle.js ---

const STOP_WORDS = new Set([
  'a',
  'an',
  'the',
  'and',
  'or',
  'but',
  'with',
  'of',
  'on',
  'in',
  'at',
  'to',
  'for',
  'from',
  'by',
  'is',
  'it',
  'this',
  'that',
  'these',
  'those',
  'as',
  'be',
  'was',
  'are',
  'were',
  'has',
  'have',
  'had',
  'will',
  'would',
  'can',
  'could',
  'should',
  'shall',
  'just',
  'very',
  'really',
  'so',
  'then',
  'than',
  'if',
  'not',
  'no',
  'yes',
  'you',
  'your',
  'we',
  'us',
  'our',
  'they',
  'them',
  'their',
  'he',
  'she',
  'his',
  'her',
  'its',
  'i',
  'me',
  'my',
  'mine',
  'do',
  'does',
  'did',
  'done',
  'up',
  'down',
  'over',
  'under',
  'again',
  'once',
  'only',
  'some',
  'many',
  'much',
  'every',
  'each',
  'all',
  '/w',
  'w/',
  'w/o',
  'w',
]);

export const normalizeTitleForKeywords = title => {
  if (!title || typeof title !== 'string') return [];

  const base = title.toLowerCase().trim();
  if (!base) return [];

  const words = base
    .replace(/[-_]/g, ' ') // convert hyphens/underscores to space
    .replace(/[^\w\s]/g, '') // remove punctuation
    .split(/\s+/) // split into words
    .filter(word => word && !STOP_WORDS.has(word));

  return Array.from(new Set([base, ...words]));
};


--- FILE: src/utilities/nutrients.js ---

//* nutrients.js

export const displayNutrients = [
  {index: 0, key: 'CA', label: 'Calcium', unit: 'mg'},
  {index: 1, key: 'CHOCDF', label: 'Total Carbohydrates', unit: 'g'},
  {index: 2, key: 'CHOCDF.net', label: 'Net Carbohydrates', unit: 'g'},
  {index: 3, key: 'CHOLE', label: 'Cholesterol', unit: 'mg'},
  {index: 4, key: 'ENERC_KCAL', label: 'Calories', unit: null},
  {index: 5, key: 'FAMS', label: 'Monounsaturated Fat', unit: 'g'},
  {index: 6, key: 'FAPU', label: 'Polyunsaturated Fat', unit: 'g'},
  {index: 7, key: 'FASAT', label: 'Saturated Fat', unit: 'g'},
  {index: 8, key: 'FATRN', label: 'Trans Fat', unit: 'g'},
  {index: 9, key: 'FAT', label: 'Total Fat', unit: 'g'},
  {index: 10, key: 'FE', label: 'Iron', unit: 'mg'},
  {index: 11, key: 'FIBTG', label: 'Dietary Fiber', unit: 'g'},
  {index: 12, key: 'FOLAC', label: 'Folic Acid', unit: 'µg'},
  {index: 13, key: 'FOLDFE', label: 'Folate (DFE)', unit: 'µg'},
  {index: 14, key: 'FOLFD', label: 'Folate (Food)', unit: 'µg'},
  {index: 15, key: 'K', label: 'Potassium', unit: 'mg'},
  {index: 16, key: 'MG', label: 'Magnesium', unit: 'mg'},
  {index: 17, key: 'NA', label: 'Sodium', unit: 'mg'},
  {index: 18, key: 'NIA', label: 'Niacin', unit: 'mg'},
  {index: 19, key: 'P', label: 'Phosphorus', unit: 'mg'},
  {index: 20, key: 'PROCNT', label: 'Protein', unit: 'g'},
  {index: 21, key: 'RIBF', label: 'Riboflavin', unit: 'mg'},
  {index: 22, key: 'SUGAR', label: 'Total Sugars', unit: 'g'},
  {index: 23, key: 'SUGAR.added', label: 'Added Sugars', unit: 'g'},
  {index: 24, key: 'Sugar.alcohol', label: 'Sugar Alcohols', unit: 'g'},
  {index: 25, key: 'THIA', label: 'Thiamin', unit: 'mg'},
  {index: 26, key: 'TOCPHA', label: 'Vitamin E', unit: 'mg'},
  {index: 27, key: 'VITA_RAE', label: 'Vitamin A', unit: 'µg'},
  {index: 28, key: 'VITB12', label: 'Vitamin B12', unit: 'µg'},
  {index: 29, key: 'VITB6A', label: 'Vitamin B6', unit: 'mg'},
  {index: 30, key: 'VITC', label: 'Vitamin C', unit: 'mg'},
  {index: 31, key: 'VITD', label: 'Vitamin D', unit: 'µg'},
  {index: 32, key: 'VITK1', label: 'Vitamin K', unit: 'µg'},
  {index: 33, key: 'WATER', label: 'Water', unit: 'g'},
  {index: 34, key: 'ZN', label: 'Zinc', unit: 'mg'},
];

// export const displayNutrients = [
//   {index: 0, key: 'calories', label: 'Calories', unit: 'kcal'},
//   {index: 1, key: 'fat', label: 'Total Fat', unit: 'g'},
//   {index: 2, key: 'saturated_fat', label: 'Saturated Fat', unit: 'g'},
//   {
//     index: 3,
//     key: 'polyunsaturated_fat',
//     label: 'Polyunsaturated Fat',
//     unit: 'g',
//   },
//   {
//     index: 4,
//     key: 'monounsaturated_fat',
//     label: 'Monounsaturated Fat',
//     unit: 'g',
//   },
//   {index: 5, key: 'trans_fat', label: 'Trans Fat', unit: 'g'},
//   {index: 6, key: 'cholesterol', label: 'Cholesterol', unit: 'mg'},
//   {index: 7, key: 'sodium', label: 'Sodium', unit: 'mg'},
//   {index: 8, key: 'potassium', label: 'Potassium', unit: 'mg'},
//   {index: 9, key: 'carbohydrate', label: 'Total Carbohydrates', unit: 'g'},
//   {index: 10, key: 'fiber', label: 'Dietary Fiber', unit: 'g'},
//   {index: 11, key: 'sugar', label: 'Total Sugars', unit: 'g'},
//   {index: 12, key: 'added_sugars', label: 'Added Sugars', unit: 'g'},
//   {index: 13, key: 'protein', label: 'Protein', unit: 'g'},
//   {index: 14, key: 'vitamin_d', label: 'Vitamin D', unit: 'µg'},
//   {index: 15, key: 'vitamin_a', label: 'Vitamin A', unit: 'µg'},
//   {index: 16, key: 'vitamin_c', label: 'Vitamin C', unit: 'mg'},
//   {index: 17, key: 'calcium', label: 'Calcium', unit: 'mg'},
//   {index: 18, key: 'iron', label: 'Iron', unit: 'mg'},
// ];

export const formatNutrient = nutrient => {
  const found = displayNutrients.find(n => n.key === nutrient);
  if (found) {
    return {label: found.label, unit: found.unit};
  }
  return {label: nutrient, unit: ''}; // Default if not found
};


--- FILE: src/utilities/realtime/RealTimeAccounts.jsx ---

//* RealTimeAccounts.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount, useProfile} from '../../hooks/useHooks';

const useRealTimeAccounts = enabled => {
  const dispatch = useDispatch();
  const profile = useProfile();
  const db = getFirestore();

  useEffect(() => {
    if (!enabled || !profile?.account) {
      return;
    }

    const accountRef = doc(db, 'accounts', profile.account);

    const unsubscribe = onSnapshot(
      accountRef,
      snapshot => {
        if (snapshot.exists) {
          const accountData = snapshot.data();
          const account = {
            ...accountData,
            lastUpdated:
              accountData?.lastUpdated?.toDate?.().toISOString() ?? null,
            createdOn: accountData?.createdOn?.toDate?.().toISOString() ?? null,
          };
          dispatch({type: 'SET_ACCOUNT', payload: account});
        } else {
          dispatch({type: 'SET_ACCOUNT', payload: null});
        }
      },
      error => {
        dispatch({type: 'ACCOUNT_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, profile?.account, db, enabled]); // ✅ Removed `storedAccount`
};

export default useRealTimeAccounts;


--- FILE: src/utilities/realtime/RealTimeAllowedProfiles.jsx ---

//* RealTimeAllowedProfiles.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {
  getFirestore,
  collection,
  query,
  where,
  onSnapshot,
} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeAllowedProfiles = enabled => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();

  useEffect(() => {
    if (!enabled || !account?.allowedUsers?.length) {
      return;
    }

    const profilesQuery = query(
      collection(db, 'profiles'),
      where('id', 'in', account.allowedUsers),
    );

    const unsubscribe = onSnapshot(
      profilesQuery,
      querySnapshot => {
        if (!querySnapshot.empty) {
          const profiles = querySnapshot.docs
            .map(doc => doc.data())
            .filter(profile => profile?.isActive)
            .sort((a, b) => (a.role === 'owner' ? -1 : 1));

          dispatch({type: 'SET_ALLOWED_PROFILES', payload: profiles});
        } else {
          dispatch({type: 'SET_ALLOWED_PROFILES', payload: []});
        }
      },
      error => {
        dispatch({
          type: 'ALLOWED_PROFILES_FETCH_FAILED',
          payload: error.message,
        });
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.allowedUsers, db, enabled]); // ✅ Removed `persistedProfiles`
};

export default useRealTimeAllowedProfiles;


--- FILE: src/utilities/realtime/RealTimeCupboard.jsx ---

// * RealTimeCupboard.jsx
import {useEffect, useRef} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeCupboard = enabled => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();
  const prevCupboardRef = useRef(null);

  useEffect(() => {
    if (!enabled || !account?.cupboardID) return;

    const cupboardRef = doc(db, 'cupboards', account.cupboardID);

    const unsubscribe = onSnapshot(
      cupboardRef,
      snapshot => {
        if (!snapshot.exists) return;

        const cupboardData = snapshot.data();
        const nextCupboard = {
          ...cupboardData,
          items: Array.isArray(cupboardData.items) ? cupboardData.items : [],
          // compare on raw millis (faster, no Date/String allocs)
          lastUpdated: cupboardData?.lastUpdated?.toMillis?.() ?? null,
        };

        const prevUpdatedAt = prevCupboardRef.current?.lastUpdated;
        const nextUpdatedAt = nextCupboard.lastUpdated;

        if (prevUpdatedAt !== nextUpdatedAt) {
          prevCupboardRef.current = nextCupboard;
          dispatch({type: 'SET_CUPBOARD', payload: nextCupboard});
        }
      },
      error => {
        dispatch({type: 'CUPBOARD_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.cupboardID, db, enabled]);
};

export default useRealTimeCupboard;


--- FILE: src/utilities/realtime/RealTimeFavorites.jsx ---

// * RealTimeFavorites.jsx
import {useEffect, useRef} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeFavorites = enabled => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();
  const prevFavoritesRef = useRef(null);

  useEffect(() => {
    if (!enabled || !account?.favoriteItemsID) return;

    const favoritesRef = doc(db, 'favoriteItems', account.favoriteItemsID);

    const unsubscribe = onSnapshot(
      favoritesRef,
      snapshot => {
        if (!snapshot.exists) return;

        const favoritesData = snapshot.data();
        const nextFavorites = {
          ...favoritesData,
          items: Array.isArray(favoritesData.items) ? favoritesData.items : [],
          // faster, no Date/String allocs
          lastUpdated: favoritesData?.lastUpdated?.toMillis?.() ?? null,
        };

        const prevUpdatedAt = prevFavoritesRef.current?.lastUpdated;
        const nextUpdatedAt = nextFavorites.lastUpdated;

        if (prevUpdatedAt !== nextUpdatedAt) {
          prevFavoritesRef.current = nextFavorites;
          dispatch({type: 'SET_FAVORITES', payload: nextFavorites});
        }
      },
      error => {
        dispatch({type: 'FAVORITES_SET_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.favoriteItemsID, db, enabled]);
};

export default useRealTimeFavorites;


--- FILE: src/utilities/realtime/RealTimeProfiles.jsx ---

import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useUser} from '../../hooks/useHooks';

const useRealTimeProfiles = enabled => {
  const dispatch = useDispatch();
  const user = useUser();
  const db = getFirestore();

  useEffect(() => {
    if (!enabled || !user?.uid) {
      return;
    }

    const profileRef = doc(db, 'profiles', user.uid);

    const unsubscribe = onSnapshot(
      profileRef,
      snapshot => {
        if (snapshot.exists) {
          const profileData = snapshot.data();
          const profilePayload = {
            ...profileData,
            lastUpdated:
              profileData?.lastUpdated?.toDate?.().toISOString() ?? null,
            createdOn: profileData?.createdOn?.toDate?.().toISOString() ?? null,
          };
          dispatch({type: 'SET_PROFILE', payload: profilePayload});
        } else {
          dispatch({type: 'SET_PROFILE', payload: null});
        }
      },
      error => {
        dispatch({type: 'PROFILE_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, user?.uid, db, enabled]); // ✅ Removed `storedProfile`
};

export default useRealTimeProfiles;


--- FILE: src/utilities/realtime/RealTimeShoppingCart.jsx ---

// * RealTimeShoppingCart.jsx
import {useEffect, useRef} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeShoppingCart = enabled => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();
  const prevCartRef = useRef(null);

  useEffect(() => {
    if (!enabled || !account?.shoppingCartID) return;

    const cartRef = doc(db, 'shoppingCarts', account.shoppingCartID);

    const unsubscribe = onSnapshot(
      cartRef,
      snapshot => {
        if (!snapshot.exists) return;

        const shopCartData = snapshot.data();
        const nextCart = {
          ...shopCartData,
          items: Array.isArray(shopCartData.items) ? shopCartData.items : [],
          // compare using raw millis (fewer allocations)
          lastUpdated: shopCartData?.lastUpdated?.toMillis?.() ?? null,
        };

        const prevUpdatedAt = prevCartRef.current?.lastUpdated;
        const nextUpdatedAt = nextCart.lastUpdated;

        if (prevUpdatedAt !== nextUpdatedAt) {
          prevCartRef.current = nextCart;
          dispatch({type: 'SET_SHOP_CART', payload: nextCart});
        }
      },
      error => {
        dispatch({type: 'SHOP_CART_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.shoppingCartID, db, enabled]);
};

export default useRealTimeShoppingCart;


--- FILE: src/utilities/realtime/RealTimeUsers.jsx ---

//* RealTimeUsers.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getAuth, onAuthStateChanged} from '@react-native-firebase/auth';

const auth = getAuth();

const useRealTimeUsers = enabled => {
  const dispatch = useDispatch();

  useEffect(() => {
    if (!enabled) return;

    const unsubscribe = onAuthStateChanged(auth, currentUser => {
      if (currentUser) {
        dispatch({type: 'SET_USER', payload: currentUser});
      } else {
        dispatch({type: 'UNSET_USER'});
      }
    });

    return () => {
      unsubscribe();
    };
  }, [dispatch, enabled]);
};

export default useRealTimeUsers;


--- FILE: src/utilities/realtime/RealtimeRecipeBox.jsx ---

// * RealTimeRecipeBox.jsx
import {useEffect, useRef} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeRecipeBox = enabled => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();
  const prevRecipeBoxRef = useRef(null);

  useEffect(() => {
    if (!enabled || !account?.recipeBoxID) return;

    const recipeBoxRef = doc(db, 'recipeBoxes', account.recipeBoxID);

    const unsubscribe = onSnapshot(
      recipeBoxRef,
      snapshot => {
        if (!snapshot.exists) return;

        const recipeBoxData = snapshot.data();
        const nextRecipeBoxes = {
          ...recipeBoxData,
          items: Array.isArray(recipeBoxData.items) ? recipeBoxData.items : [],
          // compare using raw millis (fewer allocations)
          lastUpdated: recipeBoxData?.lastUpdated?.toMillis?.() ?? null,
          // keep createdOn normalized for any UI use
          createdOn: recipeBoxData?.createdOn?.toDate?.().toISOString() ?? null,
        };

        const prevUpdatedAt = prevRecipeBoxRef.current?.lastUpdated;
        const nextUpdatedAt = nextRecipeBoxes.lastUpdated;

        if (prevUpdatedAt !== nextUpdatedAt) {
          prevRecipeBoxRef.current = nextRecipeBoxes;
          dispatch({type: 'SET_RECIPE_BOX', payload: nextRecipeBoxes});
        }
      },
      error => {
        dispatch({type: 'RECIPE_BOX_SET_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.recipeBoxID, db, enabled]);
};

export default useRealTimeRecipeBox;


--- FILE: src/utilities/realtime/index.js ---

//* index.js (RealTime Listeners)
export {default as RTAccounts} from './RealTimeAccounts';
export {default as RTProfiles} from './RealTimeProfiles';
export {default as RTShopping} from './RealTimeShoppingCart';
export {default as RTCupboards} from './RealTimeCupboard';
export {default as RTUsers} from './RealTimeUsers';
export {default as RTAllowedProfiles} from './RealTimeAllowedProfiles';
export {default as RTFavorites} from './RealTimeFavorites';
export {default as RTRecipeBox} from './RealtimeRecipeBox';


--- FILE: src/utilities/shortenUnit.js ---

//* shortenUnit.js
export const shortenUnit = unit => {
  if (!unit || typeof unit !== 'string') return '';

  const normalized = unit.toLowerCase().trim();
  if (!normalized) return '';

  const unitMap = {
    // explicitly omitted units
    each: '',
    serving: '',
    servings: '',

    // weight
    pound: 'lb',
    pounds: 'lbs',
    ounce: 'oz',
    ounces: 'oz',
    gram: 'g',
    grams: 'g',
    kilogram: 'kg',
    kilograms: 'kg',
    mg: 'mg',
    milligram: 'mg',

    // volume
    teaspoon: 'tsp',
    teaspoons: 'tsp',
    tablespoon: 'tbsp',
    tablespoons: 'tbsp',
    cup: 'cup',
    cups: 'cups',
    pint: 'pt',
    pints: 'pt',
    quart: 'qt',
    quarts: 'qt',
    gallon: 'gal',
    gallons: 'gal',
    liter: 'L',
    liters: 'L',
    milliliter: 'ml',
    milliliters: 'ml',
    'fluid ounce': 'fl oz',
    'fluid ounces': 'fl oz',

    // counts & non-quantifiables
    clove: 'clv',
    cloves: 'clv',
    piece: 'pc',
    pieces: 'pc',
    slice: 'slc',
    slices: 'slc',
    stick: 'stk',
    sticks: 'stk',

    // informal units
    pinch: 'pinch',
    pinches: 'pinch',
    dash: 'dash',
    dashes: 'dash',
    bunch: 'bunch',
    bunches: 'bunch',
    sprig: 'sprig',
    sprigs: 'sprig',
    handful: 'handful',
    handfuls: 'handful',

    // containers
    can: 'can',
    cans: 'can',
    jar: 'jar',
    jars: 'jar',
    bag: 'bag',
    bags: 'bag',
    bottle: 'btl',
    bottles: 'btl',
    packet: 'pkt',
    packets: 'pkt',
    container: 'ctnr',
    containers: 'ctnr',

    // extras
    drop: 'drop',
    drops: 'drop',
    shot: 'shot',
    shots: 'shot',
    scoop: 'scoop',
    scoops: 'scoop',
  };

  // fallback: return empty string for omitted, or normalized value if unknown
  if (unitMap.hasOwnProperty(normalized)) {
    return unitMap[normalized]; // '', 'tsp', etc.
  }

  return normalized; // fallback for unknown units
};


--- FILE: src/utilities/transformNutritionFacts.js ---

// transformNutritionFacts.js

import {formatNutrient} from './nutrients';

const normalizeUnit = rawUnit => {
  const unit = rawUnit?.toLowerCase().trim();
  if (!unit) return null;

  const map = {
    // volume
    'fl oz': 'fluidounce',
    floz: 'fluidounce',
    'fluid oz': 'fluidounce',
    ml: 'milliliter',
    l: 'liter',
    cup: 'cup',
    pint: 'pint',
    quart: 'quart',
    gallon: 'gallon',
    tbsp: 'tablespoon',
    tablespoon: 'tablespoon',
    tsp: 'teaspoon',
    teaspoon: 'teaspoon',

    // weight
    oz: 'ounce',
    g: 'gram',
    gram: 'gram',
    kg: 'kilogram',
    kilogram: 'kilogram',
    lb: 'pound',
    lbs: 'pound',
    pound: 'pound',

    // count/package
    count: 'each',
    ct: 'each',
    pk: 'package',
    package: 'package',
    bag: 'bag',
    bottle: 'bottle',
    box: 'box',
    jar: 'jar',
    can: 'can',
    bar: 'bar',
  };
  return map[unit] || unit;
};

export const transformNutritionFacts = (food = {}) => {
  if (!food || typeof food !== 'object') return null;

  const {
    foodId,
    label,
    knownAs,
    brand,
    image,
    foodContentsLabel,
    nutrients = {},
    servingSizes = [],
  } = food;

  const extractPackageSizeFromLabel = label => {
    if (!label || typeof label !== 'string') return null;

    const regex = /(\d+(?:\.\d+)?)\s?(fl\s?oz|oz|g|ml|l|count|ct|pk)/i;
    const match = label.match(regex);
    if (!match) return null;

    const quantity = parseFloat(match[1]);
    const rawUnit = match[2].toLowerCase();
    const unit = normalizeUnit(rawUnit);

    let approxMl = null;
    let approxGrams = null;

    if (rawUnit === 'fl oz') approxMl = quantity * 29.5735;
    else if (rawUnit === 'oz') approxGrams = quantity * 28.3495;
    else if (rawUnit === 'ml') approxMl = quantity;
    else if (rawUnit === 'l') approxMl = quantity * 1000;
    else if (rawUnit === 'g') approxGrams = quantity;

    return {
      quantity,
      unit,
      approxMl,
      approxGrams,
      raw: match[0],
    };
  };

  const primaryServing = servingSizes?.[0] || null;
  const servingQty = primaryServing?.quantity || 1;
  const servingLabel = primaryServing?.label?.toLowerCase() || '';
  const servingSizeGrams =
    servingLabel.includes('gram') || servingLabel.includes('g')
      ? servingQty
      : null;

  const packageSizeData = extractPackageSizeFromLabel(label);
  let servingsPerContainer = 1;

  if (packageSizeData?.approxMl && servingLabel.includes('fl oz')) {
    const servingMl = servingQty * 29.5735;
    servingsPerContainer = Math.round(packageSizeData.approxMl / servingMl);
  } else if (packageSizeData?.approxGrams && servingSizeGrams) {
    servingsPerContainer = Math.round(
      packageSizeData.approxGrams / servingSizeGrams,
    );
  }

  servingsPerContainer = Math.max(servingsPerContainer, 1);

  const assumePer100g =
    servingSizeGrams &&
    servingSizeGrams < 100 &&
    Object.values(nutrients).some(val => val > 30);

  const scaleFactor = assumePer100g ? servingSizeGrams / 100 : 1;

  const perServing = {};
  const perContainer = {};

  Object.entries(nutrients).forEach(([key, val]) => {
    if (!val || val === 0) return;

    const scaled = Math.round(val * scaleFactor);
    if (scaled === 0) return;

    const total = Math.round(scaled * servingsPerContainer);
    const {label: friendlyLabel, unit} = formatNutrient(key);

    perServing[key] = {
      key,
      label: friendlyLabel,
      unit,
      value: scaled,
    };

    perContainer[key] = {
      key,
      label: friendlyLabel,
      unit,
      value: total,
    };
  });

  return {
    foodId,
    itemName: label,
    knownAs,
    brandName: brand,
    image,
    foodContentsLabel,
    servingSizes,
    servingsPerContainer,
    servingSizeLabel: primaryServing?.label || '',
    packageSize: packageSizeData || null,
    measurement: packageSizeData?.unit || null, // ✅ matches displayMeasurements key
    nutrients: {
      perServing,
      perContainer,
    },
  };
};


--- FILE: store.js ---

// store.js
import {createStore, applyMiddleware} from 'redux';
import {persistStore, persistReducer} from 'redux-persist';
import AsyncStorage from '@react-native-async-storage/async-storage';
import rootReducer from './src/redux/reducers/_root.reducer';
import rootSaga from './src/redux/sagas/_root.saga';

// Use CJS require to avoid ESM/CJS interop issues in redux-saga@1.3.x
const SagaPkg = require('redux-saga');
const createSagaMiddleware =
  (typeof SagaPkg.default === 'function' && SagaPkg.default) ||
  (typeof SagaPkg.createSagaMiddleware === 'function' &&
    SagaPkg.createSagaMiddleware) ||
  SagaPkg;

const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['user', 'profile', 'account', 'shopping', 'cupboard'],
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

const sagaMiddleware = createSagaMiddleware();
const store = createStore(persistedReducer, applyMiddleware(sagaMiddleware));
const persistor = persistStore(store);

sagaMiddleware.run(rootSaga);

export {store, persistor};


--- FILE: syncVersion.js ---

const fs = require('fs');
const path = require('path');

// Load version.json
const versionPath = path.resolve(__dirname, 'version.json');
const versionData = JSON.parse(fs.readFileSync(versionPath, 'utf8'));

// Paths to native files
const infoPlistPath = path.resolve(
  __dirname,
  'ios',
  'KitchenQueue',
  'Info.plist',
);
const buildGradlePath = path.resolve(
  __dirname,
  'android',
  'app',
  'build.gradle',
);

// --- Update Info.plist ---
let infoPlist = fs.readFileSync(infoPlistPath, 'utf8');

// Replace CFBundleVersion
infoPlist = infoPlist.replace(
  /<key>CFBundleVersion<\/key>\s*<string>.*?<\/string>/,
  `<key>CFBundleVersion</key>\n\t<string>${versionData.appleBuildVersion}</string>`,
);

// Replace CFBundleShortVersionString
infoPlist = infoPlist.replace(
  /<key>CFBundleShortVersionString<\/key>\s*<string>.*?<\/string>/,
  `<key>CFBundleShortVersionString</key>\n\t<string>${versionData.appleAppVersion}</string>`,
);

// Write back Info.plist
fs.writeFileSync(infoPlistPath, infoPlist, 'utf8');

// --- Update build.gradle ---
let buildGradle = fs.readFileSync(buildGradlePath, 'utf8');

// Replace versionCode
buildGradle = buildGradle.replace(
  /versionCode\s+\d+/,
  `versionCode ${versionData.googleBuildVersion}`,
);

// Replace versionName
buildGradle = buildGradle.replace(
  /versionName\s+["'][^"']*["']/,
  `versionName "${versionData.androidAppVersion}"`,
);

// Write back build.gradle
fs.writeFileSync(buildGradlePath, buildGradle, 'utf8');


--- FILE: version.json ---

{
  "__comment1": "⚠️ WARNING: DO NOT EDIT MANUALLY! Do not edit this file directly.⚠️",
  "__comment2": "Only manually edit if emergency recovery is needed.",
  "__comment3": "This file is auto-generated by bumpVersion.js.",
  "__comment4": "Run yarn bump scripts. Ref package.json for details.",
  "appleAppVersion": "0.9.1",
  "androidAppVersion": "0.9.1",
  "appleBuildVersion": 2,
  "googleBuildVersion": 1,
  "tosVersion": "1.0.0",
  "ppVersion": "1.0.0"
}


--- FILE: z-sandbox/fatsecretSamples.json ---

[
  {
    "food": {
      "food_id": "304072",
      "food_name": "Original Tomato Sauce",
      "brand_name": "Hunt's",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/hunts/original-tomato-sauce",
      "servings": {
        "serving": [
          {
            "serving_id": "339065",
            "serving_description": "1/4 cup",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/hunts/original-tomato-sauce",
            "metric_serving_amount": "62.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "20",
            "carbohydrate": "4.00",
            "protein": "1.00",
            "fat": "0",
            "saturated_fat": "0",
            "polyunsaturated_fat": "0",
            "monounsaturated_fat": "0",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "380",
            "potassium": "180",
            "fiber": "2.0",
            "sugar": "2.00"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "2695621",
      "food_name": "Tomato Soup",
      "brand_name": "Campbell's",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/campbells/tomato-soup/1-can",
      "servings": {
        "serving": [
          {
            "serving_id": "2628971",
            "serving_description": "1 can",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/campbells/tomato-soup/1-can",
            "metric_serving_amount": "305.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "225",
            "carbohydrate": "50.00",
            "protein": "5.00",
            "fat": "0",
            "sodium": "1440",
            "potassium": "1450",
            "fiber": "5.0",
            "sugar": "30.00",
            "added_sugars": "20.00",
            "vitamin_c": "23.0",
            "iron": "1.25"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "2934050",
      "food_name": "Original No-Stick Cooking Spray",
      "brand_name": "PAM",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/pam/original-no-stick-cooking-spray",
      "servings": {
        "serving": [
          {
            "serving_id": "2857693",
            "serving_description": "1/2 second spray",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/pam/original-no-stick-cooking-spray",
            "metric_serving_amount": "0.250",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "0",
            "carbohydrate": "0",
            "protein": "0",
            "fat": "0",
            "saturated_fat": "0",
            "trans_fat": "0",
            "cholesterol": "0"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "71416",
      "food_name": "Extra Virgin Olive Oil",
      "brand_name": "Pompeian",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/pompeian/extra-virgin-olive-oil",
      "servings": {
        "serving": [
          {
            "serving_id": "116951",
            "serving_description": "1 tbsp",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/pompeian/extra-virgin-olive-oil",
            "metric_serving_amount": "15.000",
            "metric_serving_unit": "ml",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "120",
            "carbohydrate": "0",
            "protein": "0",
            "fat": "14.00",
            "saturated_fat": "2.000",
            "polyunsaturated_fat": "1.500",
            "monounsaturated_fat": "10.000",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "0",
            "fiber": "0",
            "sugar": "0",
            "added_sugars": "0"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "68738555",
      "food_name": "Hot Coffee - Small",
      "brand_name": "Dunkin' Donuts",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/dunkin-donuts/hot-coffee-small",
      "servings": {
        "serving": [
          {
            "serving_id": "56248357",
            "serving_description": "1 serving",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/dunkin-donuts/hot-coffee-small",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "5",
            "carbohydrate": "0",
            "protein": "0",
            "fat": "0",
            "saturated_fat": "0",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "5",
            "potassium": "155",
            "fiber": "0",
            "sugar": "0",
            "added_sugars": "0",
            "vitamin_d": "0",
            "calcium": "6",
            "iron": "0"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "251177",
      "food_name": "100% Fat Free Chicken Broth (33% Less Sodium)",
      "brand_name": "Swanson",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/swanson/100%25-fat-free-chicken-broth-(33%25-less-sodium)",
      "servings": {
        "serving": [
          {
            "serving_id": "289234",
            "serving_description": "1 cup",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/swanson/100%25-fat-free-chicken-broth-(33%25-less-sodium)",
            "metric_serving_amount": "240.000",
            "metric_serving_unit": "ml",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "15",
            "carbohydrate": "1.00",
            "protein": "2.00",
            "fat": "0",
            "saturated_fat": "0",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "570",
            "potassium": "100",
            "fiber": "0",
            "sugar": "0",
            "added_sugars": "0",
            "vitamin_d": "0",
            "calcium": "10",
            "iron": "0.10"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "31400",
      "food_name": "Elbow Macaroni",
      "brand_name": "Creamette",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/creamette/elbow-macaroni",
      "servings": {
        "serving": [
          {
            "serving_id": "97380",
            "serving_description": "1/2 cup",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/creamette/elbow-macaroni",
            "metric_serving_amount": "56.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "200",
            "carbohydrate": "42.00",
            "protein": "7.00",
            "fat": "1.00",
            "saturated_fat": "0",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "0",
            "potassium": "105",
            "fiber": "2.0",
            "sugar": "1.00",
            "added_sugars": "0"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "52744",
      "food_name": "Broccoli Au Gratin Rice Mix",
      "brand_name": "Rice-A-Roni",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/rice-a-roni/broccoli-au-gratin-rice-mix",
      "servings": {
        "serving": [
          {
            "serving_id": "86271",
            "serving_description": "1 cup prepared",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/rice-a-roni/broccoli-au-gratin-rice-mix",
            "metric_serving_amount": "2.000",
            "metric_serving_unit": "oz",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "290",
            "carbohydrate": "37.00",
            "protein": "6.00",
            "fat": "13.00",
            "saturated_fat": "4.000",
            "trans_fat": "1.500",
            "cholesterol": "5",
            "sodium": "790",
            "potassium": "190",
            "fiber": "1.0",
            "sugar": "3.00",
            "calcium": "50",
            "iron": "1.80"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "83667",
      "food_name": "Cut Green Beans",
      "brand_name": "Butter Kernel",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/butter-kernel/cut-green-beans",
      "servings": {
        "serving": [
          {
            "serving_id": "119232",
            "serving_description": "1/2 cup",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/butter-kernel/cut-green-beans",
            "metric_serving_amount": "120.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "20",
            "carbohydrate": "5.00",
            "protein": "0",
            "fat": "0",
            "saturated_fat": "0",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "390",
            "fiber": "2.0",
            "sugar": "1.00"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "17244970",
      "food_name": "Large Black Olives",
      "brand_name": "Pearls",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/pearls/large-black-olives",
      "servings": {
        "serving": [
          {
            "serving_id": "16266842",
            "serving_description": "4 olives",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/pearls/large-black-olives",
            "metric_serving_amount": "15.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "15",
            "carbohydrate": "1.00",
            "protein": "0",
            "fat": "1.50",
            "cholesterol": "0",
            "sodium": "120",
            "fiber": "0",
            "sugar": "0"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "49809",
      "food_name": "Diced Petite Tomatoes",
      "brand_name": "Hunt's",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/hunts/diced-petite-tomatoes",
      "servings": {
        "serving": [
          {
            "serving_id": "97364",
            "serving_description": "1/2 cup",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/hunts/diced-petite-tomatoes",
            "metric_serving_amount": "121.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "30",
            "carbohydrate": "6.00",
            "protein": "1.00",
            "fat": "0",
            "saturated_fat": "0",
            "cholesterol": "0",
            "sodium": "220",
            "potassium": "260",
            "fiber": "2.0",
            "sugar": "3.00",
            "added_sugars": "0"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "2339368",
      "food_name": "Complete Buttermilk Pancake & Waffle Mix",
      "brand_name": "Hungry Jack",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/hungry-jack/complete-buttermilk-pancake-waffle-mix",
      "servings": {
        "serving": [
          {
            "serving_id": "2287835",
            "serving_description": "1/4 cup of dry mix",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/hungry-jack/complete-buttermilk-pancake-waffle-mix",
            "metric_serving_amount": "38.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "130",
            "carbohydrate": "28.00",
            "protein": "3.00",
            "fat": "1.00",
            "saturated_fat": "0",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "520",
            "potassium": "46",
            "fiber": "1.0",
            "sugar": "6.00",
            "added_sugars": "5.00",
            "vitamin_d": "0",
            "calcium": "77",
            "iron": "0"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "144373",
      "food_name": "Fettucine Noodles",
      "brand_name": "Great Value",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/great-value/fettucine-noodles",
      "servings": {
        "serving": [
          {
            "serving_id": "188613",
            "serving_description": "2 oz",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/great-value/fettucine-noodles",
            "metric_serving_amount": "56.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "200",
            "carbohydrate": "42.00",
            "protein": "7.00",
            "fat": "1.00",
            "cholesterol": "0",
            "sodium": "0",
            "potassium": "105",
            "fiber": "2.0",
            "sugar": "2.00"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "2767129",
      "food_name": "Instant White Rice",
      "brand_name": "Minute",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/minute/instant-white-rice",
      "servings": {
        "serving": [
          {
            "serving_id": "2697079",
            "serving_description": "1/2 cup dry (1 cup cooked)",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/minute/instant-white-rice",
            "metric_serving_amount": "55.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "170",
            "carbohydrate": "38.00",
            "protein": "4.00",
            "fat": "0",
            "saturated_fat": "0",
            "polyunsaturated_fat": "0",
            "monounsaturated_fat": "0",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "5",
            "potassium": "0",
            "fiber": "0",
            "sugar": "0",
            "added_sugars": "0",
            "vitamin_d": "0",
            "vitamin_a": "0",
            "vitamin_c": "0",
            "calcium": "0",
            "iron": "1.00"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "1748429",
      "food_name": "Original Ranch Seasoning & Salad Dressing Mix (1.8g)",
      "brand_name": "Hidden Valley",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/hidden-valley/original-ranch-seasoning-and-salad-dressing-mix",
      "servings": {
        "serving": [
          {
            "serving_id": "1720868",
            "serving_description": "1/2 tsp",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/hidden-valley/original-ranch-seasoning-and-salad-dressing-mix",
            "metric_serving_amount": "1.800",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "5",
            "carbohydrate": "1.00",
            "protein": "0",
            "fat": "0",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "135",
            "fiber": "0",
            "sugar": "0"
          }
        ]
      }
    }
  },
  {
    "food": {
      "food_id": "26699688",
      "food_name": "Soft Tortilla Bowl",
      "brand_name": "Old El Paso",
      "food_type": "Brand",
      "food_url": "https://foods.fatsecret.com/calories-nutrition/old-el-paso/soft-tortilla-bowl",
      "servings": {
        "serving": [
          {
            "serving_id": "24608096",
            "serving_description": "2 tortillas",
            "serving_url": "https://foods.fatsecret.com/calories-nutrition/old-el-paso/soft-tortilla-bowl",
            "metric_serving_amount": "47.000",
            "metric_serving_unit": "g",
            "number_of_units": "1.000",
            "measurement_description": "serving",
            "calories": "160",
            "carbohydrate": "25.00",
            "protein": "3.00",
            "fat": "4.50",
            "saturated_fat": "2.500",
            "trans_fat": "0",
            "cholesterol": "0",
            "sodium": "320",
            "potassium": "0",
            "fiber": "0",
            "sugar": "0",
            "calcium": "50",
            "iron": "1.60"
          }
        ]
      }
    }
  }
]


--- FILE: z-sandbox/myRecipe.js ---

export const myRecipe = [
  {
    id: '4f46b0b1-3847-41d6-9ca6-12858aae341d',
    createdOn: {
      seconds: 1751389200,
      nanoseconds: 902000000,
    },
    isArchived: false,
    authorLastName: 'Wells',
    ingredientList: [
      'cream cheese',
      'penne pasta',
      'parmesan cheese',
      'pepper',
      'garlic',
      'milk',
      'chicken breasts',
      'butter',
      'parsley',
    ],
    credit: 'DarkCav19D',
    seasonal: null,
    authorOnlineName: 'DarkCav19D',
    publicAuthor: true,
    image: 'wells-creamy-chicken-alfredo.jpg',
    pictureApproved: true,
    updatedOn: {
      seconds: 1751389200,
      nanoseconds: 540000000,
    },
    source: null,
    sourceMaterial: 'personal',
    servings: 4,
    ingredients: [
      {
        amount: 8,
        name: 'cream cheese',
        note: 'Philadelphia brand is best',
        unit: 'ounce',
      },
      {
        amount: 16,
        name: 'penne pasta',
        note: '',
        unit: 'ounce',
      },
      {
        amount: 5,
        name: 'parmesan cheese',
        note: 'Use a higher quality and grated for easier melting and taste (BelGioioso is great)',
        unit: 'ounce',
      },
      {
        amount: 1,
        name: 'pepper',
        note: '',
        unit: 'tablespoon',
      },
      {
        amount: 2,
        name: 'garlic',
        note: 'Use garlic paste for a smoother sauce',
        unit: 'tablespoon',
      },
      {
        amount: 8,
        name: 'milk',
        note: '2% or whole milk works best',
        unit: 'fluidounce',
      },
      {
        amount: 4,
        name: 'chicken breasts',
        note: '',
        unit: 'each',
      },
      {
        amount: 4,
        name: 'butter',
        note: '',
        unit: 'ounce',
      },
      {
        amount: 1,
        name: 'parsley',
        note: 'For garnish, optional',
        unit: 'tablespoon',
      },
    ],
    displayAuthorName: false,
    sharedStatus: null,
    cuisines: ['italian', 'american'],
    recipeShared: false,
    instructions: [
      {
        index: 0,
        name: 'Cooking the Pasta',
        steps: [
          {
            step: 0,
            action: 'Bring a large pot of water to a boil',
          },
          {
            step: 1,
            action: 'Optional: Add salt or oil to the water',
          },
          {
            step: 2,
            action: 'Add pasta and cook until al dente',
          },
          {
            step: 3,
            action: 'Drain the pasta in a colander and set aside',
          },
          {
            step: 4,
            action:
              'Optional: Drizzle a little olive oil on the pasta to prevent sticking',
          },
        ],
      },
      {
        index: 1,
        name: 'Making the Sauce',
        steps: [
          {
            step: 0,
            action: 'In your sauce pan, over medium heat, melt the butter',
          },
          {
            step: 1,
            action:
              'Add garlic paste, pepper, and cream cheese. Mix until cream cheese is smooth',
          },
          {
            step: 2,
            action: 'Add milk and continue to stir until it gently simmers',
          },
          {
            step: 3,
            action:
              'Add parmesan cheese and stir until melted and smooth. (Add half at a time for better melting.)',
          },
          {
            step: 4,
            action:
              'Reduce heat to low. Taste and adjust with more pepper, salt, or garlic. Stir often to avoid burning. (Too thick? Add a splash of milk or water.)',
          },
          {
            step: 5,
            action: 'Once done, remove from heat and let rest for 2–3 minutes',
          },
        ],
      },
      {
        index: 2,
        name: 'Cooking the Chicken',
        steps: [
          {
            step: 0,
            action:
              '(Grill) Bring your grill to about 400°F -or- (Pan Fry) Heat 1–2 tablespoons of oil in a large skillet over medium heat',
          },
          {
            step: 1,
            action: 'Place the chicken breasts on the preheated grill or pan',
          },
          {
            step: 2,
            action:
              'Cook for 5–7 minutes per side, or until the internal temperature hits 165°F',
          },
          {
            step: 3,
            action:
              'Let the chicken rest for a few minutes to allow the juices to redistribute',
          },
          {
            step: 4,
            action: 'Slice the chicken into strips or bite-sized pieces',
          },
        ],
      },
      {
        index: 4,
        name: 'Bring it all together',
        steps: [
          {
            step: 0,
            action: 'Place the cooked pasta in a bowl or plate',
          },
          {
            step: 1,
            action: 'Add the chicken on top of the pasta',
          },
          {
            step: 2,
            action: 'Pour about 1 cup of sauce over the pasta and chicken',
          },
          {
            step: 3,
            action: 'Sprinkle with parsley for garnish, if desired',
          },
        ],
      },
    ],
    dishTypes: ['dinner', 'supper'],
    authorID: 'bLZNlr9Zu2ZBPtG8jkdaoAEMCLy2',
    adminEdit: true,
    authorFirstName: 'AJ',
    occasions: null,
    healthScore: null,
    keywords: [
      'creamy chicken alfredo w/ penne pasta',
      'creamy',
      'chicken',
      'alfredo',
      'penne',
      'pasta',
    ],
    sourceURL: null,
    ratingScore: 4.5,
    aboutRecipe:
      "I came across a version of this recipe years ago and have been tweaking it ever since to match my personal taste. It’s now one of those dishes my family asks for regularly — simple, creamy, and packed with flavor. It's become a go-to comfort meal in our home.",
    title: 'Creamy Chicken Alfredo w/ Penne Pasta',
    accountID: null,
    diets: null,
    prepTime: 10,
    cookTime: 30,
    readyIn: 30,
    imageUri:
      'https://firebasestorage.googleapis.com/v0/b/kitchen-queue-fe2fe.firebasestorage.app/o/recipes%2Fwells-creamy-chicken-alfredo.jpg?alt=media',
  },
];

let dataNeeded = [
  {
    // user sets
    // title: null, //string - Name of the recipe
    // source: null, // string - Where the recipe came from // null if personal
    // sourceMaterial: null, // string - dropdown list for source types
    // sourceURL: null, //string - used if sourceMaterial is online
    // displayAuthorName: false, // boolean - If the author wants their name displayed
    // publicAuthor: false, // boolean - If the author wants their name displayed publicly or anonymously
    // recipeShared: false, // boolean - If the recipe is shared with the community, can only be set if recipeApproved
    // cuisines: null, // array of strings - ['italian', 'mexican', 'american'], etc.
    // dishTypes: null, // array of strings - ['breakfast', 'lunch', 'dinner'], etc.
    summary: null, // string - Short description of the recipe - 'Chicken, Penne Noodles, with a Creamy Alfredo sauce'
    aboutRecipe: null, // string - Author's information about of the recipe
    notes: null, // string - Author's notes/hints for the recipe
    // prep: null, // number - Prep time in minutes
    // cooking: null, // number - Cooking time in minutes
    // readyIn: null, // number - Total time in minutes
    // servings: null, // number - Number of servings
    // diets: null, // array of strings - 'paleo', 'keto', 'low-carb', etc.
    // seasonal: null, // array of strings - 'summer', 'fall', 'winter', 'spring'
    // occasions: null, // array of strings - 'birthday', 'holiday', 'party', etc.

    tools: null, // array of strings
    ingredientList: null, // string - pulled from ingredients name's, Used for searching recipes, pulled apart from the ingredients
    ingredients: null, // array of objects
    instructions: null, // array of objects
    image: null, // string - user will attach an image and is then used to upload to firebase plus for the importer for the imageUri

    // admin sets
    sharedStatus: null, // string - 'request', 'pending', 'admin review', 'needs update', 'reject', 'processing', 'approved', 'complete'
    pictureApproved: true, // boolean - If the picture is approved by the admin
    isArchived: false, // boolean - If the recipe is archived, can not be used anymore

    // background sets
    adminEdit: true, // boolean - This will always be true unless an archived recipe
    authorID: null, // string - used to link to profileID, to the author, for editing
    authorFirstName: null, // string
    authorLastName: null, // string
    authorOnlineName: null, // string
    credit: null, // string
    accountID: null, // string
    healthScore: null,
    id: null, // string - unique ID for the recipe
    createdOn: null, // number - timestamp from firebase
    updatedOn: null, // number - timestamp from firebase

    ratingScore: null,
    keywords: null, // array of strings - Used for searching recipes, pulled apart from the title
  },
];

/*

Now...  When the user begins creating a recipe for the first time, we are going to have a modal popup, it is going to be based on a new field inside of useProfile, that will be called recipeFTU, and it will be set the false on when the profile is first created.  This will tell us, no, the user hasn't read the disclaimer yet about creating recipes.  We will need a message and I might need help with this. I'm just going to give you the basics and we'll go from there.  Overall, the user must adhere to these guidelines and are not subject for negotiations or compromise. The information requested is needed for proper reference and referral, in case the recipe is ever questioned about it originality.  1. Recipe requires an appropriate name. (this is just an example for you chatGPT, we will not use this as an actual example to tell the user it is a bad one.) It can not be called Ex: "Dog Shit on a Bun".   2: Source Material is required. All Sources that are under the "Private" options, the Source Name will be private / not displayed on the recipe it is "Shared" with the community, and the user selects to show it. Online and Published selection, will be shown and the user will not be able to block it.  3: Source Name is required, except if it is a personal recipe (because it will be auto filled in). This will also remain private when shared with the community unless the user selects for it to not be shown, however, their online name (might) be displayed instead.   4: Source URL is required when it is from an online source. This is needed in case we need to check and make sure the recipe you entered, wasn't taken illegally and it is from an open source / reference.


🆕 recipeShared + sharedStatus
This design is excellent. Here's how I'd lay out sharedStatus:

/22,685 / 22700 / 23334 

Value	          Meaning
request	        User clicked "Request Share"
pending	        In algorithm queue
admin           Review	Human needs to review
needsUpdate	    Feedback sent to user
reject	        Recipe declined
processing	    Being moved to community
approved	      Accepted but not yet public
complete	      Live in community box
*/

/*

Flow
User taps "Add Ingredients" → opens bottom sheet.
Sheet displays each row as:
If visible: true → show fields (amount, unit, name)
If visible: false → hide or grey out the fields
When user hits the ➕ on a row:
Current row’s visible is set to true
A new row is added with { amount: '', unit: '', name: '', visible: false }

const [ingredients, setIngredients] = useState([
  { amount: '', unit: '', name: '', visible: false },
]);

const handleAddIngredient = index => {
  setIngredients(prev => {
    const updated = [...prev];
    updated[index].visible = true;
    updated.push({ amount: '', unit: '', name: '', visible: false });
    return updated;
  });
};

const cleanedIngredients = ingredients
  .filter(i => i.visible || i.amount || i.unit || i.name)
  .map(i => ({
    amount: i.amount.trim(),
    unit: i.unit.trim(),
    name: i.name.trim(),
  }));



Flow
User taps "Add New Instruction" → opens bottom sheet
Inside modal:
User enters name (e.g., “Making the Sauce”)
First step is hidden until they press ➕
On ➕ press:
Reveals current step
Adds new step { step: N+1, action: '', visible: false }


  const [instructions, setInstructions] = useState([
  {
    index: 0,
    name: '',
    steps: [{ step: 0, action: '', visible: false }],
  },
]);

const handleAddStep = (instructionIndex, stepIndex) => {
  setInstructions(prev => {
    const updated = [...prev];
    const steps = updated[instructionIndex].steps;

    steps[stepIndex].visible = true;
    steps.push({ step: steps.length, action: '', visible: false });

    return updated;
  });
};


const cleanedInstructions = instructions
  .map((instr, i) => ({
    index: i,
    name: instr.name.trim(),
    steps: instr.steps
      .filter(s => s.visible || s.action.trim() !== '')
      .map((s, j) => ({
        step: j,
        action: s.action.trim(),
      })),
  }))
  .filter(instr => instr.name || instr.steps.length > 0);






















*/
