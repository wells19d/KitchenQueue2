//* app.json
{
  "name": "KitchenQueue",
  "displayName": "KitchenQueue"
}

------

//* bable.config.js
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: ['react-native-reanimated/plugin'],
};

-----

//* jest.config.js
module.exports = {
  preset: 'react-native',
};

-----

//* metro.config.js
const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');

const config = {
  server: {
    enhanceMiddleware: middleware => {
      return (req, res, next) => {
        if (req.url.startsWith('/debugger-ui')) {
          res.writeHead(404);
          res.end();
          return;
        }
        return middleware(req, res, next);
      };
    },
  },
};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);

-----

//* package.json
{
  "name": "kitchen-queue",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "android": "react-native run-android",
    "ios": "react-native run-ios",
    "lint": "eslint .",
    "start": "react-native start",
    "start-clean": "react-native start --reset-cache",
    "pod-clean": "cd ios && pod install --repo-update && cd ..",
    "gradle-clean": "cd android && ./gradlew clean && cd ..",
    "clean-project": "rm -rf node_modules && yarn cache clean && yarn install && yarn pod-clean && yarn gradle-clean",
    "clean-and-start": "rm -rf node_modules && yarn cache clean && yarn install && yarn pod-clean && yarn gradle-clean && yarn start-clean",
    "open-studio": "open -a 'Android Studio'",
    "test": "jest"
  },
  "dependencies": {
    "@dicebear/collection": "9.2.2",
    "@dicebear/core": "9.2.2",
    "@react-native-async-storage/async-storage": "2.1.2",
    "@react-native-clipboard/clipboard": "1.16.2",
    "@react-native-firebase/app": "^21.12.0",
    "@react-native-firebase/auth": "^21.12.0",
    "@react-native-firebase/firestore": "^21.12.0",
    "@react-navigation/native": "7.0.17",
    "@react-navigation/native-stack": "7.3.1",
    "@shopify/flash-list": "1.7.6",
    "pluralize": "8.0.0",
    "react": "19.0.0",
    "react-native": "0.78.1",
    "react-native-config": "1.5.5",
    "react-native-device-info": "14.0.4",
    "react-native-gesture-handler": "2.24.0",
    "react-native-haptic-feedback": "2.3.3",
    "react-native-permissions": "5.2.6",
    "react-native-reanimated": "3.17.1",
    "react-native-safe-area-context": "^5.3.0",
    "react-native-screens": "4.9.2",
    "react-native-svg": "15.11.2",
    "react-native-toast-message": "2.2.1",
    "react-native-uuid": "2.0.3",
    "react-native-vector-icons": "10.2.0",
    "react-redux": "9.2.0",
    "redux": "5.0.1",
    "redux-persist": "6.0.0",
    "redux-saga": "1.3.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.10",
    "@babel/helpers": "^7.26.10",
    "@babel/runtime": "^7.26.10",
    "@react-native-community/cli": "15.1.3",
    "@react-native-community/cli-platform-android": "15.1.3",
    "@react-native-community/cli-platform-ios": "15.1.3",
    "@react-native/babel-preset": "0.78.1",
    "@react-native/eslint-config": "0.78.1",
    "@react-native/metro-config": "0.78.1",
    "@react-native/typescript-config": "0.78.1",
    "react-test-renderer": "19.0.0"
  },
  "resolutions": {
    "@babel/runtime": "^7.26.10",
    "@babel/helpers": "^7.26.10"
  },
  "engines": {
    "node": ">=18"
  }
}

-----

//* react-native.config.js
module.exports = {
  project: {
    ios: {},
    android: {},
  },
  assets: ['./src/fonts'],
  dependencies: {
    'react-native-vector-icons': {
      platforms: {
        android: null, // ðŸ‘ˆ Tells autolink to ignore it for Android native builds
      },
    },
  },
};

-----

//*store.js
import {createStore, applyMiddleware} from 'redux';
import createSagaMiddleware from 'redux-saga';
import {persistStore, persistReducer} from 'redux-persist';
import AsyncStorage from '@react-native-async-storage/async-storage';
import rootReducer from './src/redux/reducers/_root.reducer';
import rootSaga from './src/redux/sagas/_root.saga';

const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['user', 'profile', 'account', 'shopping', 'cupboard'],
};

const persistedReducer = persistReducer(persistConfig, rootReducer);
const sagaMiddleware = createSagaMiddleware();
const store = createStore(persistedReducer, applyMiddleware(sagaMiddleware));
const persistor = persistStore(store);

sagaMiddleware.run(rootSaga);

export {store, persistor};

-----

//*CurvedBottomBar.jsx
import React from 'react';
import Svg, {
  Path,
  Defs,
  Filter,
  FeOffset,
  FeGaussianBlur,
  FeMerge,
  FeMergeNode,
} from 'react-native-svg';

const CurvedBottomBar = props => {
  const {
    width = width || 500,
    height = height || 60,
    fill = fill || '#fff',
    stroke = stroke || '#373d4370',
    strokeWidth = strokeWidth || 1,
    shadowStroke = shadowStroke || '#373d4360',
    shadowStrokeWidth = shadowStrokeWidth || 2,
  } = props;

  const startX = 0;
  const endX = width - 0;
  const topY = 2;
  const bottomY = height;

  const leftCurveStartX = width / 2 - 65;
  const leftCurveEndX = width / 2 - 30;
  const rightCurveStartX = width / 2 + 30;
  const rightCurveEndX = width / 2 + 65;

  const d = `
  M ${startX},${bottomY}
  L ${startX},20
  C ${startX},20 ${topY},${topY} 25,${topY}
  L ${leftCurveStartX},${topY}
  C ${leftCurveStartX},${topY} ${width / 2 - 40},${topY} ${leftCurveEndX},25
  C ${width / 2 - 25},38 ${width / 2 - 15},44 ${width / 2},44
  C ${width / 2 + 15},44 ${width / 2 + 25},38 ${rightCurveStartX},25
  C ${width / 2 + 40},${topY} ${rightCurveEndX},${topY} ${rightCurveEndX},${topY}
  L ${endX - 20},${topY}
  C ${endX - 25},${topY} ${endX - 2},${topY} ${endX},20
  L ${endX},${bottomY}`;

  return (
    <Svg width={width} height={height}>
      <Defs>
        <Filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
          <FeOffset dx="0" dy="3" />
          <FeGaussianBlur stdDeviation="3" result="blurred" />
          <FeMerge>
            <FeMergeNode in="blurred" />
            <FeMergeNode in="SourceGraphic" />
          </FeMerge>
        </Filter>
      </Defs>

      <Path
        d={d}
        fill="none"
        stroke={shadowStroke}
        strokeWidth={shadowStrokeWidth}
        filter="url(#shadow)"
      />

      <Path d={d} fill={fill} stroke={stroke} strokeWidth={strokeWidth} />
    </Svg>
  );
};

export default CurvedBottomBar;

-----

//*IconListRouter.jsx
import ADIcons from 'react-native-vector-icons/AntDesign';
import FAIcons from 'react-native-vector-icons/FontAwesome';
import FA5Icons from 'react-native-vector-icons/FontAwesome5';
import MCIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import MIIcons from 'react-native-vector-icons/MaterialIcons';
import IIcons from 'react-native-vector-icons/Ionicons';
import EIcons from 'react-native-vector-icons/Entypo';
import FIcons from 'react-native-vector-icons/Fontisto';
import FEIcons from 'react-native-vector-icons/Feather';
import SIIcons from 'react-native-vector-icons/SimpleLineIcons';
import MIcons from 'react-native-vector-icons/MaterialIcons';
import ZOIcons from 'react-native-vector-icons/Zocial';
import {Keyboard} from 'react-native';

export const Icons = {
  Account: props => (
    <MCIcons name="account-circle" size={20} color="#000" {...props} />
  ),
  AddList: props => (
    <MCIcons name="playlist-plus" size={20} color="#000" {...props} />
  ),
  Back: props => (
    <MIIcons name="arrow-back-ios" size={20} color="#000" {...props} />
  ),
  Barcode: props => (
    <FAIcons name="barcode" size={20} color="#000" {...props} />
  ),
  Check: props => <FA5Icons name="check" size={20} color="#000" {...props} />,
  ChevronDown: props => (
    <FEIcons name="chevron-down" size={20} color="#000" {...props} />
  ),
  ChevronUp: props => (
    <FEIcons name="chevron-up" size={20} color="#000" {...props} />
  ),
  CirclePlus: props => (
    <ADIcons name="pluscircleo" size={20} color="#000" {...props} />
  ),
  Close: props => <MCIcons name="close" size={20} color="#000" {...props} />,
  Cupboards: props => (
    <MCIcons name="wardrobe" size={20} color="#000" {...props} />
  ),
  Dev: props => <MCIcons name="dev-to" size={20} color="#000" {...props} />,
  Edit: props => <MIIcons name="edit-note" size={20} color="#000" {...props} />,
  EyeOn: props => <MCIcons name="eye" size={20} color="#000" {...props} />,
  EyeOff: props => <MCIcons name="eye-off" size={20} color="#000" {...props} />,
  Favorite: props => <MCIcons name="star" size={20} color="#000" {...props} />,
  Filter: props => (
    <IIcons name="filter-outline" size={20} color="#000" {...props} />
  ),
  Forward: props => (
    <MIIcons name="arrow-forward-ios" size={20} color="#000" {...props} />
  ),
  Home: props => <MCIcons name="home" size={20} color="#000" {...props} />,
  Help: props => (
    <MCIcons name="help-circle" size={20} color="#000" {...props} />
  ),
  Keyboard: props => (
    <MCIcons name="keyboard-variant" size={20} color="#000" {...props} />
  ),
  Menu: props => <FEIcons name="menu" size={20} color="#000" {...props} />,
  MenuList: props => <MCIcons name="menu" size={20} color="#000" {...props} />,
  LightOn: props => (
    <MIIcons name="flashlight-on" size={20} color="#000" {...props} />
  ),
  LightOff: props => (
    <MIIcons name="flashlight-off" size={20} color="#000" {...props} />
  ),
  Logout: props => <MIIcons name="logout" size={20} color="#000" {...props} />,
  Merge: props => (
    <MCIcons name="set-merge" size={20} color="#000" {...props} />
  ),
  Plus: props => <MCIcons name="plus" size={20} color="#000" {...props} />,
  Profile: props => (
    <ADIcons name="profile" size={20} color="#000" {...props} />
  ),
  Recipe: props => (
    <MCIcons name="treasure-chest" size={20} color="#000" {...props} />
  ),
  Save: props => (
    <MCIcons name="content-save" size={20} color="#000" {...props} />
  ),
  Search: props => <MIIcons name="search" size={20} color="#000" {...props} />,
  Settings: props => (
    <FA5Icons name="wrench" size={20} color="#000" {...props} />
  ),
  Shopping: props => (
    <FAIcons name="shopping-cart" size={20} color="#000" {...props} />
  ),
  Split: props => (
    <MCIcons name="set-split" size={20} color="#000" {...props} />
  ),
  Wave: props => <MCIcons name="wave" size={20} color="#000" {...props} />,
  Waves: props => <MCIcons name="waves" size={20} color="#000" {...props} />,
};

-----

//*NavHeader.jsx
import React, {useCallback} from 'react';
import {Alert, TouchableOpacity, View} from 'react-native';
import {useNavigation} from '@react-navigation/native';
import {Text} from '../KQ-UI';
import {Icons} from './IconListRouter';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useDispatch} from 'react-redux';
import {useProfile, useShoppingCart} from '../hooks/useHooks';
import {NavHeaderStyles} from '../styles/Styles';

const NavHeader = ({
  title = '',
  headerColor = '#319177',
  textColor = '#000',
  LeftButton = 'None',
  RightButton = 'None',
  LeftAction,
  RightAction,
  sheetOpen,
}) => {
  const navigation = useNavigation();
  const useHaptics = setHapticFeedback();
  const dispatch = useDispatch();
  const shopping = useShoppingCart();
  const profile = useProfile();
  let fadeText = '#ffffff60';

  const cartList =
    shopping?.items?.filter(item => item.status === 'shopping-cart') ?? [];

  const handleSignOut = useCallback(() => {
    Alert.alert('Logging Out', 'Are you sure you want to logout?', [
      {text: 'Cancel', style: 'destructive'},
      {
        text: 'Confirm',
        onPress: () => {
          useHaptics(profile?.userSettings?.hapticStrength || 'light');
          dispatch({type: 'LOGOUT'});
        },
      },
    ]);
  }, [profile?.userSettings?.hapticStrength, dispatch]);

  const NavButton = React.memo(
    ({position, action, navigate, goBack, title, icon}) => {
      const handlePress = useCallback(() => {
        if (navigate) navigation.navigate(navigate);
        if (goBack) navigation.goBack();
        if (action) action();
        useHaptics(profile?.userSettings?.hapticStrength || 'light');
      }, [navigate, goBack, action, profile?.userSettings?.hapticStrength]);

      const isLeft = position === 'Left';

      if (sheetOpen) {
        return (
          <View
            style={[
              isLeft
                ? NavHeaderStyles.leftWrapper
                : NavHeaderStyles.rightWrapper,
              {flex: 1},
            ]}>
            {isLeft && icon && (
              <View style={NavHeaderStyles.iconPosition}>{icon}</View>
            )}
            <View
              style={
                isLeft
                  ? NavHeaderStyles.leftContainer
                  : NavHeaderStyles.rightContainerAlt
              }>
              {title && (
                <Text style={{color: sheetOpen ? fadeText : textColor}}>
                  {title}
                </Text>
              )}
            </View>
            {!isLeft && icon && (
              <View style={NavHeaderStyles.iconPosition}>{icon}</View>
            )}
          </View>
        );
      } else {
        return (
          <TouchableOpacity onPress={handlePress}>
            <View
              style={
                isLeft
                  ? NavHeaderStyles.leftWrapper
                  : NavHeaderStyles.rightWrapper
              }>
              {isLeft && icon && (
                <View style={NavHeaderStyles.iconPosition}>{icon}</View>
              )}
              <View
                style={
                  isLeft
                    ? NavHeaderStyles.leftContainer
                    : NavHeaderStyles.rightContainerAlt
                }>
                {title && <Text style={{color: textColor}}>{title}</Text>}
              </View>
              {!isLeft && icon && (
                <View style={NavHeaderStyles.iconPosition}>{icon}</View>
              )}
            </View>
          </TouchableOpacity>
        );
      }
    },
  );

  const renderButton = (buttonType, position) => {
    if (!buttonType || buttonType === 'None') return null;

    const allowedLeftButtons = [
      'Back',
      'Cancel',
      'Cancel-WA',
      'Cancel-Scan',
      'Close',
      'Merge',
      'Split',
      'To-List',
    ];
    const allowedRightButtons = [
      'Scan',
      'Checkout',
      'Edit',
      'Logout',
      'Save',
      'Submit',
      'To-Cart',
      'Torch-On',
      'Torch-Off',
      'Update',
    ];

    if (
      (position === 'Left' && !allowedLeftButtons.includes(buttonType)) ||
      (position === 'Right' && !allowedRightButtons.includes(buttonType))
    ) {
      console.warn(
        `Invalid placement: Button "${buttonType}" is not allowed on the ${position} side.`,
      );
      return null;
    }

    const buttonProps = {
      position,
      title: '',
      icon: null,
      action: null,
      navigate: null,
      goBack: false,
      showCondition: true,
    };

    switch (buttonType) {
      case 'Back':
        buttonProps.title = 'Back';
        buttonProps.icon = (
          <Icons.Back size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.goBack = true;
        break;

      case 'Cancel':
        buttonProps.title = 'Cancel';
        buttonProps.goBack = true;
        break;

      case 'Cancel-WA':
        buttonProps.title = 'Cancel';
        buttonProps.action = () => LeftAction();
        break;

      case 'Cancel-Scan':
        buttonProps.title = 'Cancel';
        buttonProps.action = () => LeftAction();
        break;

      case 'Checkout':
        buttonProps.title = 'Checkout';
        buttonProps.showCondition = cartList?.length > 0;
        buttonProps.icon = (
          <Icons.Forward size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Close':
        buttonProps.title = 'Close';
        buttonProps.action = () => LeftAction();
        break;

      case 'Edit':
        buttonProps.title = 'Edit';
        buttonProps.icon = (
          <Icons.Edit size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Logout':
        buttonProps.title = 'Logout';
        buttonProps.icon = (
          <Icons.Logout size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = handleSignOut;
        break;

      case 'Merge':
        buttonProps.title = 'Grouped';
        buttonProps.icon = (
          <View style={{marginRight: 5}}>
            <Icons.Merge size={25} color={sheetOpen ? fadeText : textColor} />
          </View>
        );
        buttonProps.action = () => LeftAction();
        break;

      case 'Save':
        buttonProps.title = 'Save';
        buttonProps.icon = (
          <Icons.Save size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Scan':
        buttonProps.title = 'Scan';
        buttonProps.icon = (
          <Icons.Barcode size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Split':
        buttonProps.title = 'Single';
        buttonProps.icon = (
          <View style={{marginRight: 5}}>
            <Icons.Split size={25} color={sheetOpen ? fadeText : textColor} />
          </View>
        );
        buttonProps.action = () => LeftAction();
        break;

      case 'To-Cart':
        buttonProps.title = 'Cart';
        buttonProps.navigate = 'InCart';
        buttonProps.icon = <Icons.Forward size={20} color={textColor} />;
        buttonProps.showCondition = cartList?.length > 0;
        break;

      case 'To-List':
        buttonProps.title = 'List';
        buttonProps.navigate = 'ShoppingList';
        buttonProps.icon = (
          <Icons.Back size={20} color={sheetOpen ? fadeText : textColor} />
        );
        break;
      case 'Torch-On':
        buttonProps.title = 'Light On';
        buttonProps.icon = (
          <Icons.LightOn size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;
      case 'Torch-Off':
        buttonProps.title = 'Light Off';
        buttonProps.icon = (
          <Icons.LightOff size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      default:
        console.warn(`Unknown buttonType: "${buttonType}"`);
        return null;
    }

    if (!buttonProps.showCondition) return null;

    return <NavButton {...buttonProps} />;
  };

  return (
    <View
      style={[
        NavHeaderStyles.header,
        {backgroundColor: headerColor ?? '#fff', height: 50},
      ]}>
      <View style={NavHeaderStyles.titleContainer}>
        <Text style={{color: textColor}}>{title}</Text>
      </View>
      <View style={NavHeaderStyles.buttonContainer}>
        <View style={NavHeaderStyles.buttonRows}>
          <View style={NavHeaderStyles.sideContainers}>
            {renderButton(LeftButton, 'Left')}
          </View>
          <View style={NavHeaderStyles.sideContainers}>
            {renderButton(RightButton, 'Right')}
          </View>
        </View>
      </View>
    </View>
  );
};

export default React.memo(NavHeader);

-----

//*NavMenu.jsx
import React, {useMemo} from 'react';
import {Alert, TouchableOpacity, View} from 'react-native';
import CurvedBottomBar from './CurvedBottomBar';
import {Icons} from '../components/IconListRouter';
import {useNavigation} from '@react-navigation/native';
import {getNavBarHeight} from '../utilities/deviceUtils';
import {
  CurvedBarStyles,
  MenuButtonStyles,
  NavMenuStyles,
} from '../styles/Styles';
import {Text} from '../KQ-UI';

const NavMenu = props => {
  const {bottomHeight, bottomWidth, toggleMenu, device, setIsSheetOpen} = props;
  const navigation = useNavigation();

  const navHeight = useMemo(
    () => getNavBarHeight(device, bottomHeight),
    [device, bottomHeight],
  );

  const userItems = [
    {
      id: 'shopping',
      title: 'Shopping',
      icon: <Icons.Shopping size={25} color={'#000'} />,
      screen: 'ShoppingList',
    },
    {
      id: 'cupboard',
      title: 'Cupboard',
      icon: <Icons.Cupboards size={25} color={'#000'} />,
      screen: 'CupboardList',
    },
  ];

  const getNavBarLayout = (items = []) => {
    const requiredItems = [
      {
        id: 'home',
        title: 'Home',
        icon: <Icons.Home size={27} color={'#000'} />,
        screen: 'Home',
      },
      {
        id: 'account',
        title: 'Account',
        icon: <Icons.Account size={25} color={'#000'} />,
        screen: 'Account',
      },
    ];

    // Combine required and user items, Home first, Account last
    let allItems = [requiredItems[0], ...items, requiredItems[1]];

    // Ensure odd number of slots (to keep center slot open)
    if (allItems.length % 2 === 0) {
      allItems.splice(Math.floor(allItems.length / 2), 0, {id: 'spacer'}); // Center spacer
    }

    return allItems;
  };

  const navItems = getNavBarLayout(userItems);

  const handleNavPress = item => {
    setIsSheetOpen(false);
    const allowedScreens = ['Home', 'ShoppingList', 'CupboardList', 'Account'];

    if (allowedScreens.includes(item.screen)) {
      navigation.navigate(item.screen);
    } else {
      Alert.alert('Coming Soon', `${item.title} screen not yet available.`);
    }
  };

  return (
    <View style={NavMenuStyles.container}>
      <View style={{height: navHeight}}>
        <CurvedBottomBar
          height={bottomHeight}
          width={bottomWidth}
          fill={CurvedBarStyles.fillColor}
          stroke={CurvedBarStyles.strokeColor}
          strokeWidth={CurvedBarStyles.strokeWidth}
          shadowStroke={CurvedBarStyles.shadowStroke}
          shadowStrokeWidth={CurvedBarStyles.shadowStrokeWidth}
        />
        <View style={MenuButtonStyles.wrapper}>
          {navItems.map((item, index) => {
            if (item.id === 'spacer') {
              return (
                <View key={index} style={MenuButtonStyles.container}>
                  <TouchableOpacity
                    style={MenuButtonStyles.button}
                    onPress={toggleMenu}>
                    <Icons.Menu size={30} color={'#fff'} />
                  </TouchableOpacity>
                </View>
              );
            }
            return (
              <TouchableOpacity
                key={index}
                onPress={() => handleNavPress(item)}
                style={MenuButtonStyles.menuButton}>
                {item.icon}
                <Text size="tiny" font="open-6">
                  {item.title}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>
      </View>
    </View>
  );
};

export default NavMenu;

-----

//*SplashScreen.jsx
import React from 'react';
import {View, Text, StyleSheet, ActivityIndicator, Image} from 'react-native';

const SplashScreen = () => {
  const logo = require('../images/AppLogo_350.png');
  return (
    <View style={styles.container}>
      <View style={{marginBottom: -24}}>
        <Image source={logo} style={styles.image} />
      </View>
      <View style={{position: 'absolute', top: '44%', left: '50%'}}>
        <ActivityIndicator size="large" color="#319177" />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 36,
    padding: 5,
    fontFamily: 'Montserrat-Bold',
  },
  indicator: {
    marginVertical: 5,
    paddingTop: 8,
    paddingBottom: 5,
    paddingLeft: 8,
    paddingRight: 6,
  },
  image: {},
});

export default SplashScreen;

-----

//* useAuthSync
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import auth from '@react-native-firebase/auth';

const useAuthSync = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    const unsubscribe = auth().onAuthStateChanged(firebaseUser => {
      if (firebaseUser) {
        dispatch({type: 'SET_USER', payload: firebaseUser});
      } else {
        dispatch({type: 'LOGOUT'});
      }
    });

    return () => unsubscribe();
  }, [dispatch]);
};

export default useAuthSync;


-----

//*setHapticFeedback.jsx
import HapticFeedback from 'react-native-haptic-feedback';

export const setHapticFeedback = () => {
  const triggerHaptic = props => {
    const options = {
      enableVibrateFallback: true,
      ignoreAndroidSystemSettings: false,
    };
    // console.log('props:', props);
    switch (props) {
      case 'off':
        break;
      case 'light':
        HapticFeedback.trigger('impactLight', options);
        break;
      case 'medium':
        HapticFeedback.trigger('impactMedium', options);
        break;
      case 'heavy':
        HapticFeedback.trigger('impactHeavy', options);
        break;
      case 'success':
        HapticFeedback.trigger('notificationSuccess', options);
        break;
      case 'warning':
        HapticFeedback.trigger('notificationWarning', options);
        break;
      case 'error':
        HapticFeedback.trigger('notificationError', options);
        break;
      default:
        HapticFeedback.trigger('impactLight', options);
        break;
    }
  };

  return triggerHaptic;
};

-----

//*useHooks.jsx
import {useSelector} from 'react-redux';

export const useDeviceInfo = () => {
  return useSelector(state => state.deviceInfo?.deviceInfo);
};

export const useAuth = () => {
  return useSelector(state => state.user?.isAuthenticated);
};

export const useUser = () => {
  return useSelector(state => state.user?.data);
};

export const useLoginError = () => {
  return useSelector(state => state.user?.error);
};

export const useProfile = () => {
  return useSelector(state => state.profile?.profile);
};

export const useProfileError = () => {
  return useSelector(state => state.profile?.error);
};

export const useAccount = () => {
  return useSelector(state => state.account?.account);
};

export const useAccountError = () => {
  return useSelector(state => state.account?.error);
};

export const useShoppingCart = () => {
  return useSelector(state => state.shopping?.shopping);
};

export const useShoppingCartError = () => {
  return useSelector(state => state.shopping?.error);
};

export const useCupboard = () => {
  return useSelector(state => state.cupboard?.cupboard);
};

export const useCupboardError = () => {
  return useSelector(state => state.cupboard?.error);
};

export const useAllowedProfiles = () => {
  return useSelector(state => state.account?.allowedProfiles);
};

export const useExistingInvite = () => {
  return useSelector(state => state.invites?.existingInvite || null);
};

export const useFoodData = () => {
  return useSelector(state => state.edamam?.foodData);
};

export const useFoodDataError = () => {
  return useSelector(state => state.edamam?.error);
};

export const useFoodDataLoading = () => {
  return useSelector(state => state.edamam?.loading);
};

-----

//* index.js (KQ-UI)
export {default as Text} from './KQText';
export {default as BottomSheet} from './KQBottomSheet';
export {default as Toast} from './KQToast';
export {default as Layout} from './KQLayout';
export {default as Modal} from './KQModal';
export {default as Button} from './KQButton';
export {default as Input} from './KQInput';
export {default as Dropdown} from './KQDropdown';
export {default as ScrollView} from './KQScrollView';

-----

//* KQBottomSheet.jsx
import React, {useEffect, useRef, useState} from 'react';
import {
  View,
  Animated,
  StyleSheet,
  Dimensions,
  TouchableWithoutFeedback,
} from 'react-native';
import {PanGestureHandler, State} from 'react-native-gesture-handler';

const {height} = Dimensions.get('window');

const KQBottomSheet = ({
  visible,
  onClose,
  children,
  snapPoints = [0.01, 0.9], // Default snap points
}) => {
  const translateY = useRef(new Animated.Value(height)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  const [isFullyVisible, setIsFullyVisible] = useState(visible);
  const [heightMulti, setHeightMulti] = useState(0.8);

  useEffect(() => {
    if (visible) {
      setIsFullyVisible(true); // Ensure component is mounted
      Animated.parallel([
        Animated.spring(translateY, {
          toValue: height * (1 - snapPoints[1]),
          speed: 7,
          bounciness: 3,
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 1,
          duration: 250, // Smooth fade-in
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.spring(translateY, {
          toValue: height, // Move off-screen
          speed: 5,
          bounciness: 0,
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start(() => {
        setTimeout(() => {
          setIsFullyVisible(false); // Only unmount AFTER animation completes
        }, 500);
      });
    }
  }, [visible]);

  if (!isFullyVisible) return null; // Prevent rendering when fully hidden

  const handleGesture = event => {
    const {translationY} = event.nativeEvent;

    if (translationY >= 0) {
      translateY.setValue(height * (1 - snapPoints[1]) + translationY);
    }
  };

  const handleStateChange = event => {
    const {translationY, velocityY} = event.nativeEvent;

    if (event.nativeEvent.state === State.END) {
      if (translationY > height * 0.5 || velocityY > 1.5) {
        Animated.timing(translateY, {
          toValue: height,
          duration: 250,
          useNativeDriver: true,
        }).start(() => onClose());
      } else {
        Animated.spring(translateY, {
          toValue: height * (1 - snapPoints[1]),
          speed: 7,
          bounciness: 3,
          useNativeDriver: true,
        }).start();
      }
    }
  };

  return (
    <TouchableWithoutFeedback
      onPress={e => {
        if (e.target === e.currentTarget) {
          onClose(); // Only close if tapping outside the modal
        }
      }}
      accessible={false} // Prevents interference with child components
    >
      <Animated.View style={[styles.overlay, {opacity}]}>
        <Animated.View
          style={[
            styles.sheet,
            {transform: [{translateY}]},
            {height: height * heightMulti},
          ]}>
          <PanGestureHandler
            onGestureEvent={handleGesture}
            onHandlerStateChange={handleStateChange}>
            <View style={styles.handleContainer}>
              <View style={styles.handle} />
            </View>
          </PanGestureHandler>
          <View style={styles.viewableArea}>{children}</View>
        </Animated.View>
      </Animated.View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'flex-end',
  },
  sheet: {
    width: '100%',
    height: height,
    backgroundColor: '#fff',
    borderTopLeftRadius: 15,
    borderTopRightRadius: 15,
  },
  handleContainer: {
    alignItems: 'center',
    paddingTop: 15,
    paddingBottom: 15,
  },
  handle: {
    width: 40,
    height: 5,
    backgroundColor: '#c4c4c4',
    borderRadius: 10,
  },
  viewableArea: {
    flex: 1,
    marginHorizontal: 5,
    // borderWidth: 1,
    marginBottom: 55,
  },
});

export default React.memo(KQBottomSheet);

-----

//* KQButton.jsx
import React, {useCallback} from 'react';
import {StyleSheet, TouchableOpacity, View} from 'react-native';
import {Text} from '../KQ-UI/';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useProfile} from '../hooks/useHooks';
import {
  useColors,
  useFontStyles,
  useButtonStyles,
  useButtonSizes,
} from './KQUtilities';

const KQButton = ({
  children,
  onPress,
  style = {},
  textStyle = {},
  outerTextStyle = {},
  type = 'filled',
  size = 'small',
  color = 'primary',
  textSize = 'small',
  textColor = 'white',
  fontType = 'open-6',
  hapticFeedback = 'light',
  disabled = false,
  ...props
}) => {
  const useHaptics = setHapticFeedback();
  const profile = useProfile();
  const buttonColor = useColors(disabled ? 'basic' : color);
  const buttonStyle = useButtonStyles(type, buttonColor);
  const buttonSize = useButtonSizes(size);

  const fontStyles = useFontStyles(
    fontType,
    textSize,
    type === 'filled' ? textColor : buttonColor,
  );

  const handlePress = useCallback(() => {
    useHaptics(profile?.userSettings?.hapticStrength || hapticFeedback);
    if (onPress) onPress();
  }, [profile?.userSettings?.hapticStrength, hapticFeedback, onPress]);

  return (
    <TouchableOpacity
      style={[ButtonStyles.buttonOC, buttonStyle, buttonSize, style]}
      onPress={!disabled ? handlePress : null}
      disabled={disabled}
      {...props}>
      <View style={outerTextStyle}>
        <Text
          numberOfLines={1}
          style={[ButtonStyles.buttonText, fontStyles, textStyle]}>
          {children}
        </Text>
      </View>
    </TouchableOpacity>
  );
};

const ButtonStyles = StyleSheet.create({
  buttonOC: {
    borderRadius: 5,
    margin: 5,
    alignContent: 'center',
    alignItems: 'center',
    justifyContent: 'center',
  },
  buttonText: {
    fontSize: 16,
    textAlign: 'center',
  },
});

export default React.memo(KQButton);

-----

//* KQDropdown.jsx

import React, {useMemo, useState} from 'react';
import {View, TouchableOpacity, Platform} from 'react-native';
import {Modal, Text, ScrollView} from '../KQ-UI/';
import {Icons} from '../components/IconListRouter';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useProfile} from '../hooks/useHooks';

const KQDropdown = ({
  label = '',
  labelStyles = {},
  required = false,
  validation = false,
  validationMessage = '',
  value = null,
  setValue = () => {},
  placeholder = '',
  onPress = () => {},
  caption,
  hapticFeedback = 'light',
  mapData,
  ...props
}) => {
  const isIOS = Platform.OS === 'ios';
  const useHaptics = setHapticFeedback();
  const profile = useProfile();
  const [showDropModal, setShowDropModal] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  const handleOnPress = () => {
    useHaptics(profile?.userSettings?.hapticStrength || hapticFeedback);
    setSelectedItem(value); // set to current value on open
    setShowDropModal(true);
    onPress();
  };

  const renderStyles = useMemo(() => {
    if (isIOS && value === null) {
      return {
        color: '#373d4350',
        padding: 0,
      };
    }

    if (!isIOS && value === null) {
      return {
        color: '#373d43',
        padding: 0,
        opacity: 0.8,
      };
    }
  }, [value, placeholder]);

  const handleCancel = () => {
    setShowDropModal(false);
    setSelectedItem(null);
  };

  const handleSave = item => {
    setShowDropModal(false);
    setValue(item);
  };

  const handleClear = () => {
    setSelectedItem(null);
    setValue(null);
  };

  return (
    <View style={styles.dropContainer}>
      {label && (
        <View style={styles.labelContainer}>
          <View style={styles.labelContainer}>
            <Text
              size="small"
              font="open-6"
              style={[styles.label(validation, props.disabled), labelStyles]}>
              {label} {required && '*'}
            </Text>
          </View>
        </View>
      )}
      <View style={styles.dropWrapper}>
        <TouchableOpacity onPress={() => handleOnPress()} style={{flex: 1}}>
          <Text style={renderStyles}>{value?.label || placeholder}</Text>
        </TouchableOpacity>

        {value && (
          <TouchableOpacity
            onPress={() => handleClear()}
            style={{paddingHorizontal: 5}}>
            <Icons.Close />
          </TouchableOpacity>
        )}

        <TouchableOpacity
          onPress={() => handleOnPress()}
          style={{paddingHorizontal: 5}}>
          <Icons.ChevronDown />
        </TouchableOpacity>
      </View>
      {caption && (
        <View style={styles.captionContainer}>
          <View style={{flex: 1}}>
            <Text
              size="xSmall"
              kqColor="dark90"
              font="open-5"
              numberOfLines={1}>
              ({caption})
            </Text>
          </View>
        </View>
      )}
      <Modal
        visible={showDropModal}
        fullScreen
        hideHeader
        onClose={() => setShowDropModal(false)}>
        <View style={styles.modalContainer}>
          <View style={styles.headerContainer}>
            <TouchableOpacity
              style={styles.headerButtonContainer}
              onPress={handleCancel}>
              <View style={styles.headerButtonIcon}>
                <View style={{position: 'relative', left: 4}}>
                  <Icons.Back />
                </View>
              </View>
              <View style={styles.headerButtonTextLeft}>
                <Text>Cancel</Text>
              </View>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.headerButtonContainer}
              onPress={() => handleSave(selectedItem)}>
              <View style={styles.headerButtonTextRight}>
                <Text>Save</Text>
              </View>
              <View style={styles.headerButtonIcon}>
                <Icons.Save />
              </View>
            </TouchableOpacity>
          </View>
          <View style={{flex: 1}}>
            <ScrollView>
              <View style={{flex: 1}}>
                {mapData?.map((item, index) => {
                  return (
                    <View
                      key={index}
                      style={{borderBottomWidth: 1, borderColor: '#373d4380'}}>
                      <TouchableOpacity
                        style={{
                          height: 48,
                          alignItems: 'flex-start',
                          justifyContent: 'center',
                          paddingHorizontal: 5,
                        }}
                        onPress={() => setSelectedItem(item)}>
                        <View style={{flexDirection: 'row'}}>
                          <View style={{flex: 1}}>
                            <Text
                              size={
                                selectedItem?.index === item.index
                                  ? 'small'
                                  : 'xSmall'
                              }
                              font={
                                selectedItem?.index === item.index
                                  ? 'open-7'
                                  : 'open-5'
                              }>
                              {item.label}
                            </Text>
                          </View>
                          {selectedItem?.index === item.index && (
                            <View>
                              <Icons.Check color={'#63B76C'} size={20} />
                            </View>
                          )}
                        </View>
                      </TouchableOpacity>
                    </View>
                  );
                })}
              </View>
            </ScrollView>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = {
  dropContainer: {
    marginHorizontal: 5,
    marginVertical: 10,
    paddingHorizontal: 2,
  },
  labelContainer: {position: 'relative', left: 0},
  label: (validation, disabled) => ({
    color: validation ? '#fE4949' : disabled ? '#373d4390' : '#373d43',
  }),
  dropWrapper: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
    paddingTop: 2,
    paddingBottom: 4,
  },
  captionContainer: {
    flexDirection: 'row',
    paddingHorizontal: 2,
    marginTop: 2,
  },
  textInputContainer: {
    flex: 1,
    paddingHorizontal: 1,
    paddingVertical: 3,
  },
  modalContainer: {flex: 1, flexDirection: 'column'},
  headerContainer: {
    height: 50,
    marginHorizontal: 5,
    marginBottom: 5,
    flexDirection: 'row',
  },
  headerButtonContainer: {
    flex: 1,
    flexDirection: 'row',
  },
  headerButtonIcon: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerButtonTextLeft: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    paddingHorizontal: 5,
  },
  headerButtonTextRight: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingHorizontal: 5,
  },
};

export default React.memo(KQDropdown);

-----

//* KQInput.jsx
import React, {useMemo} from 'react';
import {View, TextInput, StyleSheet} from 'react-native';
import {Text} from '../KQ-UI/';
import {useColors, useFontStyles} from './KQUtilities';

const KQInput = ({
  label = '',
  labelStyles = {},
  required = false,
  validation = false,
  validationMessage = '',
  value = '',
  onChangeText = () => {},
  capitalize = false,
  capitalMode = 'none',
  multiline = false,
  multiHeight = 'medium',
  scrollEnabled = true,
  caption = '',
  accessoryRight = null,
  counter = false,
  maxCount = 250,
  ...props
}) => {
  const fontStyles = useFontStyles('open-6', 'small', 'black');
  const showCount = value?.length || 0;

  const multiMode = useMemo(() => {
    if (!multiline) return {};

    const heightMap = {
      small: {minHeight: 20, maxHeight: 40},
      medium: {minHeight: 20, maxHeight: 75},
      large: {minHeight: 20, maxHeight: 150},
      xLarge: {minHeight: 20, maxHeight: 250},
      full: {minHeight: 20},
    };

    return {...(heightMap[multiHeight] || heightMap.medium)};
  }, [multiline, multiHeight]);

  const capMode = useMemo(
    () => (multiline ? 'sentences' : capitalize ? capitalMode : 'none'),
    [capitalize, capitalMode, multiline],
  );

  const InputInfoContainer = ({children}) => {
    if (caption || counter) {
      return (
        <View
          style={{
            flexDirection: 'row',
            paddingHorizontal: 2,
            marginTop: 2,
          }}>
          {children}
        </View>
      );
    }
    return null;
  };

  const handleTextChange = text => {
    if (text.length > maxCount) {
      text = text.substring(0, maxCount); // Trim excess characters
    }
    onChangeText(text); // Update state
  };

  return (
    <View style={styles.inputContainer}>
      {label && (
        <View style={styles.labelContainer}>
          <Text
            size="small"
            font="open-6"
            style={[styles.label(validation, props.disabled), labelStyles]}>
            {label} {required && '*'}
          </Text>
        </View>
      )}
      <View style={styles.inputWrapper}>
        <View style={styles.textInputContainer}>
          <TextInput
            value={value}
            onChangeText={handleTextChange}
            autoCapitalize={capMode}
            multiline={multiline}
            allowFontScaling={false}
            style={[fontStyles, multiMode, {padding: 0}]}
            {...props}
          />
        </View>
        {accessoryRight && (
          <View style={styles.accessoriesContainer}>{accessoryRight()}</View>
        )}
      </View>
      <InputInfoContainer>
        {caption && (
          <View style={{flex: 1}}>
            <Text
              size="xSmall"
              kqColor="dark90"
              font="open-5"
              numberOfLines={1}>
              ({caption})
            </Text>
          </View>
        )}
        {counter && (
          <View style={{flex: caption ? 0 : 1, alignItems: 'flex-end'}}>
            <Text
              size="xSmall"
              kqColor={showCount >= maxCount ? 'danger' : 'dark90'}
              font="open-5"
              numberOfLines={1}>
              ({showCount} / {maxCount})
            </Text>
          </View>
        )}
      </InputInfoContainer>
    </View>
  );
};

const styles = {
  inputContainer: {
    marginHorizontal: 5,
    marginVertical: 10,
    paddingHorizontal: 2,
  },
  labelContainer: {position: 'relative', left: 0},
  label: (validation, disabled) => ({
    color: validation ? '#fE4949' : disabled ? '#373d4390' : '#373d43',
  }),
  inputWrapper: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
  },
  textInputContainer: {
    flex: 1,
    paddingHorizontal: 1,
    paddingVertical: 3,
  },
  accessoriesContainer: {
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
};

export default React.memo(KQInput);

-----

//* KQLayout.jsx
import React from 'react';
import {
  TouchableWithoutFeedback,
  Keyboard,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  View,
} from 'react-native';
import NavHeader from '../components/NavHeader';

const KQLayout = ({
  children,
  bgColor = '#ffffff',
  headerTitle = '',
  headerColor = '#319177',
  textColor = '#ffffff',
  LeftButton = '',
  RightButton = '',
  LeftAction = null,
  RightAction = null,
  sheetOpen = false,
  useHeader = true,
  useKeyboardHandling = false,
  innerViewStyles = {},
  outerViewStyles = {},
}) => {
  if (useKeyboardHandling) {
    return (
      <View
        style={[
          {flex: 1, backgroundColor: bgColor, paddingBottom: 25},
          outerViewStyles,
        ]}>
        <TouchableWithoutFeedback onPress={Keyboard.dismiss} accessible={false}>
          <View style={{flex: 1}}>
            {useHeader && (
              <NavHeader
                title={headerTitle}
                headerColor={headerColor}
                textColor={textColor}
                LeftButton={LeftButton}
                RightButton={RightButton}
                LeftAction={LeftAction}
                RightAction={RightAction}
                sheetOpen={sheetOpen}
              />
            )}
            <KeyboardAvoidingView
              style={{flex: 1}}
              behavior={Platform.OS === 'ios' ? 'padding' : undefined}
              keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}>
              <ScrollView
                onScrollBeginDrag={Keyboard.dismiss}
                contentContainerStyle={{flexGrow: 1}}>
                <View style={[{flex: 1}, innerViewStyles]}>{children}</View>
              </ScrollView>
            </KeyboardAvoidingView>
          </View>
        </TouchableWithoutFeedback>
      </View>
    );
  } else {
    return (
      <View
        style={[
          {flex: 1, backgroundColor: bgColor, paddingBottom: 25},
          outerViewStyles,
        ]}>
        {useHeader && (
          <NavHeader
            title={headerTitle}
            headerColor={headerColor}
            textColor={textColor}
            LeftButton={LeftButton}
            RightButton={RightButton}
            LeftAction={LeftAction}
            RightAction={RightAction}
            sheetOpen={sheetOpen}
          />
        )}
        <View style={[{flex: 1}, innerViewStyles]}>{children}</View>
      </View>
    );
  }
};

export default KQLayout;

-----

//* KQModal.jsx
import React, {useEffect, useRef, useState} from 'react';
import {
  View,
  Keyboard,
  TouchableOpacity,
  Modal,
  StatusBar,
  Pressable,
  Dimensions,
} from 'react-native';
import {Icons} from '../components/IconListRouter';
import {Text} from '../KQ-UI';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useProfile} from '../hooks/useHooks';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import {useColors} from './KQUtilities';

const KQModal = ({
  visible,
  header = '',
  children,
  height = '90%',
  width = '90%',
  headerFont = 'open-6',
  headerSize = 'small',
  headerColor = 'white',
  hideHeader = false,
  hideTitle = false,
  hideClose = false,
  fullScreen = false,
  hapticFeedback = 'light',
  onClose,
}) => {
  const useHaptics = setHapticFeedback();
  const profile = useProfile();
  const insets = useSafeAreaInsets();
  const isClosingRef = useRef(false);

  const handleClose = (event = null) => {
    const isBackdropTap = event?.target === event?.currentTarget;
    const isManualCall = !event;

    if ((isBackdropTap || isManualCall) && !isClosingRef.current) {
      isClosingRef.current = true;

      useHaptics(profile?.userSettings?.hapticStrength || hapticFeedback);
      Keyboard.dismiss();

      setTimeout(() => {
        onClose?.();
        isClosingRef.current = false;
      }, 100);
    }
  };

  const Header = () => {
    if (hideHeader) {
      return null;
    }
    return (
      <View style={styles.headerWrapper(fullScreen)}>
        <View style={styles.headerContainer}>
          {!hideTitle && (
            <Text
              kqColor={useColors(headerColor)}
              font={headerFont}
              size={headerSize}>
              {header}
            </Text>
          )}
        </View>
        {!hideClose && (
          <TouchableOpacity
            style={styles.closeButton}
            onPress={() => handleClose()}>
            <Icons.Close size={25} color={'white'} />
          </TouchableOpacity>
        )}
      </View>
    );
  };

  const [screenSize, setScreenSize] = useState({
    height: Dimensions.get('window').height,
    width: Dimensions.get('window').width,
  });

  useEffect(() => {
    const updateScreenSize = () => {
      setScreenSize({
        height: Dimensions.get('window').height,
        width: Dimensions.get('window').width,
      });
    };

    const subscription = Dimensions.addEventListener(
      'change',
      updateScreenSize,
    );

    return () => subscription?.remove();
  }, []);

  const prsHeight = Math.min(Math.max(parseFloat(height), 75), 100);
  const prsWidth = Math.min(Math.max(parseFloat(width), 75), 100);

  const topHeight = fullScreen
    ? 0
    : insets.top + (screenSize.height - (screenSize.height * prsHeight) / 100);
  const btmHeight = fullScreen
    ? 0
    : insets.bottom +
      (screenSize.height - (screenSize.height * prsHeight) / 100);
  const midHeight = screenSize.height - topHeight - btmHeight;

  const midLeftWidth = fullScreen
    ? 0
    : insets.left + (screenSize.width - (screenSize.width * prsWidth) / 100);
  const midRightWidth = fullScreen
    ? 0
    : insets.right + (screenSize.width - (screenSize.width * prsWidth) / 100);

  if (!visible) {
    return null;
  }

  return (
    <Modal
      visible={visible}
      animationType="fade"
      transparent={true}
      statusBarTranslucent
      onRequestClose={handleClose}>
      <StatusBar
        barStyle={fullScreen ? 'dark-content' : 'light-content'}
        backgroundColor={'rgba(0,0,0,0.5)'}
        translucent
      />
      <View style={styles.wrapper}>
        <Pressable
          style={styles.pressTop(topHeight, screenSize)}
          onPress={handleClose}
        />
        <View style={styles.container}>
          <Pressable
            style={styles.pressLeft(midLeftWidth, midHeight)}
            onPress={handleClose}
          />
          <View style={styles.subContainer(fullScreen, midHeight, insets)}>
            <Header />
            {children}
          </View>
          <Pressable
            style={styles.pressRight(midRightWidth, midHeight)}
            onPress={handleClose}
          />
        </View>
        <Pressable
          style={styles.pressBtm(btmHeight, screenSize)}
          onPress={handleClose}
        />
      </View>
    </Modal>
  );
};

export default React.memo(KQModal);

const styles = {
  wrapper: {
    flex: 1,
    flexDirection: 'column',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  pressTop: (topHeight, screenSize) => ({
    height: topHeight,
    width: screenSize.width,
    backgroundColor: 'transparent',
  }),
  pressBtm: (btmHeight, screenSize) => ({
    height: btmHeight,
    width: screenSize.width,
    backgroundColor: 'transparent',
  }),
  pressLeft: (midLeftWidth, midHeight) => ({
    width: midLeftWidth,
    height: midHeight,
    backgroundColor: 'transparent',
  }),
  pressRight: (midRightWidth, midHeight) => ({
    width: midRightWidth,
    height: midHeight,
    backgroundColor: 'transparent',
  }),
  container: {flex: 1, flexDirection: 'row'},
  subContainer: (fullScreen, midHeight, insets) => ({
    flex: 1,
    height: midHeight,
    borderWidth: 1,
    borderColor: '#319177',
    backgroundColor: '#fff',
    paddingTop: fullScreen ? insets.top : 0,
    paddingBottom: fullScreen ? insets.bottom : 0,
    borderRadius: fullScreen ? 0 : 10,
    shadowColor: fullScreen ? '' : 'black',
    shadowOffset: fullScreen ? {} : {width: 3, height: 4},
    shadowOpacity: fullScreen ? 0 : 0.5,
    elevation: fullScreen ? 0 : 7,
  }),

  headerWrapper: fullScreen => ({
    flexDirection: 'row',
    borderWidth: fullScreen ? 0 : 1,
    borderTopRightRadius: fullScreen ? 0 : 8,
    borderTopLeftRadius: fullScreen ? 0 : 8,
    borderColor: '#319177',
    backgroundColor: '#319177',
  }),
  headerContainer: {
    flex: 1,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  closeButton: {
    position: 'absolute',
    zIndex: 999,
    right: 0,
    borderWidth: 1.5,
    backgroundColor: '#319177',
    justifyContent: 'center',
    alignItems: 'center',
    margin: 5,
    width: 30,
    height: 30,
    borderRadius: 8,
    borderColor: 'white',
  },
};


const styles = {
  wrapper: {
    flex: 1,
    flexDirection: 'column',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  pressTop: (topHeight, screenSize) => ({
    height: topHeight,
    width: screenSize.width,
    backgroundColor: 'transparent',
  }),
  pressBtm: (btmHeight, screenSize) => ({
    height: btmHeight,
    width: screenSize.width,
    backgroundColor: 'transparent',
  }),
  pressLeft: (midLeftWidth, midHeight) => ({
    width: midLeftWidth,
    height: midHeight,
    backgroundColor: 'transparent',
  }),
  pressRight: (midRightWidth, midHeight) => ({
    width: midRightWidth,
    height: midHeight,
    backgroundColor: 'transparent',
  }),
  container: {flex: 1, flexDirection: 'row'},
  subContainer: (fullScreen, midHeight, insets) => ({
    flex: 1,
    height: midHeight,
    borderWidth: 1,
    borderColor: '#319177',
    backgroundColor: '#fff',
    paddingTop: fullScreen ? insets.top : 0,
    paddingBottom: fullScreen ? insets.bottom : 0,
    borderRadius: fullScreen ? 0 : 10,
    shadowColor: fullScreen ? '' : 'black',
    shadowOffset: fullScreen ? {} : {width: 3, height: 4},
    shadowOpacity: fullScreen ? 0 : 0.5,
    elevation: fullScreen ? 0 : 7,
  }),

  headerWrapper: fullScreen => ({
    flexDirection: 'row',
    borderWidth: fullScreen ? 0 : 1,
    borderTopRightRadius: fullScreen ? 0 : 8,
    borderTopLeftRadius: fullScreen ? 0 : 8,
    borderColor: '#319177',
    backgroundColor: '#319177',
  }),
  headerContainer: {
    flex: 1,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  closeButton: {
    position: 'absolute',
    zIndex: 999,
    right: 0,
    borderWidth: 1.5,
    backgroundColor: '#319177',
    justifyContent: 'center',
    alignItems: 'center',
    margin: 5,
    width: 30,
    height: 30,
    borderRadius: 8,
    borderColor: 'white',
  },
};

-----

//* KQScrollView.jsx
import React, {useState, useRef, useEffect} from 'react';
import {ScrollView, View, StyleSheet} from 'react-native';

const KQScrollView = ({children, style}) => {
  const [scrollBarHeight, setScrollBarHeight] = useState(0);
  const [scrollBarTop, setScrollBarTop] = useState(0);
  const [layoutHeight, setLayoutHeight] = useState(0);
  const [contentHeight, setContentHeight] = useState(0);

  const scrollViewRef = useRef();

  useEffect(() => {
    if (layoutHeight > 0 && contentHeight > layoutHeight) {
      const visibleRatio = layoutHeight / contentHeight;
      const calculatedHeight = layoutHeight * visibleRatio;
      const minHeight = 30;
      setScrollBarHeight(Math.max(calculatedHeight, minHeight));
      setScrollBarTop(0);
    } else {
      setScrollBarHeight(0);
      setScrollBarTop(0);
    }
  }, [layoutHeight, contentHeight]);

  const handleLayout = event => {
    const {height} = event.nativeEvent.layout;
    setLayoutHeight(height);
  };

  const handleContentSizeChange = (width, height) => {
    setContentHeight(height);
  };

  const handleScroll = event => {
    const {layoutMeasurement, contentOffset, contentSize} = event.nativeEvent;
    const scrollRatio =
      contentOffset.y / (contentSize.height - layoutMeasurement.height);
    const calculatedTop =
      scrollRatio * (layoutMeasurement.height - scrollBarHeight);
    setScrollBarTop(calculatedTop);
  };

  return (
    <View style={[styles.container, style]}>
      <ScrollView
        ref={scrollViewRef}
        onScroll={handleScroll}
        onLayout={handleLayout}
        onContentSizeChange={handleContentSizeChange}
        scrollEventThrottle={16}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}>
        {children}
      </ScrollView>
      {scrollBarHeight > 0 && (
        <View style={styles.scrollBar}>
          <View
            style={[
              styles.scrollBarThumb,
              {
                height: scrollBarHeight,
                top: scrollBarTop,
              },
            ]}
          />
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    position: 'relative',
    marginHorizontal: 3,
    paddingHorizontal: 5,
  },
  scrollContent: {
    flexGrow: 1,
    paddingRight: 10,
    paddingTop: 5,
    paddingBottom: 5,
  },
  scrollBar: {
    position: 'absolute',
    right: 2,
    top: 2,
    bottom: 2,
    width: 4,
    backgroundColor: 'transparent',
    borderRadius: 2,
  },
  scrollBarThumb: {
    position: 'absolute',
    left: 0,
    right: 0,
    backgroundColor: '#373d4380',
    borderRadius: 3,
  },
});

export default KQScrollView;

-----

 //* KQText.jsx
import React from 'react';
import {Text} from 'react-native';
import {useFontStyles} from './KQUtilities';

const KQText = ({
  children,
  style,
  size = 'small',
  kqColor = 'black',
  font = 'open-6',
  ...props
}) => {
  const fontStyles = useFontStyles(font, size, kqColor);

  return (
    <Text allowFontScaling={false} style={[fontStyles, style]} {...props}>
      {children}
    </Text>
  );
};

export default React.memo(KQText);

-----

//*KQToast.jsx
import {BaseToast} from 'react-native-toast-message';

const toastStyles = {
  baseStyle: {
    top: 60,
    minHeight: 75,
    paddingVertical: 20,
  },
  primary: {borderLeftColor: '#44B3B3'},
  success: {borderLeftColor: '#228B22'},
  info: {borderLeftColor: '#0077A2'},
  warning: {borderLeftColor: '#FCC945'},
  danger: {borderLeftColor: '#fE4949'},
  dark: {borderLeftColor: '#373d43'},
  basic: {borderLeftColor: '#C4C4C4'},
  textStyle1: {
    fontSize: 16,
    color: '#000',
    fontFamily: 'Montserrat-Bold',
  },
  textStyle2: {
    fontSize: 14,
    color: '#000',
    fontFamily: 'Montserrat-SemiBold',
  },
};

const toastConfig = {
  primary: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.primary]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  success: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.success]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  info: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.info]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  warning: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.warning]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  danger: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.danger]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  dark: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.dark]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  basic: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.basic]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
};

export default toastConfig;

-----

//* KQUtilities.jsx
import {Platform} from 'react-native';

export const useColors = color => {
  if (!color || typeof color !== 'string') return '#000000'; // Default to black

  const colors = {
    black: '#000000',
    white: '#ffffff',
    primary: '#319177',
    success: '#63B76C',
    info: '#009DC4',
    warning: '#FCC945',
    danger: '#DA2C43',
    dark: '#373d43',
    dark90: '#373d4390',
    basic: '#C4C4C4',
  };

  const normalizedColor = color.trim().toLowerCase();

  // If it's a predefined color, return it
  if (colors[normalizedColor]) {
    return colors[normalizedColor];
  }

  // If it's a valid hex or RGB(A) color, return it as is
  if (/^#([0-9A-F]{3}){1,2}$/i.test(color) || color.startsWith('rgb')) {
    return color;
  }

  return '#000000'; // Default fallback
};

const fontLookup = {
  // NotoSans mappings
  'noto-1': {ios: 'NotoSans', android: 'NotoSans-Thin', weight: 100},
  'noto-2': {ios: 'NotoSans', android: 'NotoSans-ExtraLight', weight: 200},
  'noto-3': {ios: 'NotoSans', android: 'NotoSans-Light', weight: 300},
  'noto-4': {ios: 'NotoSans', android: 'NotoSans-Regular', weight: 400},
  'noto-5': {ios: 'NotoSans', android: 'NotoSans-Medium', weight: 500},
  'noto-6': {ios: 'NotoSans', android: 'NotoSans-SemiBold', weight: 600},
  'noto-7': {ios: 'NotoSans', android: 'NotoSans-Bold', weight: 700},
  'noto-8': {ios: 'NotoSans', android: 'NotoSans-ExtraBold', weight: 800},
  'noto-9': {ios: 'NotoSans', android: 'NotoSans-Black', weight: 900},

  // Montserrat mappings
  'mont-1': {ios: 'Montserrat', android: 'Montserrat-Thin', weight: 100},
  'mont-2': {ios: 'Montserrat', android: 'Montserrat-ExtraLight', weight: 200},
  'mont-3': {ios: 'Montserrat', android: 'Montserrat-Light', weight: 300},
  'mont-4': {ios: 'Montserrat', android: 'Montserrat-Regular', weight: 400},
  'mont-5': {ios: 'Montserrat', android: 'Montserrat-Medium', weight: 500},
  'mont-6': {ios: 'Montserrat', android: 'Montserrat-SemiBold', weight: 600},
  'mont-7': {ios: 'Montserrat', android: 'Montserrat-Bold', weight: 700},
  'mont-8': {ios: 'Montserrat', android: 'Montserrat-ExtraBold', weight: 800},
  'mont-9': {ios: 'Montserrat', android: 'Montserrat-Black', weight: 900},

  // OpenSans mappings
  'open-3': {ios: 'OpenSans-Light', android: 'OpenSans-Light', weight: 300},
  'open-4': {ios: 'OpenSans-Regular', android: 'OpenSans-Regular', weight: 400},
  'open-5': {ios: 'OpenSans-Medium', android: 'OpenSans-Medium', weight: 500}, // Default
  'open-6': {
    ios: 'OpenSans-SemiBold',
    android: 'OpenSans-SemiBold',
    weight: 600,
  },
  'open-7': {ios: 'OpenSans-Bold', android: 'OpenSans-Bold', weight: 700},
  'open-8': {
    ios: 'OpenSans-ExtraBold',
    android: 'OpenSans-ExtraBold',
    weight: 800,
  },

  // Special cases (no weight variations)
  cherry: {
    ios: 'CherryBlossom',
    android: 'Cherry-Blossom',
    weight: 500,
  },
  banana: {
    ios: 'BananaChips-Regular',
    android: 'BananaChips-Regular',
    weight: 500,
    lineHeightFactor: 0.8, // Adjusts large vertical space
  },
};

// Default settings
const DEFAULT_FONT = 'open-5';

export const useFonts = (font = DEFAULT_FONT) => {
  const normalizedFont = font.trim().toLowerCase();
  const fontData = fontLookup[normalizedFont] || fontLookup[DEFAULT_FONT];

  return Platform.OS === 'ios'
    ? {fontFamily: fontData.ios, fontWeight: fontData.weight}
    : {fontFamily: fontData.android};
};

export const useFontSizes = (size = 'medium', font = 'OpenSans') => {
  const sizes = {
    tiny: 12,
    xSmall: 14,
    small: 16,
    medium: 18, // Default
    large: 20,
    xLarge: 24,
    giant: 28,
    massive: 36,
    gargantuan: 48,
  };

  // Scaling factors based on font
  const fontScale = {
    cherry: 1.1, // Slightly larger
    banana: 2, // Twice the size
  };

  const baseSize = sizes[size] || sizes.medium;
  const scaleFactor = fontScale[font.toLowerCase()] || 1;
  return {fontSize: baseSize * scaleFactor};
};

export const useFontStyles = (
  font = 'open-5',
  size = 'medium',
  color = 'black',
) => {
  return {
    ...useFonts(font), // âœ… Returns { fontFamily, fontWeight }
    ...useFontSizes(size, font), // âœ… Returns { fontSize }
    color: useColors(color), // âœ… Assign color as a string
  };
};

export const useButtonStyles = (type = 'filled', color = 'primary') => {
  const statusColor = useColors(color);

  const styles = {
    filled: {
      backgroundColor: statusColor,
      elevation: 3,
      shadowColor: '#373d43',
      shadowOffset: {width: 2, height: 3},
      shadowOpacity: 0.3,
    },
    outline: {
      backgroundColor: 'transparent',
      borderColor: statusColor,
      borderWidth: 2,
    },
    ghost: {
      backgroundColor: 'transparent',
    },
  };

  return styles[type] || styles.filled;
};

export const useButtonSizes = (size = 'medium') => {
  const sizes = {
    tiny: 30,
    small: 35,
    medium: 40,
    large: 50,
    giant: 60,
  };

  return {
    height: sizes[size] ?? sizes.medium,
    paddingHorizontal: 12,
  };
};

-----

//* Account.jsx
import React from 'react';
import {useRoute} from '@react-navigation/native';
import {Layout, Text} from '../../KQ-UI';

const Account = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Text>Account</Text>
    </Layout>
  );
};

export default Account;

-----

//* Cupboards.jsx
import React from 'react';
import {useRoute} from '@react-navigation/native';
import {Layout, Text} from '../../KQ-UI';

const Cupboards = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Text>Cupboards</Text>
    </Layout>
  );
};

export default Cupboards;

-----

//* Auth.jsx
import React, {useEffect, useRef} from 'react';
import {
  Animated,
  Image,
  Platform,
  StatusBar,
  TouchableWithoutFeedback,
} from 'react-native';
import MCIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import {useDispatch} from 'react-redux';
import {Button, Input, Layout} from '../../KQ-UI';
import {useDeviceInfo} from '../../hooks/useHooks';

function Auth(props) {
  const {bgColor} = props;
  const [email, setEmail] = React.useState('');
  const [password, setPassword] = React.useState('');
  const [secureTextEntry, setSecureTextEntry] = React.useState(true);
  const dispatch = useDispatch();
  const device = useDeviceInfo();

  const logoPosition = useRef(
    new Animated.Value(Platform.OS === 'ios' ? 330 : 370),
  ).current;
  const formOpacity = useRef(new Animated.Value(0)).current;
  const formTranslateY = useRef(new Animated.Value(50)).current;

  useEffect(() => {
    const screenHeight = device?.dimensions?.height || 800; // Default fallback
    const deviceSize = device?.system?.deviceSize || 'unknown';
    const os = device?.system?.os || 'unknown';

    const getLogoFinalPosition = (screenHeight, deviceSize, os) => {
      switch (`${deviceSize}-${os}`) {
        case 'xSmall-iOS':
          return screenHeight * 0.1;
        case 'xSmall-Android':
          return screenHeight * 0.12;

        case 'small-iOS':
          return screenHeight * 0.12;
        case 'small-Android':
          return screenHeight * 0.14;

        case 'medium-iOS':
          return screenHeight * 0.14;
        case 'medium-Android':
          return screenHeight * 0.16;

        case 'large-iOS':
          return screenHeight * 0.16;
        case 'large-Android':
          return screenHeight * 0.18;

        case 'xLarge-iOS': // iPhone Pro Max / Large Tablets
          return screenHeight * 0.18;
        case 'xLarge-Android': // Android XL devices
          return screenHeight * 0.2;

        default:
          return screenHeight * 0.18; // Fallback for unknown sizes
      }
    };

    const finalPosition = getLogoFinalPosition(screenHeight, deviceSize, os);

    Animated.timing(logoPosition, {
      toValue: finalPosition,
      duration: 1000,
      useNativeDriver: false,
    }).start();

    setTimeout(() => {
      Animated.parallel([
        Animated.timing(formOpacity, {
          toValue: 1,
          duration: 500,
          useNativeDriver: true,
        }),
        Animated.timing(formTranslateY, {
          toValue: 0,
          duration: 700,
          useNativeDriver: true,
        }),
      ]).start();
    }, 800);
  }, [device]); // Recalculate when `device` changes

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  const renderIcon = () => (
    <TouchableWithoutFeedback onPress={toggleSecureEntry}>
      <MCIcons
        name={secureTextEntry ? 'eye-off' : 'eye'}
        size={20}
        color={'#000'}
      />
    </TouchableWithoutFeedback>
  );

  const isValidEmail = email => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  const isValidPassword = password => password.length >= 8;
  const canSignIn = isValidEmail(email) && isValidPassword(password);

  const handleSignIn = () => {
    if (canSignIn) {
      dispatch({
        type: 'LOGIN_REQUEST',
        payload: {email, password},
      });
    }
  };

  const logo = require('../../images/AppLogo_350.png');

  return (
    <Layout useHeader={false} innerViewStyles={{justifyContent: 'center'}}>
      <StatusBar backgroundColor={bgColor} barStyle="light-content" />
      <Animated.View
        style={{
          position: 'absolute',
          top: logoPosition,
          width: '100%',
          alignItems: 'center',
        }}>
        <Image source={logo} />
      </Animated.View>
      <Animated.View
        style={{
          opacity: formOpacity,
          transform: [{translateY: formTranslateY}],
        }}>
        <Input
          placeholder="Email"
          capitalize={false}
          value={email}
          onChangeText={setEmail}
        />
        <Input
          placeholder="Password"
          value={password}
          onChangeText={setPassword}
          accessoryRight={renderIcon}
          secureTextEntry={secureTextEntry}
          capitalize={false}
        />
        <Button
          status={canSignIn ? 'primary' : 'basic'}
          onPress={handleSignIn}
          disabled={!canSignIn}>
          Sign In
        </Button>
      </Animated.View>
    </Layout>
  );
}

export default Auth;

-----

//* Home.jsx
import React from 'react';
import {useRoute} from '@react-navigation/native';
import {Layout, Text} from '../../KQ-UI';

const Home = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Text>Home</Text>
    </Layout>
  );
};

export default Home;

-----

//* Shopping.jsx
import React from 'react';
import {useRoute} from '@react-navigation/native';
import {Layout, Text} from '../../KQ-UI';

const Shopping = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Text>Shopping</Text>
    </Layout>
  );
};

export default Shopping;

-----

//* Styles.jsx
import {StyleSheet} from 'react-native';

export const AppStyles = StyleSheet.create({
  navMenu: {
    height: 90,
  },
  safeArea: {
    flex: 1,
    margin: 5,
  },
  globalContainer: {
    flex: 1,
  },
});

export const NavMenuStyles = StyleSheet.create({
  container: {flex: 1},
  wrapper: {
    height: '100%',
    width: '100%',
    position: 'absolute',
    backgroundColor: 'transparent',
    flexDirection: 'row',
    padding: 5,
  },
});

export const CurvedBarStyles = StyleSheet.create({
  fillColor: '#f7f7f7',
  strokeColor: '#373d4340',
  strokeWidth: 1.5,
  shadowStroke: '#373d4320',
  shadowStrokeWidth: 4,
});

export const MenuButtonStyles = StyleSheet.create({
  wrapper: {
    height: '100%',
    width: '100%',
    position: 'absolute',
    flexDirection: 'row',
    zIndex: 2000, // Bottom Layer
    paddingHorizontal: 5,
  },
  container: {
    flex: 1,
    height: 65,
    position: 'relative',
    top: -21,
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    zIndex: 2100, // Middle Layer
  },
  button: {
    borderWidth: 1,
    height: 55,
    width: 55,
    borderRadius: 30,
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    borderColor: '#c4c4c480',
    backgroundColor: '#319177',
    zIndex: 2300, // Over Layer
  },
  menuButton: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2200, // Top Layer
  },
});

export const ListStyles = StyleSheet.create({
  actionButton: {
    alignItems: 'center',
    borderRadius: 5,
    justifyContent: 'center',
    marginHorizontal: 2,
    width: 90,
    height: 60,
  },
  actionsContainer: {
    alignItems: 'top',
    flexDirection: 'row',
    justifyContent: 'flex-end',
    paddingHorizontal: 2,
    paddingVertical: 5,
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
  },
  addButton: {
    backgroundColor: '#44B3B3',
  },
  bottomInnerContainer: {
    borderColor: '#c4c4c4',
    borderTopWidth: 1,
    height: 58,
    justifyContent: 'center',
    marginHorizontal: -5,
  },
  bottomLeft: {
    flex: 1,
    paddingLeft: 10,
    paddingRight: 5,
  },
  bottomRight: {
    flex: 1,
    paddingLeft: 5,
    paddingRight: 10,
  },
  bottomCenter: {width: '50%', paddingLeft: 5, paddingRight: 5},
  buttonContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 2,
    width: '100%',
    height: '100%',
    backgroundColor: 'transparent',
  },
  buttonText: {
    color: '#fff',
    textAlign: 'center',
  },
  container: {
    backgroundColor: '#ffffff',
    flex: 1,
  },
  deleteButton: {
    backgroundColor: '#fE4949',
  },
  viewContainer: {
    flex: 1,
    backgroundColor: '#ffffff',
    padding: 5,
    marginBottom: 18,
  },
  updateButton: {
    backgroundColor: '#0077A2',
  },
  bottomSheet: {
    zIndex: 9000,
    borderColor: 'transparent',
    borderRadius: 18,
  },

  rmcContainer: {flex: 1},
  rmcImage: {alignItems: 'center', justifyContent: 'center'},
  rmcTitle: {
    marginHorizontal: 5,
    marginVertical: 2,
    alignItems: 'center',
    paddingVertical: 2,
  },
  rmcBrand: {
    marginHorizontal: 5,
    marginTop: 2,
    marginBottom: 5,
    alignItems: 'center',
    paddingVertical: 2,
  },
  rmcScroll: {
    flex: 1,
    paddingVertical: 5,
    paddingHorizontal: 5,
  },
  rmcScrollShellTop: {height: 5},
  rmcScrollShellBottom: {height: 15},
  rmcScrollWrapper: {
    paddingVertical: 2,
    paddingHorizontal: 5,
  },
  rmcNutrientLabel: {
    flex: 1,
    borderBottomWidth: 1,
    padding: 2,
    paddingBottom: 1,
    justifyContent: 'center',
  },
  rmcNutrientValue: {
    borderBottomWidth: 1,
    alignItems: 'flex-end',
    padding: 2,
    paddingBottom: 1,
    justifyContent: 'center',
  },
  rmcContents: {borderWidth: 0, marginTop: 10, paddingHorizontal: 5},
  rmcButtonWrapper: {flexDirection: 'row', paddingHorizontal: 5},
  rmcButtonContainer: {flex: 1, marginHorizontal: 5},
  rmcDisclaimer: {marginTop: 3, marginHorizontal: 5, paddingHorizontal: 2},
});

export const NavHeaderStyles = StyleSheet.create({
  header: {
    alignItems: 'center',
    backgroundColor: '#fff',
    borderColor: '#c4c4c490',
    borderBottomWidth: 1,
    elevation: 5,
    shadowColor: '#c4c4c490',
    shadowOffset: {width: 0, height: 4},
    shadowOpacity: 0.8,
  },
  titleContainer: {
    position: 'absolute',
    top: 0,
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2000,
  },
  buttonContainer: {
    position: 'absolute',
    top: 0,
    width: '100%',
    height: '100%',
    zIndex: 2001,
  },
  buttonRows: {flexDirection: 'row', height: '100%'},
  sideContainers: {
    flex: 1,
    justifyContent: 'center',
    paddingLeft: 15,
  },
  leftWrapper: {flexDirection: 'row', marginLeft: 0},
  leftContainer: {flex: 1, justifyContent: 'center'},
  rightWrapper: {flexDirection: 'row', marginRight: 10},
  rightContainer: {
    flex: 1,
    justifyContent: 'center',
    alignContent: 'flex-end',
    alignItems: 'flex-end',
  },
  rightContainerAlt: {
    flex: 1,
    justifyContent: 'center',
    alignContent: 'flex-end',
    alignItems: 'flex-end',
    marginRight: 5,
  },
  iconPosition: {position: 'relative', top: 1},
  textStyles: {
    fontSize: 16,
  },
});

export const ScreenStyles = StyleSheet.create({
  container: {
    backgroundColor: '#ffffff',
    flex: 1,
  },
  error: {
    color: 'red',
    flex: 1,
    fontSize: 18,
    textAlign: 'center',
  },
  errorContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  success: {
    color: 'green',
    flex: 1,
    fontSize: 22,
    marginBottom: 20,
    marginTop: 20,
    textAlign: 'center',
  },
  successContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  viewContainer: {
    flex: 1,
    paddingBottom: 2,
    padding: 5,
  },
  viewInnerTopContainer: {
    alignItems: 'center',
    paddingTop: 20,
    paddingBottom: 5,
    paddingHorizontal: 15,
  },
  scrollContainer: {
    flex: 1,
    paddingVertical: 10,
  },
});

export const SelectItemStyles = StyleSheet.create({
  container: {
    marginHorizontal: 2.5,
    flex: 1,
  },
  imageContainer: {
    flex: 0.3,
    alignItems: 'center',
    justifyContent: 'center',
  },
  updateContainer: {
    padding: 0,
    marginVertical: -5,
  },
  infoContainer: {
    flex: 0.7,
    paddingHorizontal: 5,
  },
  itemContainer: {
    flexDirection: 'row',
    borderBottomWidth: 1.5,
    borderRadius: 8,
    borderBottomColor: '#c4c4c490',
    paddingBottom: 6,
    paddingTop: 3,
  },
  itemNoteContainer: {
    borderRadius: 8,
    borderBottomColor: '#c4c4c4',
    paddingBottom: 3,
    paddingTop: 7,
  },
  titleWrap: {paddingTop: 3, paddingHorizontal: 3},
  infoWrap: {
    flex: 1,
    paddingTop: 3,
    paddingHorizontal: 4,
  },
  infoNoteWrap: {
    paddingTop: 3,
    paddingHorizontal: 4,
  },
  textStyles: {textAlign: 'right'},
  textNoteStyles: {letterSpacing: 0.2, textAlign: 'justify'},
});

export const LegalStyles = StyleSheet.create({
  container: {
    height: '100%',
    flexDirection: 'column',
  },
  body: {
    flex: 1,
  },
  buttonWrapper: {
    flexDirection: 'row',
  },
  buttonCells: {
    flex: 1,
    paddingHorizontal: 5,
  },
  sectionWrapper: {
    marginVertical: 5,
  },
  sectionHeader: {
    flexDirection: 'row',
  },
  sectionIndex: {
    width: 40,
    alignItems: 'flex-end',
    paddingRight: 3,
    paddingVertical: 3,
  },
  sectionTitle: {
    flex: 1,
    alignItems: 'flex-start',
    paddingLeft: 3,
    paddingVertical: 3,
  },
  clauseWrapper: {},
  clauseHeader: {
    flexDirection: 'row',
  },
  clauseIndexSpacing: {width: 39},
  clauseTextWrapper: {
    flex: 1,
    paddingVertical: 3,
    paddingLeft: 3,
    paddingRight: 20,
    paddingBottom: 5,
  },
  subClauseWrapper: {},
  subClauseHeader: {flexDirection: 'row'},
  bulletWrapper: {
    width: 55,
    alignItems: 'flex-end',
    paddingRight: 3,
  },
  subClauseTextWrapper: {
    flex: 1,
    paddingVertical: 2,
    paddingLeft: 3,
    paddingRight: 25,
    paddingBottom: 10,
  },
  clauseInfo: {},
});

export const SettingsStyles = StyleSheet.create({
  card: {
    marginTop: 15,
    marginHorizontal: 15,
    backgroundColor: '#319177',
    borderTopRightRadius: 8,
    borderTopLeftRadius: 8,
    borderWidth: 1,
    borderBottomWidth: 0.5,
    borderColor: '#c4c4c4',
  },
  cardTitle: {marginVertical: 10, color: '#fff'},
  topContainer: {
    borderTopWidth: 1,
    borderColor: '#c4c4c4',
    height: 70,
    backgroundColor: '#fff',
    flexDirection: 'row',
    height: 70,
  },
  innerTopContainer: {
    width: 70,
    padding: 8,
  },
  quantityCell: {
    borderWidth: 1,
    borderRadius: 8,
    borderColor: '#c4c4c4',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  infoCell: {
    flex: 1,
    marginVertical: 5,
    marginRight: 5,
    justifyContent: 'center',
    padding: 0,
  },
  bottomContainer: {
    marginHorizontal: 15,
    borderWidth: 1,
    borderTopWidth: 0.5,
    borderBottomRightRadius: 8,
    borderBottomLeftRadius: 8,
    paddingVertical: 7,
    borderColor: '#c4c4c4',
  },
  buttonContainer: {alignContent: 'center', alignItems: 'center'},

  listContainer: {
    paddingHorizontal: 10,
  },
  itemContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 15,
    marginVertical: 5,
    borderRadius: 5,
    borderWidth: 1,
    borderColor: '#dcdcdc',
  },
  description: {
    marginVertical: 10,
  },
  segmentedButtonContainer: {
    flexDirection: 'row',
    paddingHorizontal: 15,
    gap: 10,
  },
  hapticButton: {
    elevation: 3,
    shadowColor: '#373d43',
    shadowOffset: {width: 1, height: 2},
    shadowOpacity: 0.3,
    borderRadius: 5,
    marginVertical: 10,
    marginHorizontal: 5,
    alignContent: 'center',
    alignItems: 'center',
    justifyContent: 'center',
    borderColor: '#319177',
    height: 45,
  },
  hbInner: {
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    flex: 1,
    width: '100%',
    flexDirection: 'row',
  },
});

export const KQDropStyles = StyleSheet.create({
  dropdownContainer: {
    marginVertical: 5,
    marginHorizontal: 7,
  },
  labelContainer: {
    marginBottom: 4,
    marginLeft: 5,
  },
  dropdown: {
    borderWidth: 1,
    borderRadius: 5,
    borderColor: '#c4c4c4',
    minHeight: 40,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 8,
  },
  iconContainer: {
    width: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  sheetContentContainer: {
    paddingVertical: 16,
  },
  sheetItem: {
    paddingVertical: 16,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  sheetItemText: {
    fontSize: 18,
  },
  bottomSheet: {
    zIndex: 9000,
    borderColor: 'transparent',
    borderWidth: 4,
    borderRadius: 18,
  },
  captionWrap: {marginHorizontal: 10, marginBottom: 5},
  captionText: {
    color: '#373d4390',
  },
});

export const AvatarStyles = StyleSheet.create({
  avatarCard: {
    // width: 80,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'transparent',
  },
  avatarView: {
    width: 100,
    height: 100,
    borderWidth: 1,
    borderRadius: 50,
    overflow: 'hidden',
  },
});

export const ProfileStyles = StyleSheet.create({
  FTCenter: {textAlign: 'center'},
  FTLeft: {
    // fontWeight: 700,
    textAlign: 'right',
    marginRight: 5,
  },
  FTRight: {marginLeft: 5},
  optionContainer: {height: 35, flexDirection: 'row', marginVertical: 4},
  optionLeft: {
    borderWidth: 1,
    borderColor: '#373d43',
    borderTopLeftRadius: 8,
    borderBottomLeftRadius: 8,
    width: 40,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 1, height: 2},
    shadowOpacity: 0.3,
    elevation: 5,
  },
  olInner: {
    position: 'relative',
    left: 5,
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
  optionRight: {
    borderWidth: 1,
    borderColor: '#373d43',
    borderTopRightRadius: 8,
    borderBottomRightRadius: 8,
    width: 40,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 2, height: 3},
    shadowOpacity: 0.3,
    elevation: 5,
  },
  orInner: {
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
  optionView: {
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: '#373d43',
    justifyContent: 'center',
    alignItems: 'center',
    width: 150,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 2, height: 3},
    shadowOpacity: 0.3,
    elevation: 5,
  },
});

export const AccountStyles = StyleSheet.create({
  section: {flex: 1, backgroundColor: '#fff', padding: 5, marginBottom: 10},
  sectionNav: {flexDirection: 'row'},
  sectionUsers: {
    borderWidth: 1,
    borderColor: '#c4c4c4',
    borderRadius: 5,
    backgroundColor: '#fff',
    shadowColor: '#373d4380',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 5,
    paddingBottom: 15,
  },
  usersHeader: {
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
    paddingVertical: 5,
    paddingHorizontal: 10,
  },
  avatarWrapper: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    marginHorizontal: 10,
    marginTop: 5,
  },
  subWrapper: {
    height: 65,
    borderWidth: 1,
    borderColor: '#c4c4c4',
    borderRadius: 5,
    backgroundColor: '#fff',
    shadowColor: '#373d4380',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 5,
  },
  subIcon: {
    flex: 1,
    justifyContent: 'flex-end',
    alignItems: 'center',
    alignContent: 'center',
  },
  subTextWrap: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
});

export const CMStyles = StyleSheet.create({
  shContainer: {height: 35, borderWidth: 0},
  shLine: {
    borderBottomWidth: 1,
    position: 'relative',
    top: 16,
    marginLeft: 15,
    marginRight: 50,
    zIndex: 1,
  },
  shTWrap: {alignItems: 'flex-end', marginRight: 1},
  shTO: {
    height: 30,
    width: 50,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
  shTitleWrap: {
    zIndex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    top: -7,
  },
  shTitle: {
    backgroundColor: '#fff',
    paddingHorizontal: 15,
    paddingVertical: 2,
  },
  sectionExpanded: {paddingHorizontal: 25, paddingVertical: 5, marginTop: -10},
  sectionCollapsed: {
    paddingHorizontal: 25,
    paddingTop: 3,
    paddingBottom: 10,
    alignItems: 'center',
    marginTop: -10,
  },
  sectionTO: {
    flexDirection: 'row',
    paddingVertical: 5,
    alignItems: 'center',
  },
  sectionIcon: {marginRight: 20},
});

-----

//* RealTimeAccounts.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount, useProfile} from '../../hooks/useHooks';

const useRealTimeAccounts = () => {
  const dispatch = useDispatch();
  const profile = useProfile();
  const db = getFirestore();

  useEffect(() => {
    if (!profile?.account) {
      return;
    }

    console.log(`ðŸ”„ Fetching Account data from Firestore`);
    const accountRef = doc(db, 'accounts', profile.account);

    const unsubscribe = onSnapshot(
      accountRef,
      snapshot => {
        if (snapshot.exists) {
          const accountData = snapshot.data();
          const account = {
            ...accountData,
            lastUpdated: accountData?.lastUpdated || null, // âœ… No more toDate()
            createdOn: accountData?.createdOn || null, // âœ… No more toDate()
          };
          dispatch({type: 'SET_ACCOUNT', payload: account});
        } else {
          dispatch({type: 'SET_ACCOUNT', payload: null});
        }
      },
      error => {
        dispatch({type: 'ACCOUNT_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, profile?.account, db]); // âœ… Removed `storedAccount`
};

export default useRealTimeAccounts;

-----

//* RealTimeAllowedProfiles.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {
  getFirestore,
  collection,
  query,
  where,
  onSnapshot,
} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeAllowedProfiles = () => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();

  useEffect(() => {
    if (!account?.allowedUsers?.length) {
      return;
    }

    console.log(`ðŸ”„ Fetching Allowed Profiles data from Firestore`);

    const profilesQuery = query(
      collection(db, 'profiles'),
      where('id', 'in', account.allowedUsers),
    );

    const unsubscribe = onSnapshot(
      profilesQuery,
      querySnapshot => {
        if (!querySnapshot.empty) {
          const profiles = querySnapshot.docs
            .map(doc => doc.data())
            .filter(profile => profile?.isActive)
            .sort((a, b) => (a.role === 'owner' ? -1 : 1));

          dispatch({type: 'SET_ALLOWED_PROFILES', payload: profiles});
        } else {
          dispatch({type: 'SET_ALLOWED_PROFILES', payload: []});
        }
      },
      error => {
        dispatch({
          type: 'ALLOWED_PROFILES_FETCH_FAILED',
          payload: error.message,
        });
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.allowedUsers, db]); // âœ… Removed `persistedProfiles`
};

export default useRealTimeAllowedProfiles;

-----

//* RealTimeCupboard.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeCupboard = () => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();

  useEffect(() => {
    if (!account?.cupboardID) {
      return;
    }

    console.log(`ðŸ”„ Fetching Cupboard data from Firestore`);
    const cupboardRef = doc(db, 'cupboards', account.cupboardID);

    const unsubscribe = onSnapshot(
      cupboardRef,
      snapshot => {
        if (snapshot.exists) {
          const cupboardData = snapshot.data();
          const cupboard = {
            ...cupboardData,
            items: cupboardData.items || [],
            lastUpdated: cupboardData?.lastUpdated || null, // âœ… No more toDate()
          };

          dispatch({type: 'SET_CUPBOARD', payload: cupboard});
        } else {
          dispatch({type: 'SET_CUPBOARD', payload: null});
        }
      },
      error => {
        dispatch({type: 'CUPBOARD_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.cupboardID, db]); // âœ… Removed `persistedCupboard`
};

export default useRealTimeCupboard;

-----

import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useProfile, useUser} from '../../hooks/useHooks';

const useRealTimeProfiles = () => {
  const dispatch = useDispatch();
  const user = useUser();
  const db = getFirestore();

  useEffect(() => {
    if (!user?.uid) {
      return;
    }

    console.log(`ðŸ”„ Fetching Profile data from Firestore`);
    const profileRef = doc(db, 'profiles', user.uid);

    const unsubscribe = onSnapshot(
      profileRef,
      snapshot => {
        if (snapshot.exists) {
          const profileData = snapshot.data();
          const profilePayload = {
            ...profileData,
            lastUpdated: profileData?.lastUpdated || null, // âœ… No more toDate()
          };
          dispatch({type: 'SET_PROFILE', payload: profilePayload});
        } else {
          dispatch({type: 'SET_PROFILE', payload: null});
        }
      },
      error => {
        dispatch({type: 'PROFILE_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, user?.uid, db]); // âœ… Removed `storedProfile`
};

export default useRealTimeProfiles;

-----

//* RealTimeShoppingCart.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount, useShoppingCart} from '../../hooks/useHooks';

const useRealTimeShoppingCart = () => {
  const dispatch = useDispatch();
  const account = useAccount();
  const persistedCart = useShoppingCart();
  const db = getFirestore();

  useEffect(() => {
    if (!account?.shoppingCartID) {
      return;
    }

    const cartRef = doc(db, 'shoppingCarts', account.shoppingCartID);
    console.log('RealTimeShoppingCart fired');

    const unsubscribe = onSnapshot(
      cartRef,
      snapshot => {
        if (snapshot.exists) {
          const shopCartData = snapshot.data();
          const shopCart = {
            ...shopCartData,
            items: shopCartData.items || [],
            lastUpdated: shopCartData?.lastUpdated || null, // âœ… No need for toDate()
          };

          // âœ… Prevent unnecessary updates by checking if data changed
          if (JSON.stringify(persistedCart) !== JSON.stringify(shopCart)) {
            dispatch({type: 'SET_SHOP_CART', payload: shopCart});
          }
        }
      },
      error => {
        dispatch({type: 'SHOP_CART_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.shoppingCartID, persistedCart, db]);
};

export default useRealTimeShoppingCart;

-----

//* RealTimeUsers.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getAuth, onAuthStateChanged} from '@react-native-firebase/auth';

const auth = getAuth();

const useRealTimeUsers = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    console.log(`ðŸ”„ Fetching User data from Firebase Auth`);

    const unsubscribe = onAuthStateChanged(auth, currentUser => {
      if (currentUser) {
        dispatch({type: 'SET_USER', payload: currentUser});
      } else {
        dispatch({type: 'UNSET_USER'});
      }
    });

    return () => {
      unsubscribe();
    };
  }, [dispatch]);
};

export default useRealTimeUsers;

-----
//* categories.js

export const displayCategories = [
  {index: 0, key: 'na', label: 'No Category', bg: '#319177'},
  {index: 1, key: 'meats-seafood', label: 'Meat & Seafood', bg: '#8B0000'},
  {index: 2, key: 'dairy', label: 'Dairy & Eggs', bg: '#FFB300'},
  {index: 3, key: 'produce', label: 'Produce', bg: '#2E8B57'},
  {index: 4, key: 'frozen', label: 'Frozen Goods', bg: '#4682B4'},
  {index: 5, key: 'baked', label: 'Baked Goods', bg: '#C5A27D'},
  {index: 6, key: 'dry-pasta', label: 'Dry Goods & Pasta', bg: '#C5A27D'},
  {index: 7, key: 'condiments', label: 'Condiments & Sauces', bg: '#A0522D'},
  {index: 8, key: 'canned', label: 'Canned Goods', bg: '#708090'},
  {index: 9, key: 'spices', label: 'Oils, Vinegars & Spices', bg: '#DAA520'},
  {index: 10, key: 'baking', label: 'Baking Ingredients', bg: '#C5A27D'},
  {index: 11, key: 'cereals', label: 'Breakfast & Cereal', bg: '#CD853F'},
  {index: 12, key: 'snacks', label: 'Snacks & Candy', bg: '#FF6347'},
  {index: 13, key: 'beverages', label: 'Beverages', bg: '#4682B4'},
  {index: 14, key: 'other', label: 'Other', bg: '#319177'},
  {index: 99, key: 'custom', label: 'Custom', bg: '#319177'},
];

export const formatCategories = category => {
  const found = displayCategories.find(cat => cat.key === category);

  if (category === undefined || category === null) {
  } else if (found) {
    return found.label;
  } else {
    return category
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }
};

export const categoryColors = category => {
  const found = displayCategories.find(cat => cat.key === category);

  if (category === undefined || category === null) {
    return '#319177';
  } else if (found) {
    return found.bg;
  } else {
    return '#319177';
  }
};

-----

// deviceUtils.js
export const hbDevices = [
  'iPhone SE',
  'iPad Air 3rd Gen (WiFi)',
  'iPad Air 3rd Gen (Cellular)',
  // Add other home-button models here as needed
];

export const isHBDevice = model => hbDevices.includes(model);

export const isAndroidPhone = device =>
  device?.system?.os === 'Android' && device?.system?.device === 'Handset';

export const isAndroidTablet = device =>
  device?.system?.os === 'Android' && device?.system?.device === 'Tablet';

export const isiOSPhone = device =>
  device?.system?.os === 'iOS' && device?.system?.device === 'Handset';

export const isiOSTablet = device =>
  device?.system?.os === 'iOS' && device?.system?.device === 'Tablet';

export const getNavMenuHeight = device => {
  const {deviceSize, model, os} = device?.system || {};
  const isHomeButton = isHBDevice(model);

  let baseHeight = 90; // Fallback for unknown devices (just to be safe)

  switch (deviceSize) {
    case 'xLarge':
      baseHeight = 100;
      break;
    case 'large':
      baseHeight = 100;
      break;
    case 'medium':
      baseHeight = 100;
      break;
    case 'small':
      baseHeight = 100;
      break;
    case 'xSmall':
      baseHeight = 100;
      break;
    default:
      baseHeight = 90; // Unknown devices default to xSmall
      break;
  }

  // Special adjustment for iOS devices
  if (os === 'iOS') {
    baseHeight -= 5;
  }

  // Special adjustment for home button devices
  if (isHomeButton) {
    baseHeight -= 30;
  }

  return baseHeight;
};

export const getNavBarHeight = (device, baseHeight) => {
  if (isHBDevice(device?.system?.model)) {
    return baseHeight;
  } else {
    return baseHeight - 20;
  }
};

-----

//* measurements.js

export const displayMeasurements = [
  {index: 0, key: 'each', label: 'Single'},
  {index: 1, key: 'slice', label: 'Slice'},
  {index: 2, key: 'bag', label: 'Bag'},
  {index: 3, key: 'roll', label: 'Roll'},
  {index: 4, key: 'tube', label: 'Tube'},
  {index: 5, key: 'package', label: 'Package'},
  {index: 6, key: 'box', label: 'Box'},
  {index: 7, key: 'fluidounce', label: 'Fluid Ounce'},
  {index: 8, key: 'milliliter', label: 'Milliliter'},
  {index: 9, key: 'liter', label: 'Liter'},
  {index: 10, key: 'pint', label: 'Pint'},
  {index: 11, key: 'quart', label: 'Quart'},
  {index: 12, key: 'gallon', label: 'Gallon'},
  {index: 13, key: 'ounce', label: 'Ounce'},
  {index: 14, key: 'pound', label: 'Pound'},
  {index: 15, key: 'gram', label: 'Gram'},
  {index: 16, key: 'kilogram', label: 'Kilogram'},
  {index: 17, key: 'can', label: 'Can'},
  {index: 18, key: 'cup', label: 'Cup'},
  {index: 19, key: 'tablespoon', label: 'Tablespoon'},
  {index: 20, key: 'teaspoon', label: 'Teaspoon'},
  {index: 21, key: 'custom', label: 'Custom (Enter Your Own)'},
];

export const formatMeasurement = measurement => {
  const found = displayMeasurements.find(meas => meas.key === measurement);
  if (measurement === undefined || measurement === null) {
    // do nothing
  } else if (found) {
    return found.label;
  } else {
    return measurement
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }
};

-----

//* nutrients.js

export const displayNutrients = [
  {index: 0, key: 'CA', label: 'Calcium', unit: 'mg'},
  {index: 1, key: 'CHOCDF', label: 'Total Carbohydrates', unit: 'g'},
  {index: 2, key: 'CHOCDF.net', label: 'Net Carbohydrates', unit: 'g'},
  {index: 3, key: 'CHOLE', label: 'Cholesterol', unit: 'mg'},
  {index: 4, key: 'ENERC_KCAL', label: 'Calories', unit: 'kcal'},
  {index: 5, key: 'FAMS', label: 'Monounsaturated Fat', unit: 'g'},
  {index: 6, key: 'FAPU', label: 'Polyunsaturated Fat', unit: 'g'},
  {index: 7, key: 'FASAT', label: 'Saturated Fat', unit: 'g'},
  {index: 8, key: 'FATRN', label: 'Trans Fat', unit: 'g'},
  {index: 9, key: 'FAT', label: 'Total Fat', unit: 'g'},
  {index: 10, key: 'FE', label: 'Iron', unit: 'mg'},
  {index: 11, key: 'FIBTG', label: 'Dietary Fiber', unit: 'g'},
  {index: 12, key: 'FOLAC', label: 'Folic Acid', unit: 'Âµg'},
  {index: 13, key: 'FOLDFE', label: 'Folate (DFE)', unit: 'Âµg'},
  {index: 14, key: 'FOLFD', label: 'Folate (Food)', unit: 'Âµg'},
  {index: 15, key: 'K', label: 'Potassium', unit: 'mg'},
  {index: 16, key: 'MG', label: 'Magnesium', unit: 'mg'},
  {index: 17, key: 'NA', label: 'Sodium', unit: 'mg'},
  {index: 18, key: 'NIA', label: 'Niacin', unit: 'mg'},
  {index: 19, key: 'P', label: 'Phosphorus', unit: 'mg'},
  {index: 20, key: 'PROCNT', label: 'Protein', unit: 'g'},
  {index: 21, key: 'RIBF', label: 'Riboflavin', unit: 'mg'},
  {index: 22, key: 'SUGAR', label: 'Total Sugars', unit: 'g'},
  {index: 23, key: 'SUGAR.added', label: 'Added Sugars', unit: 'g'},
  {index: 24, key: 'Sugar.alcohol', label: 'Sugar Alcohols', unit: 'g'},
  {index: 25, key: 'THIA', label: 'Thiamin', unit: 'mg'},
  {index: 26, key: 'TOCPHA', label: 'Vitamin E', unit: 'mg'},
  {index: 27, key: 'VITA_RAE', label: 'Vitamin A', unit: 'Âµg'},
  {index: 28, key: 'VITB12', label: 'Vitamin B12', unit: 'Âµg'},
  {index: 29, key: 'VITB6A', label: 'Vitamin B6', unit: 'mg'},
  {index: 30, key: 'VITC', label: 'Vitamin C', unit: 'mg'},
  {index: 31, key: 'VITD', label: 'Vitamin D', unit: 'Âµg'},
  {index: 32, key: 'VITK1', label: 'Vitamin K', unit: 'Âµg'},
  {index: 33, key: 'WATER', label: 'Water', unit: 'g'},
  {index: 34, key: 'ZN', label: 'Zinc', unit: 'mg'},
];

export const formatNutrient = nutrient => {
  const found = displayNutrients.find(n => n.key === nutrient);
  if (found) {
    return {label: found.label, unit: found.unit};
  }
  return {label: nutrient, unit: ''}; // Default if not found
};

-----

//* Main.jsx

import {NavigationContainer} from '@react-navigation/native';
import React, {useCallback, useEffect, useMemo, useState} from 'react';
import {Dimensions, View} from 'react-native';
import {SafeAreaView} from 'react-native-safe-area-context';
import {createNativeStackNavigator} from '@react-navigation/native-stack';
import NavMenu from './src/components/NavMenu';
import {useDispatch} from 'react-redux';
import {getNavMenuHeight} from './src/utilities/deviceUtils';
import Home from './src/screens/Home/Home';
import {useAuth, useDeviceInfo, useProfile} from './src/hooks/useHooks';
import {setHapticFeedback} from './src/hooks/setHapticFeedback';
import Account from './src/screens/Account/Account';
import Cupboards from './src/screens/Cupboard/Cupboard';
import Shopping from './src/screens/Shopping/Shopping';
import CenterMenu from './src/screens/CenterMenu/CenterMenu';
import {BottomSheet, Text} from './src/KQ-UI';
import DevInputs from './src/screens/Dev/DevInputs';
import DevButtons from './src/screens/Dev/DevButtons';
import DevModals from './src/screens/Dev/DevModals';
import DevDropdowns from './src/screens/Dev/DevDropdowns';
import DevPlayground from './src/screens/Dev/DevPlayground';
import DevText from './src/screens/Dev/DevText';
import {getAuth} from '@react-native-firebase/auth';
import {getApp} from '@react-native-firebase/app';
import Auth from './src/screens/Auth/Auth';
import {
  RTAccounts,
  RTProfiles,
  RTShopping,
  RTCupboards,
  RTUsers,
  RTAllowedProfiles,
} from './src/utilities/realtime';

const Main = () => {
  const dispatch = useDispatch();
  const device = useDeviceInfo();
  const profile = useProfile();
  const useHaptics = setHapticFeedback();
  const Stack = createNativeStackNavigator();
  const isAuthenticated = useAuth();
  const [headerColor, setHeaderColor] = useState('black');
  const [screenLocation, setScreenLocation] = useState('');
  const [bgColor, setBgColor] = useState('#ffffff');
  const [textColor, setTextColor] = useState('#373d43');
  const [isSheetOpen, setIsSheetOpen] = useState(false);
  const bottomHeight = getNavMenuHeight(device);

  RTUsers();
  RTAccounts();
  RTProfiles();
  RTShopping();
  RTCupboards();
  RTAllowedProfiles();

  useEffect(() => {
    try {
      const auth = getAuth(getApp());
      const user = auth.currentUser;

      if (user) {
        dispatch({type: 'SET_USER', payload: user});
      } else {
        dispatch({type: 'LOGOUT'});
      }
    } catch (e) {
      console.log('[Main] Firebase not ready yet:', e.message);
      dispatch({type: 'LOGOUT'});
    }
  }, []);

  const borrowedParams = useMemo(
    () => ({bgColor, textColor, screenLocation}),
    [bgColor, textColor, screenLocation],
  );

  useEffect(() => {
    dispatch({type: 'FETCH_DEVICE_INFO'});

    const subscription = Dimensions.addEventListener('change', () => {
      dispatch({type: 'FETCH_DEVICE_INFO'});
    });

    return () => subscription?.remove();
  }, [dispatch]);

  const toggleMenu = useCallback(() => {
    setIsSheetOpen(prev => !prev);
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
  }, [useHaptics]);

  const BottomMenu = () => (
    <BottomSheet
      visible={isSheetOpen}
      onClose={() => setIsSheetOpen(false)}
      snapPoints={[0.01, 0.95]}>
      <CenterMenu borrowedParams={borrowedParams} toggleMenu={toggleMenu} />
    </BottomSheet>
  );

  const Navigation = () => {
    return (
      <>
        <Stack.Navigator
          screenOptions={{
            animation: 'none',
            gestureEnabled: false,
            headerBackVisible: false,
            headerShown: false,
            navigationBarColor: '#f7f7f7',
          }}>
          <Stack.Screen
            name="Home"
            component={Home}
            initialParams={{
              title: 'Home',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('Home');
              },
            }}
          />
          <Stack.Screen
            name="ShoppingList"
            component={Shopping}
            initialParams={{
              title: 'Shopping List',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('ShoppingList');
              },
            }}
          />
          <Stack.Screen
            name="CupboardList"
            component={Cupboards}
            initialParams={{
              title: 'Cupboards',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('CupboardList');
              },
            }}
          />
          <Stack.Screen
            name="Account"
            component={Account}
            initialParams={{
              title: 'Account',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('Account');
              },
            }}
          />

          {__DEV__ && (
            <>
              <Stack.Screen
                name="DevPlayground"
                component={DevPlayground}
                initialParams={{
                  title: 'Dev Playground',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevPlayground');
                  },
                }}
              />
              <Stack.Screen
                name="DevText"
                component={DevText}
                initialParams={{
                  title: 'Dev Text',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevText');
                  },
                }}
              />
              <Stack.Screen
                name="DevInputs"
                component={DevInputs}
                initialParams={{
                  title: 'Dev Inputs',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevInputs');
                  },
                }}
              />
              <Stack.Screen
                name="DevButtons"
                component={DevButtons}
                initialParams={{
                  title: 'Dev Buttons',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevButtons');
                  },
                }}
              />
              <Stack.Screen
                name="DevModals"
                component={DevModals}
                initialParams={{
                  title: 'Dev Modals',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevModals');
                  },
                }}
              />
              <Stack.Screen
                name="DevDropdowns"
                component={DevDropdowns}
                initialParams={{
                  title: 'Dev Dropdowns',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevDropdowns');
                  },
                }}
              />
            </>
          )}
          <Stack.Screen name="Login" component={Auth} />
        </Stack.Navigator>
      </>
    );
  };

  if (!isAuthenticated) {
    return (
      <SafeAreaView style={{flex: 1, margin: 5}}>
        <Auth bgColor={bgColor} />
      </SafeAreaView>
    );
  } else {
    return (
      <NavigationContainer>
        <SafeAreaView
          style={{flex: 1, backgroundColor: headerColor}}
          edges={['top']}>
          <View style={{flex: 1}}>
            <Navigation />
            <BottomMenu toggleMenu={toggleMenu} />
          </View>
        </SafeAreaView>
        <SafeAreaView style={{height: bottomHeight}} edges={['bottom']}>
          <NavMenu
            bottomHeight={bottomHeight}
            bottomWidth={device?.dimensions?.width}
            toggleMenu={toggleMenu}
            setIsSheetOpen={setIsSheetOpen}
            device={device}
          />
        </SafeAreaView>
      </NavigationContainer>
    );
  }
};

export default Main;

-----

//*App.jsx
import React, {useEffect, useState} from 'react';
import {Provider} from 'react-redux';
import {store, persistor} from './store';
import {PersistGate} from 'redux-persist/integration/react';
import {GestureHandlerRootView} from 'react-native-gesture-handler';
import {
  StatusBar,
  View,
  Text,
  TextInput,
  PixelRatio,
  Platform,
  AccessibilityInfo,
} from 'react-native';
import SplashScreen from './src/components/SplashScreen';
import Toast from 'react-native-toast-message';
import {toastConfig} from './src/KQ-UI/KQToast';
import Main from './Main';
import {initializeApp, getApps} from '@react-native-firebase/app';
import {SafeAreaProvider} from 'react-native-safe-area-context';

const App = () => {
  const [appReady, setAppReady] = useState(false);

  useEffect(() => {
    if (!getApps().length) {
      initializeApp();
    }

    // Wait until app is ready
    if (getApps().length) {
      setAppReady(true);
    }
  }, []);

  const [isSplashVisible, setSplashVisible] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => setSplashVisible(false), 3000);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    if (Text.defaultProps == null) Text.defaultProps = {};
    if (TextInput.defaultProps == null) TextInput.defaultProps = {};

    Text.defaultProps.allowFontScaling = false;
    TextInput.defaultProps.allowFontScaling = false;

    if (Platform.OS === 'android') {
      PixelRatio.get = () => 1;
      PixelRatio.getFontScale = () => 1;
    }

    AccessibilityInfo.addEventListener('reduceMotionChanged', reduceMotion => {
      if (reduceMotion) {
        PixelRatio.get = () => 1;
        PixelRatio.getFontScale = () => 1;
      }
    });
  }, []);

  if (!appReady || isSplashVisible) {
    return (
      <>
        <SplashScreen />
        <StatusBar barStyle="light-content" />
      </>
    );
  }

  return (
    <Provider store={store}>
      <PersistGate loading={<SplashScreen />} persistor={persistor}>
        <GestureHandlerRootView style={{flex: 1}}>
          <SafeAreaProvider>
            <View style={{flex: 1, backgroundColor: '#fff'}}>
              <StatusBar barStyle="light-content" />
              <Main />
              <Toast config={toastConfig} />
            </View>
          </SafeAreaProvider>
        </GestureHandlerRootView>
      </PersistGate>
    </Provider>
  );
};

export default App;

-----

//*CenterMenu.jsx
import React, {useCallback, useReducer} from 'react';
import {Alert, ScrollView, TouchableOpacity, View} from 'react-native';
import {useNavigation} from '@react-navigation/native';
import {useDispatch} from 'react-redux';
import {useProfile, useShoppingCart} from '../../hooks/useHooks';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';
import {menuArray} from './CenterMenuArray';
import {Icons} from '../../components/IconListRouter';
import {CMStyles} from '../../styles/Styles';
import {Text} from '../../KQ-UI';

function CenterMenu(props) {
  const {toggleMenu} = props;
  const navigation = useNavigation();
  const useHaptics = setHapticFeedback();
  const dispatch = useDispatch();
  const profile = useProfile();
  const shopping = useShoppingCart();
  const cartList =
    shopping?.items?.filter(item => item.status === 'shopping-cart') ?? [];

  const handleOnPress = useCallback(
    navigate => {
      if (navigate === 'console') return;
      if (navigate === 'Logout') {
        handleSignOut();
        return;
      }
      useHaptics(profile?.userSettings?.hapticStrength || 'light');
      toggleMenu();
      navigation.navigate(navigate);
    },
    [profile?.userSettings?.hapticStrength, toggleMenu, navigation],
  );

  const handleSignOut = useCallback(() => {
    Alert.alert('Logging Out', 'Are you sure you want to logout?', [
      {text: 'Cancel', style: 'destructive'},
      {
        text: 'Confirm',
        onPress: () => {
          useHaptics(profile?.userSettings?.hapticStrength || 'light');
          dispatch({type: 'LOGOUT'});
        },
      },
    ]);
  }, [profile?.userSettings?.hapticStrength, dispatch]);

  const sectionReducer = (state, action) => {
    return {...state, [action]: !state[action]};
  };

  const initialState = menuArray.reduce((acc, section) => {
    acc[section.section] = section.defaultOpen;
    return acc;
  }, {});

  const [sectionStates, dispatchSection] = useReducer(
    sectionReducer,
    initialState,
  );

  const toggleSection = useCallback(
    sectionName => dispatchSection(sectionName),
    [dispatchSection],
  );

  const SectionHeader = React.memo(({title, state, onPress}) => {
    return (
      <View style={CMStyles.shContainer}>
        <View style={CMStyles.shLine}></View>
        <View style={{flex: 1, zIndex: 2}}>
          <View style={[CMStyles.shTWrap, {flex: 1}]}>
            <TouchableOpacity style={CMStyles.shTO} onPress={onPress}>
              {state ? <Icons.ChevronUp /> : <Icons.ChevronDown />}
            </TouchableOpacity>
          </View>
        </View>

        <View style={CMStyles.shTitleWrap}>
          <View style={CMStyles.shTitle}>
            <Text>{title}</Text>
          </View>
        </View>
      </View>
    );
  });

  const Section = React.memo(({title, state, onPress, data}) => {
    return (
      <>
        <SectionHeader title={title} state={state} onPress={onPress} />
        {state ? (
          <View style={CMStyles.sectionExpanded}>
            {data.map((item, index) =>
              item.action === 'InCart' && cartList.length === 0 ? null : (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleOnPress(item.action)}
                  style={CMStyles.sectionTO}>
                  <View style={CMStyles.sectionIcon}>{item.icon}</View>
                  <Text>{item.title}</Text>
                </TouchableOpacity>
              ),
            )}
          </View>
        ) : (
          <View style={CMStyles.sectionCollapsed}>
            <Text size="xSmall">(Hidden: Expand to View)</Text>
          </View>
        )}
      </>
    );
  });

  return (
    <ScrollView style={{backgroundColor: '#fff'}}>
      {menuArray.map((section, index) => (
        <Section
          key={index}
          title={section.section}
          state={sectionStates[section.section]}
          onPress={() => toggleSection(section.section)}
          data={section.items}
        />
      ))}
    </ScrollView>
  );
}

export default CenterMenu;

-----

//* CenterMenuArray.jsx
import {Icons} from '../../components/IconListRouter';

export const menuArray = [
  {
    section: 'Shopping',
    defaultOpen: true,
    items: [
      // future feature
      // {
      //   title: 'Scan to',
      //   icon: <Icons.Barcode />,
      //   action: 'console',
      // },
      {
        title: 'Add to',
        icon: <Icons.AddList />,
        action: 'AddShopItems',
      },
      {
        title: 'View List',
        icon: <Icons.MenuList />,
        action: 'ShoppingList',
      },
      {
        title: 'View Cart',
        icon: <Icons.Shopping />,
        action: 'InCart',
      },
    ],
  },
  {
    section: 'Cupboard',
    defaultOpen: true,
    items: [
      // future feature
      // {
      //   title: 'Scan to',
      //   icon: <Icons.Barcode />,
      //   action: 'console',
      // },
      {
        title: 'Add to',
        icon: <Icons.AddList />,
        action: 'AddCupboardItems',
      },
      {
        title: 'View List',
        icon: <Icons.Cupboards />,
        action: 'CupboardList',
      },
    ],
  },
  // future feature
  // {
  //   section: 'Recipe',
  //   defaultOpen: false,
  //   items: [
  //     {
  //       title: 'Search',
  //       icon: <Icons.Search />,
  //       action: 'console',
  //     },
  //     {
  //       title: 'Add to',
  //       icon: <Icons.AddList />,
  //       action: 'console',
  //     },
  //     {
  //       title: 'View List',
  //       icon: <Icons.Recipe />,
  //       action: 'console',
  //     },
  //   ],
  // },

  // future feature
  // {
  //   section: 'Favorites',
  //   defaultOpen: false,
  //   items: [
  //     {
  //       title: 'Add to',
  //       icon: <Icons.AddList />,
  //       action: 'console',
  //     },
  //     {
  //       title: 'View List',
  //       icon: <Icons.Favorite />,
  //       action: 'console',
  //     },
  //   ],
  // },
  {
    section: 'Misc',
    defaultOpen: true,
    items: [
      {
        title: 'View Account',
        icon: <Icons.Account />,
        action: 'Account',
      },
      {
        title: 'View Profile',
        icon: <Icons.Profile />,
        action: 'AccountProfile',
      },
      {
        title: 'View Settings',
        icon: <Icons.Settings />,
        action: 'AccountSettings',
      },
      {
        title: 'Get Help',
        icon: <Icons.Help />,
        action: 'AccountHelp',
      },
      {
        title: 'LogOut',
        icon: <Icons.Logout />,
        action: 'Logout',
      },
    ],
  },
  __DEV__
    ? {
        section: '(Development)',
        defaultOpen: true,
        items: [
          {
            title: 'Dev Playground',
            icon: <Icons.Dev />,
            action: 'DevPlayground',
          },
          {
            title: 'Text',
            icon: <Icons.Dev />,
            action: 'DevText',
          },
          {
            title: 'Inputs',
            icon: <Icons.Dev />,
            action: 'DevInputs',
          },
          {
            title: 'Buttons',
            icon: <Icons.Dev />,
            action: 'DevButtons',
          },
          {
            title: 'Modals',
            icon: <Icons.Dev />,
            action: 'DevModals',
          },
          {
            title: 'Dropdowns',
            icon: <Icons.Dev />,
            action: 'DevDropdowns',
          },
        ],
      }
    : null,
].filter(Boolean);

-----

//* DevButtons.jsx
import React from 'react';
import {Button, Layout} from '../../KQ-UI';
import {useRoute} from '@react-navigation/native';
import {View} from 'react-native';

const DevButtons = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{
        justifyContent: 'center',
        alignItems: 'center',
      }}>
      <Button
        type="filled" //useButtonType
        size="small" //useButtonSizes
        color="primary" //useColors or allow custom like "white" or "#fff"
        textSize="medium" //useFonts
        fontType="open-6" //useFonts
        textColor="white" //or useColors or allow custom like "white" or "#fff"
        disabled={false} //true or false, default is false and the prop is optional
        onPress={() => {
          console.log('button pressed');
        }}>
        Press Me
      </Button>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Primary"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Primary"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Primary"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Success"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Success"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Success"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Info"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Info"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Info"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Warning"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Warning"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Warning"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Danger"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Danger"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Danger"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Dark"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Dark"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Dark"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            disabled
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            disabled
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            disabled
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
      </View>
    </Layout>
  );
};

export default DevButtons;

-----

//* DevDropdowns.jsx
import React, {useState} from 'react';
import {View} from 'react-native';
import {Dropdown, Input, Layout, Text} from '../../KQ-UI';
import {useRoute} from '@react-navigation/native';
import {displayCategories} from '../../utilities/categories';
import {displayMeasurements} from '../../utilities/measurements';

const DevDropdowns = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  const [value, setValue] = useState(null);
  console.log('value:', value);
  const [value2, setValue2] = useState('');

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}>
      <Input
        label="Item Name"
        placeholder="Enter Item Name"
        value={value2}
        onChangeText={setValue2}
        capitalize={false}
        capitalMode="words"
        caption="Enter Item"
      />
      <Dropdown
        label="Category"
        placeholder="Press to Select"
        value={value}
        setValue={setValue}
        caption="Select a Category"
        mapData={displayMeasurements}
      />
    </Layout>
  );
};

export default DevDropdowns;

-----

//* DevInputs.jsx
import React, {useState} from 'react';
import {useRoute} from '@react-navigation/native';
import {Layout, Input} from '../../KQ-UI';
import {TouchableWithoutFeedback} from 'react-native';
import {Icons} from '../../components/IconListRouter';

const DevInputs = ({}) => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  const [value, setValue] = useState('');
  const [value1, setValue1] = useState('');
  const [value2, setValue2] = useState('');
  const [value3, setValue3] = useState('');
  const [secureTextEntry, setSecureTextEntry] = useState(true);

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  const renderIcon = () => (
    <TouchableWithoutFeedback onPress={toggleSecureEntry}>
      {secureTextEntry ? <Icons.EyeOff /> : <Icons.EyeOn />}
    </TouchableWithoutFeedback>
  );

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      useKeyboardHandling={true}>
      <Input
        label="Email"
        placeholder="Email"
        value={value}
        onChangeText={setValue}
        capitalize={false}
        capitalMode="words"
        caption="Enter your email address"
        // keyboardType="default"
        // keyboardType="number-pad" // ios, has no decimal point
        // keyboardType="decimal-pad"
        // keyboardType="numeric" // ios, shows letters on number pad
        // keyboardType="email-address"
        // keyboardType="phone-pad" // same as numeric
        // keyboardType="url"
      />
      <Input
        label="Password"
        placeholder="Password"
        value={value1}
        onChangeText={setValue1}
        capitalize={false}
        accessoryRight={renderIcon}
        secureTextEntry={secureTextEntry}
        required
        caption="Password must be at least 8 characters long"
        counter
        maxCount={500}
      />
      <Input
        label="Multiple Lines"
        placeholder="Enter text here"
        value={value2}
        onChangeText={setValue2}
        multiline
        // multiHeight="medium"
        required
        caption="Enter a message"
        counter
        maxCount={150}
      />
      <Input
        label="Notes"
        placeholder="Type multiple lines..."
        value={value3}
        onChangeText={setValue3}
        multiline
        multiHeight="large"
        caption="Enter notes"
        counter
        maxCount={250}
      />
    </Layout>
  );
};

export default DevInputs;

-----

//* DevModals.jsx
import React, {useState} from 'react';
import {useRoute} from '@react-navigation/native';
import {View} from 'react-native';
import {Button, Layout, Modal, Text} from '../../KQ-UI';

const DevModals = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  const [showModal, setShowModal] = useState(false);
  const [showModal2, setShowModal2] = useState(false);
  const [showModal3, setShowModal3] = useState(false);
  const [showModal4, setShowModal4] = useState(false);

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Modal
        visible={showModal}
        header="Full Screen"
        headerFont="open-6"
        headerSize="small"
        headerColor="white"
        height="95%"
        width="95%"
        fullScreen
        // hideHeader
        // hideTitle
        // hideClose
        onClose={() => setShowModal(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>Full Screen w/ Header</Text>
          <Button onPress={() => setShowModal(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal2}
        header="Full Screen"
        headerFont="open-6"
        headerSize="small"
        headerColor="white"
        height="95%"
        width="95%"
        fullScreen
        hideHeader
        // hideTitle
        // hideClose
        onClose={() => setShowModal2(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>Full Screen w/o Header</Text>
          <Button onPress={() => setShowModal2(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal3}
        header="Modal Title"
        headerFont="open-6"
        headerSize="small"
        headerColor="white"
        height="95%"
        width="95%"
        // fullScreen
        // hideHeader
        hideTitle
        // hideClose
        onClose={() => setShowModal3(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>95% Screen w/o Title</Text>
          <Button onPress={() => setShowModal3(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal4}
        header="Modal Title"
        headerFont="open-6"
        headerSize="small"
        headerColor="white"
        height="85%"
        width="85%"
        // fullScreen
        // hideHeader
        // hideTitle
        hideClose
        onClose={() => setShowModal4(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>85% Screen w/o Close Button</Text>
          <Button onPress={() => setShowModal4(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Button onPress={() => setShowModal(true)}>Show F/S w/ Header</Button>
      <Button onPress={() => setShowModal2(true)}>Show F/S w/o Header</Button>
      <Button onPress={() => setShowModal3(true)}>
        Show 95% Modal w/o Title
      </Button>
      <Button onPress={() => setShowModal4(true)}>
        Show 85% Modal w/o Close
      </Button>
    </Layout>
  );
};

export default React.memo(DevModals);

-----

//* Account.jsx
import React, {use, useEffect} from 'react';
import {useIsFocused, useRoute} from '@react-navigation/native';
import {Layout, ScrollView, Text} from '../../KQ-UI';
import {
  useAccount,
  useCupboard,
  useProfile,
  useShoppingCart,
} from '../../hooks/useHooks';
import {View} from 'react-native';

const DevPlayground = () => {
  const isFocused = useIsFocused();
  const route = useRoute();
  const profile = useProfile();
  const account = useAccount();
  const shopping = useShoppingCart();
  const cupboard = useCupboard();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  useEffect(() => {
    if (isFocused) {
      console.log('profile', profile);
      console.log('account', account);
      console.log('shopping', shopping);
      console.log('cupboard', cupboard);
    }
  }, [isFocused, profile, account, shopping, cupboard]);

  const renderValue = value => {
    if (Array.isArray(value)) {
      return value.map((item, idx) => {
        if (typeof item === 'object' && item !== null) {
          return (
            <View key={idx} style={{marginLeft: 8, marginBottom: 12}}>
              <Text font="open-6" style={{marginBottom: 4}}>
                {idx}:
              </Text>
              {Object.entries(item)
                .sort(([a, b]) => a.localeCompare(b))
                .map(([k, v], subIdx) => (
                  <Text key={subIdx} font="open-5" style={{marginLeft: 16}}>
                    â€¢ {k}:{' '}
                    {typeof v === 'object' ? JSON.stringify(v) : String(v)}
                  </Text>
                ))}
            </View>
          );
        }

        return (
          <Text
            key={idx}
            font="open-5"
            style={{marginLeft: 16, marginBottom: 8}}>
            {idx}: {String(item)}
          </Text>
        );
      });
    }

    if (typeof value === 'object' && value !== null) {
      return Object.entries(value)
        .sort(([a, b]) => a.localeCompare(b))
        .map(([k, v], idx) => (
          <Text
            key={idx}
            font="open-5"
            style={{marginLeft: 16, marginBottom: 4}}>
            â€¢ {k}: {typeof v === 'object' ? JSON.stringify(v) : String(v)}
          </Text>
        ));
    }

    return (
      <Text font="open-5" style={{marginLeft: 16}}>
        {String(value)}
      </Text>
    );
  };

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{}}>
      <ScrollView>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Profile</Text>
          {Object.entries(profile)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7">{key}:</Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Account</Text>
          {Object.entries(account)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7">{key}:</Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Shopping</Text>
          {Object.entries(shopping)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7">{key}:</Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Cupboard</Text>
          {Object.entries(cupboard)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7">{key}:</Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
      </ScrollView>
    </Layout>
  );
};

export default DevPlayground;

-----

//* DevText.jsx
import React from 'react';
import {useRoute} from '@react-navigation/native';
import {Platform, View} from 'react-native';
import {Layout, Text} from '../../KQ-UI';

const DevText = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  const Row = ({children}) => (
    <View style={{flexDirection: 'row', width: '90%'}}>{children}</View>
  );

  const Cell = ({children}) => (
    <View
      style={{
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        borderWidth: 0.2,
        borderColor: '#00000090',
        margin: 5,
        height: 40,
      }}>
      {children}
    </View>
  );

  const TextBefore = ({font, text, weight, size, ...props}) => (
    <Text
      kqColor="black"
      style={{fontFamily: font, fontWeight: weight, fontSize: size || 20}}
      {...props}>
      {text}
    </Text>
  );

  const TextAfter = ({font, text, size, ...props}) => (
    <Text kqColor="black" font={font} style={{fontSize: size || 20}} {...props}>
      {text}
    </Text>
  );

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Light" weight={300} text="Noto 300" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-3" text="Noto 300" style={{color: 'purple'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Medium" weight={500} text="Noto 500" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-5" text="Noto 500" kqColor="primary" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Bold" weight={700} text="Noto 700" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-7" text="Noto 700" kqColor="success" />
        </Cell>
      </Row>

      <Row>
        <Cell>
          <TextBefore font="Montserrat-Light" weight={200} text="Mont 300" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-3" text="Mont 300" style={{color: 'blue'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="Montserrat-Medium" weight={500} text="Mont 500" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-5" text="Mont 500" kqColor="info" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="Montserrat-Bold" weight={700} text="Mont 700" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-7" text="Mont 700" kqColor="warning" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Light" weight={300} text="Open 300" />
        </Cell>
        <Cell>
          <TextAfter font="open-3" text="Open 300" style={{color: 'aqua'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Medium" weight={500} text="Open 500" />
        </Cell>
        <Cell>
          <TextAfter font="open-5" text="Open 500" kqColor="danger" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Bold" weight={700} text="Open 700" />
        </Cell>
        <Cell>
          <TextAfter font="open-7" text="Open 700" kqColor="dark" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore
            font={Platform.OS === 'ios' ? 'CherryBlossom' : 'Cherry-Blossom'}
            weight={500}
            size={22}
            text="Cherry Blossom"
          />
        </Cell>
        <Cell>
          <TextAfter
            font="cherry"
            text="Cherry Blossom"
            size={22}
            kqColor="basic"
          />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore
            font="BananaChips-Regular"
            text="Banana Chips"
            size={40}
            weight={500}
          />
        </Cell>
        <Cell>
          <TextAfter
            font="banana"
            text="Banana Chips"
            size={40}
            style={{color: 'gold'}}
          />
        </Cell>
      </Row>
      <Text font="open-6" size="large">
        The quick brown lazy dog.
      </Text>
    </Layout>
  );
};

export default DevText;

-----

