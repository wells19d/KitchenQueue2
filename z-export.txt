

--- FILE: App.jsx ---

//*App.jsx
import React, {useEffect, useState} from 'react';
import {Provider} from 'react-redux';
import {store, persistor} from './store';
import {PersistGate} from 'redux-persist/integration/react';
import {GestureHandlerRootView} from 'react-native-gesture-handler';
import {
  StatusBar,
  View,
  Text,
  TextInput,
  PixelRatio,
  Platform,
  AccessibilityInfo,
} from 'react-native';
import SplashScreen from './src/components/SplashScreen';
import Toast from 'react-native-toast-message';
import toastConfig from './src/KQ-UI/KQToast';
import Main from './Main';
import {initializeApp, getApps} from '@react-native-firebase/app';
import {SafeAreaProvider} from 'react-native-safe-area-context';

const App = () => {
  const [appReady, setAppReady] = useState(false);

  useEffect(() => {
    if (!getApps().length) {
      initializeApp();
    }

    // Wait until app is ready
    if (getApps().length) {
      setAppReady(true);
    }
  }, []);

  const [isSplashVisible, setSplashVisible] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => setSplashVisible(false), 3000);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    if (Text.defaultProps == null) Text.defaultProps = {};
    if (TextInput.defaultProps == null) TextInput.defaultProps = {};

    Text.defaultProps.allowFontScaling = false;
    TextInput.defaultProps.allowFontScaling = false;

    if (Platform.OS === 'android') {
      PixelRatio.get = () => 1;
      PixelRatio.getFontScale = () => 1;
    }

    AccessibilityInfo.addEventListener('reduceMotionChanged', reduceMotion => {
      if (reduceMotion) {
        PixelRatio.get = () => 1;
        PixelRatio.getFontScale = () => 1;
      }
    });
  }, []);

  if (!appReady || isSplashVisible) {
    return (
      <>
        <SplashScreen />
        <StatusBar barStyle="light-content" />
      </>
    );
  }

  return (
    <Provider store={store}>
      <PersistGate loading={<SplashScreen />} persistor={persistor}>
        <GestureHandlerRootView style={{flex: 1}}>
          <SafeAreaProvider>
            <View style={{flex: 1, backgroundColor: '#fff'}}>
              <StatusBar barStyle="light-content" />
              <Main />
              <Toast config={toastConfig} />
            </View>
          </SafeAreaProvider>
        </GestureHandlerRootView>
      </PersistGate>
    </Provider>
  );
};

export default App;


--- FILE: AppInfo.js ---

//* AppInfo.js
export const AppInfo = {
  appName: 'Kitchen Queue',
  appVersion: '0.0.4',
  tosVersion: '1.0.2',
  ppVersion: '1.0.2',
};


--- FILE: Main.jsx ---

//* Main.jsx
import {NavigationContainer} from '@react-navigation/native';
import React, {useCallback, useEffect, useMemo, useState} from 'react';
import {Alert, Dimensions, View} from 'react-native';
import {SafeAreaView} from 'react-native-safe-area-context';
import {createNativeStackNavigator} from '@react-navigation/native-stack';
import NavMenu from './src/components/NavMenu';
import {useDispatch} from 'react-redux';
import {getNavMenuHeight} from './src/utilities/deviceUtils';
import Home from './src/screens/Home/Home';
import {useAuth, useDeviceInfo, useProfile} from './src/hooks/useHooks';
import {setHapticFeedback} from './src/hooks/setHapticFeedback';
import Account from './src/screens/Account/Account';
import CupboardSingle from './src/screens/Cupboard/CupboardSingle';
import ShoppingList from './src/screens/Shopping/ShoppingList';
import CenterMenu from './src/screens/CenterMenu/CenterMenu';
import {BottomSheet, Modal, Text} from './src/KQ-UI';
import DevInputs from './src/screens/Dev/DevInputs';
import DevButtons from './src/screens/Dev/DevButtons';
import DevDropdowns from './src/screens/Dev/DevDropdowns';
import DevPlayground from './src/screens/Dev/DevPlayground';
import DevModals from './src/screens/Dev/DevModals';
import DevText from './src/screens/Dev/DevText';
import {getAuth} from '@react-native-firebase/auth';
import {getApp} from '@react-native-firebase/app';
import Auth from './src/screens/Auth/Auth';
import {
  RTAccounts,
  RTProfiles,
  RTShopping,
  RTCupboards,
  RTUsers,
  RTAllowedProfiles,
} from './src/utilities/realtime';
import TermsService from './src/screens/Legal/TermsService';
import PrivacyPolicy from './src/screens/Legal/PrivacyPolicy';
import {AppInfo} from './AppInfo';
import {enableScreens} from 'react-native-screens';
import ShoppingCart from './src/screens/Shopping/ShoppingCart';
import CupboardGroup from './src/screens/Cupboard/CupboardGroup';
import ShoppingItems from './src/screens/Shopping/ShoppingItems';
import CupboardItems from './src/screens/Cupboard/CupboardItems';

const Main = () => {
  const dispatch = useDispatch();
  const device = useDeviceInfo();
  const profile = useProfile();
  const useHaptics = setHapticFeedback();
  const Stack = createNativeStackNavigator();
  const isAuthenticated = useAuth();
  const [headerColor, setHeaderColor] = useState('black');
  const [screenLocation, setScreenLocation] = useState('');
  const [bgColor, setBgColor] = useState('#ffffff');
  const [textColor, setTextColor] = useState('#373d43');
  const [isSheetOpen, setIsSheetOpen] = useState(false);
  const bottomHeight = getNavMenuHeight(device);

  const [showPPModal, setShowPPModal] = useState(false);
  const [showTOSModal, setShowTOSModal] = useState(true);
  const [currentModal, setCurrentModal] = useState('');
  enableScreens(true);

  RTUsers();
  RTAccounts();
  RTProfiles();
  RTShopping();
  RTCupboards();
  RTAllowedProfiles();

  useEffect(() => {
    try {
      const auth = getAuth(getApp());
      const user = auth.currentUser;

      if (user) {
        dispatch({type: 'SET_USER', payload: user});
      } else {
        dispatch({type: 'LOGOUT'});
      }
    } catch (e) {
      console.log('[Main] Firebase not ready yet:', e.message);
      dispatch({type: 'LOGOUT'});
    }
  }, []);

  const borrowedParams = useMemo(
    () => ({bgColor, textColor, headerColor, screenLocation}),
    [bgColor, textColor, headerColor, screenLocation],
  );

  useEffect(() => {
    if (isAuthenticated && profile) {
      if (!profile?.tosVersion || profile?.tosVersion !== AppInfo.tosVersion) {
        setCurrentModal('TOS');
        setShowTOSModal(true);
      } else if (
        !profile?.ppVersion ||
        profile?.ppVersion !== AppInfo.ppVersion
      ) {
        setCurrentModal('PP');
        setShowPPModal(true);
      }
    }
  }, [isAuthenticated, profile]);

  useEffect(() => {
    dispatch({type: 'FETCH_DEVICE_INFO'});

    const subscription = Dimensions.addEventListener('change', () => {
      dispatch({type: 'FETCH_DEVICE_INFO'});
    });

    return () => subscription?.remove();
  }, [dispatch]);

  const handlePPConfirm = () => {
    let updatedData = {
      ppVersion: AppInfo.ppVersion,
    };
    dispatch({
      type: 'UPDATE_PROFILE_REQUEST',
      payload: {userId: profile?.id, updatedData},
    });
    setShowPPModal(false);

    if (profile?.tosVersion !== AppInfo.tosVersion) {
      setCurrentModal('TOS');
      setShowTOSModal(true);
    }
  };

  const handleTOSConfirm = () => {
    let updatedData = {
      tosVersion: AppInfo.tosVersion,
    };
    dispatch({
      type: 'UPDATE_PROFILE_REQUEST',
      payload: {userId: profile?.id, updatedData},
    });
    setShowTOSModal(false);
    setCurrentModal('');
  };

  const handleCancel = type => {
    Alert.alert(
      `${type} Declined`,
      `Not accepting the ${type}, you will be logged out and prevented from using Kitchen Queue. Are you sure you want to decline?`,
      [
        {text: 'Back'},
        {
          text: 'Decline',
          style: 'destructive',
          onPress: () => {
            dispatch({type: 'LOGOUT'});
          },
        },
      ],
    );
  };

  const toggleMenu = useCallback(() => {
    setIsSheetOpen(prev => !prev);
    useHaptics(profile?.userSettings?.hapticStrength || 'light');
  }, [useHaptics]);

  const BottomMenu = () => (
    <BottomSheet
      visible={isSheetOpen}
      onClose={() => setIsSheetOpen(false)}
      snapPoints={[0.01, 0.95]}>
      <CenterMenu borrowedParams={borrowedParams} toggleMenu={toggleMenu} />
    </BottomSheet>
  );

  const Navigation = () => {
    return (
      <>
        <Stack.Navigator
          screenOptions={{
            animation: 'none',
            gestureEnabled: false,
            headerBackVisible: false,
            headerShown: false,
            navigationBarColor: '#f7f7f7',
          }}>
          <Stack.Screen
            name="Home"
            component={Home}
            options={{freezeOnBlur: true}}
            initialParams={{
              title: 'Home',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('Home');
              },
            }}
          />
          <Stack.Screen
            name="ShoppingList"
            component={ShoppingList}
            options={{freezeOnBlur: true}}
            initialParams={{
              title: 'Shopping List',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('ShoppingList');
              },
            }}
          />
          <Stack.Screen
            name="ShoppingCart"
            component={ShoppingCart}
            options={{freezeOnBlur: true}}
            initialParams={{
              title: 'Shopping Cart',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('ShoppingCart');
              },
            }}
          />
          <Stack.Screen
            name="ShoppingItems"
            component={ShoppingItems}
            options={{freezeOnBlur: true}}
            initialParams={{
              title: 'Items',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('ShoppingItems');
              },
            }}
          />
          <Stack.Screen
            name="CupboardList-Single"
            component={CupboardSingle}
            options={{freezeOnBlur: true}}
            initialParams={{
              title: 'Cupboards',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('CupboardList-Single');
              },
            }}
          />
          <Stack.Screen
            name="CupboardList-Group"
            component={CupboardGroup}
            options={{freezeOnBlur: true}}
            initialParams={{
              title: 'Cupboards',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('CupboardList-Group');
              },
            }}
          />
          <Stack.Screen
            name="CupboardItems"
            component={CupboardItems}
            options={{freezeOnBlur: true}}
            initialParams={{
              title: 'Items',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('CupboardItems');
              },
            }}
          />
          {/* <Stack.Screen
            name="RecipeList"
            component={Recipes}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Recipes',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('RecipeList');
              },
            }}
          /> */}
          <Stack.Screen
            name="Account"
            component={Account}
            options={{freezeOnBlur: true}}
            initialParams={{
              title: 'Account',
              bgColor: bgColor,
              headerColor: headerColor,
              textColor: textColor,
              screenLocation: screenLocation,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('Account');
              },
            }}
          />
          {/* <Stack.Screen
            name="AccountSettings"
            component={Settings}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Settings',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('AccountSettings');
              },
            }}
          /> */}
          {/* <Stack.Screen
            name="AccountHelp"
            component={Help}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Help',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('AccountHelp');
              },
            }}
          /> */}
          {/* <Stack.Screen
            name="Vibrations"
            component={Vibrations}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Vibration Settings',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('Vibrations');
              },
            }}
          /> */}
          {/* <Stack.Screen
            name="ItemDisplay"
            component={ItemDisplay}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Item Display',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('ItemDisplay');
              },
            }}
          /> */}
          {/* <Stack.Screen
            name="AdvancedFields"
            component={AdvancedFields}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Advanced Fields',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('AdvancedFields');
              },
            }}
          /> */}
          {/* <Stack.Screen
            name="DefaultView"
            component={DefaultGroupView}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Group View',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('DefaultView');
              },
            }}
          /> */}
          {/* <Stack.Screen
            name="Resets"
            component={Resets}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Resets',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('Resets');
              },
            }}
          /> */}
          {/* <Stack.Screen
            name="Passwords"
            component={Passwords}
            options={{ freezeOnBlur: true }} 
            initialParams={{
              title: 'Passwords',
              bgColor: bgColor,
              textColor: textColor,
            }}
            listeners={{
              focus: () => {
                setBgColor('#ffffff');
                setHeaderColor('#319177');
                setTextColor('#ffffff');
                setScreenLocation('Passwords');
              },
            }}
          /> */}
          {__DEV__ && (
            <>
              <Stack.Screen
                name="DevPlayground"
                component={DevPlayground}
                options={{freezeOnBlur: true}}
                initialParams={{
                  title: 'Dev Playground',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevPlayground');
                  },
                }}
              />
              <Stack.Screen
                name="DevText"
                component={DevText}
                options={{freezeOnBlur: true}}
                initialParams={{
                  title: 'Dev Text',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevText');
                  },
                }}
              />
              <Stack.Screen
                name="DevInputs"
                component={DevInputs}
                options={{freezeOnBlur: true}}
                initialParams={{
                  title: 'Dev Inputs',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevInputs');
                  },
                }}
              />
              <Stack.Screen
                name="DevButtons"
                component={DevButtons}
                options={{freezeOnBlur: true}}
                initialParams={{
                  title: 'Dev Buttons',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevButtons');
                  },
                }}
              />
              <Stack.Screen
                name="DevModals"
                component={DevModals}
                options={{freezeOnBlur: true}}
                initialParams={{
                  title: 'Dev Modals',
                  bgColor: bgColor,
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevModals');
                  },
                }}
              />
              <Stack.Screen
                name="DevDropdowns"
                component={DevDropdowns}
                options={{freezeOnBlur: true}}
                initialParams={{
                  title: 'Dev Dropdowns',
                  bgColor: 'white',
                  headerColor: headerColor,
                  textColor: textColor,
                  screenLocation: screenLocation,
                }}
                listeners={{
                  focus: () => {
                    setBgColor('#ffffff');
                    setHeaderColor('#319177');
                    setTextColor('#ffffff');
                    setScreenLocation('DevDropdowns');
                  },
                }}
              />
            </>
          )}
          <Stack.Screen name="Login" component={Auth} />
        </Stack.Navigator>
      </>
    );
  };

  if (!isAuthenticated) {
    return (
      <SafeAreaView style={{flex: 1, margin: 5}}>
        <Auth bgColor={bgColor} />
      </SafeAreaView>
    );
  } else {
    return (
      <NavigationContainer>
        <SafeAreaView
          style={{flex: 1, backgroundColor: headerColor}}
          edges={['top']}>
          <View style={{flex: 1}}>
            <Navigation />
            <BottomMenu toggleMenu={toggleMenu} />
          </View>
        </SafeAreaView>
        <SafeAreaView style={{height: bottomHeight}} edges={['bottom']}>
          <NavMenu
            bottomHeight={bottomHeight}
            bottomWidth={device?.dimensions?.width}
            toggleMenu={toggleMenu}
            setIsSheetOpen={setIsSheetOpen}
            device={device}
          />
        </SafeAreaView>
        {currentModal === 'TOS' && (
          <Modal
            visible={showTOSModal}
            title="Terms of Service Update"
            fullScreen
            hideClose>
            <TermsService
              handleTOSConfirm={handleTOSConfirm}
              handleCancel={handleCancel}
            />
          </Modal>
        )}

        {currentModal === 'PP' && (
          <Modal
            visible={showPPModal}
            title="Privacy Policy Update"
            fullScreen
            hideClose>
            <PrivacyPolicy
              handlePPConfirm={handlePPConfirm}
              handleCancel={handleCancel}
            />
          </Modal>
        )}
      </NavigationContainer>
    );
  }
};

export default Main;


--- FILE: app.json ---

{
  "name": "KitchenQueue",
  "displayName": "KitchenQueue"
}


--- FILE: babel.config.js ---

//* bable.config.js
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: ['react-native-reanimated/plugin'],
};


--- FILE: dataExport.js ---

export const shoppingBatch = [
  {
    quantity: 2,
    packageSize: 12,
    itemName: 'Eggs',
    description: 'Large white eggs',
    measurement: 'each',
    category: 'dairy',
    notes: 'Buy if on sale',
    status: 'shopping-list',
    brandName: "Eggland's Best",
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Milk',
    description: 'Whole milk',
    measurement: 'gallon',
    category: 'dairy',
    notes: '2% also okay',
    status: 'shopping-list',
    brandName: 'DairyPure',
  },
  {
    quantity: 2,
    packageSize: 1,
    itemName: 'Frozen Pizza',
    description: 'Pepperoni',
    measurement: 'each',
    category: 'frozen',
    notes: '',
    status: 'shopping-list',
    brandName: 'DiGiorno',
  },
  {
    quantity: 3,
    packageSize: 6,
    itemName: 'Bananas',
    description: 'Fresh bunch',
    measurement: 'each',
    category: 'produce',
    notes: 'Slightly green preferred',
    status: 'shopping-list',
    brandName: 'Dole',
  },
  {
    quantity: 1,
    packageSize: 16,
    itemName: 'Bread',
    description: 'Whole wheat loaf',
    measurement: 'slice',
    category: 'baked',
    notes: '',
    status: 'shopping-list',
    brandName: "Nature's Own",
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Ground Beef',
    description: '85% lean',
    measurement: 'pound',
    category: 'meats-seafood',
    notes: 'Organic preferred',
    status: 'shopping-list',
    brandName: 'Market Pantry',
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Yogurt',
    description: 'Strawberry',
    measurement: 'cup',
    category: 'dairy',
    notes: '',
    status: 'shopping-list',
    brandName: 'Chobani',
  },
  {
    quantity: 2,
    packageSize: 16,
    itemName: 'Cookies',
    description: 'Chocolate Chip',
    measurement: 'box',
    category: 'snacks',
    notes: 'Chewy',
    status: 'shopping-list',
    brandName: 'Chips Ahoy',
  },
  {
    quantity: 1,
    packageSize: 24,
    itemName: 'Cereal',
    description: 'Honey Oats',
    measurement: 'box',
    category: 'cereals',
    notes: 'Buy if on sale',
    status: 'shopping-list',
    brandName: 'Honey Bunches',
  },
  {
    quantity: 2,
    packageSize: 1,
    itemName: 'Chicken Breast',
    description: 'Boneless skinless',
    measurement: 'pound',
    category: 'meats-seafood',
    notes: '',
    status: 'shopping-list',
    brandName: 'Tyson',
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Orange Juice',
    description: 'No pulp',
    measurement: 'quart',
    category: 'beverages',
    notes: '100% juice only',
    status: 'shopping-cart',
    brandName: 'Tropicana',
  },
  {
    quantity: 2,
    packageSize: 6,
    itemName: 'Apples',
    description: 'Fuji',
    measurement: 'each',
    category: 'produce',
    notes: 'Firm & red',
    status: 'shopping-cart',
    brandName: 'Dole',
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Ketchup',
    description: 'Tomato',
    measurement: 'bottle',
    category: 'condiments',
    notes: '',
    status: 'shopping-cart',
    brandName: 'Heinz',
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Shredded Cheese',
    description: 'Cheddar blend',
    measurement: 'cup',
    category: 'dairy',
    notes: '',
    status: 'shopping-cart',
    brandName: 'Sargento',
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Spaghetti',
    description: 'Thin pasta',
    measurement: 'box',
    category: 'dry-pasta',
    notes: '',
    status: 'shopping-cart',
    brandName: 'Barilla',
  },
  {
    quantity: 1,
    packageSize: 12,
    itemName: 'Soda',
    description: 'Cola',
    measurement: 'fluidounce',
    category: 'beverages',
    notes: '',
    status: 'shopping-cart',
    brandName: 'Coca-Cola',
  },
  {
    quantity: 1,
    packageSize: 15,
    itemName: 'Canned Beans',
    description: 'Black beans',
    measurement: 'ounce',
    category: 'canned',
    notes: '',
    status: 'shopping-cart',
    brandName: 'Bushâ€™s',
  },
  {
    quantity: 2,
    packageSize: 1,
    itemName: 'Ice Cream',
    description: 'Vanilla',
    measurement: 'pint',
    category: 'frozen',
    notes: 'Any brand',
    status: 'shopping-cart',
    brandName: 'Ben & Jerryâ€™s',
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Flour',
    description: 'All-purpose',
    measurement: 'pound',
    category: 'baking',
    notes: '',
    status: 'shopping-cart',
    brandName: 'Gold Medal',
  },
  {
    quantity: 1,
    packageSize: 1,
    itemName: 'Olive Oil',
    description: 'Extra virgin',
    measurement: 'liter',
    category: 'spices',
    notes: '',
    status: 'shopping-cart',
    brandName: 'Bertolli',
  },
];

export const cupboardBatch = [
  {
    itemName: 'Eggs',
    brandName: 'Farm Fresh',
    description: 'Large brown eggs',
    packageSize: 12,
    remainingAmount: 8,
    measurement: 'ct',
    category: 'Dairy',
    notes: 'Use for breakfast and baking',
    quantity: 1,
  },
  {
    itemName: 'Milk',
    brandName: 'Dairy Pure',
    description: '2% reduced fat milk',
    packageSize: 1,
    remainingAmount: 0.4,
    measurement: 'gal',
    category: 'Dairy',
    notes: '',
    quantity: 1,
  },
  {
    itemName: 'Rice',
    brandName: 'Uncle Benâ€™s',
    description: 'Long grain white rice',
    packageSize: 5,
    remainingAmount: 2,
    measurement: 'lb',
    category: 'Pantry',
    notes: 'Running low',
    quantity: 1,
  },
  {
    itemName: 'Black Beans',
    brandName: 'Goya',
    description: 'Canned black beans',
    packageSize: 15.5,
    remainingAmount: 15.5,
    measurement: 'oz',
    category: 'Canned Goods',
    notes: '',
    quantity: 1,
  },
  {
    itemName: 'Olive Oil',
    brandName: 'Bertolli',
    description: 'Extra virgin olive oil',
    packageSize: 750,
    remainingAmount: 500,
    measurement: 'ml',
    category: 'Pantry',
    notes: '',
    quantity: 1,
  },
  {
    itemName: 'Bread',
    brandName: 'Sara Lee',
    description: 'Whole grain sandwich bread',
    packageSize: 18,
    remainingAmount: 6,
    measurement: 'slices',
    category: 'Bakery',
    notes: 'Getting stale',
    quantity: 1,
  },
  {
    itemName: 'Butter',
    brandName: 'Land O Lakes',
    description: 'Salted stick butter',
    packageSize: 4,
    remainingAmount: 1,
    measurement: 'sticks',
    category: 'Dairy',
    notes: '',
    quantity: 1,
  },
  {
    itemName: 'Carrots',
    brandName: 'Organic Valley',
    description: 'Baby carrots',
    packageSize: 2,
    remainingAmount: 0.5,
    measurement: 'lb',
    category: 'Produce',
    notes: '',
    quantity: 1,
  },
  {
    itemName: 'Chicken Breast',
    brandName: 'Tyson',
    description: 'Boneless skinless',
    packageSize: 2.5,
    remainingAmount: 1.2,
    measurement: 'lb',
    category: 'Meat',
    notes: 'Frozen',
    quantity: 1,
  },
  {
    itemName: 'Pasta',
    brandName: 'Barilla',
    description: 'Spaghetti noodles',
    packageSize: 16,
    remainingAmount: 10,
    measurement: 'oz',
    category: 'Pantry',
    notes: 'Dry goods',
    quantity: 1,
  },
];

let testData = {
  brandName: 'Tyson', // correct, they all have the same brand
  category: undefined, // correct, they all have a different category
  count: 3, // correct, there are 3 items
  itemName: 'Chicken Breast', // correct, they all have the same name
  itemId: 'fd0139c4-507e-4a0a-8aba-c35131e77589', // correct, this is the first itemI
  description: 'Boneless skinless', // correct, they all have the same description
  measurement: undefined, // correct, they all have a different measurement
  packageSize: undefined, // incorrect, this should be the total of the package sizes
  remainingAmount: undefined, // incorrect, this should be the total of the remaining amounts
  items: [
    {
      itemId: 'fd0139c4-507e-4a0a-8aba-c35131e77589',
      quantity: 1,
      packageSize: 2.5,
      itemName: 'Chicken Breast',
      description: 'Boneless skinless',
      itemDate: '2025-03-27T23:21:45.129Z',
      measurement: 'lb',
      category: 'Meat',
      notes: 'Frozen',
      remainingAmount: 2.5,
      brandName: 'Tyson',
    },
    {
      itemId: 'fd25e1d1-3cae-4732-a7f8-8d4c6cd329f1',
      quantity: 1,
      packageSize: 1,
      itemName: 'Chicken Breast',
      description: 'Boneless skinless',
      itemDate: '2025-03-30T17:41:01.976Z',
      measurement: 'pound',
      category: 'meats-seafood',
      notes: '',
      remainingAmount: 1,
      brandName: 'Tyson',
    },
    {
      itemId: '0ddf7f20-acfc-4a19-b2c1-ba98157b830a',
      quantity: 1,
      packageSize: 1,
      itemName: 'Chicken Breast',
      description: 'Boneless skinless',
      itemDate: '2025-03-30T17:41:01.976Z',
      measurement: 'pound',
      category: 'meats-seafood',
      notes: '',
      remainingAmount: 1,
      brandName: 'Tyson',
    },
  ],
};


--- FILE: exportComponents.js ---

const fs = require('fs');
const path = require('path');

const ROOT_DIR = __dirname;
const COMPONENT_DIR = path.join(ROOT_DIR); // Start at project root
const OUTPUT_STRUCTURE_FILE = 'y-structure.txt';
const OUTPUT_CODE_FILE = 'z-export.txt';

const codeExtensions = ['.js', '.jsx', '.ts', '.tsx', '.json']; // for z-export
const structureExtensions = [...codeExtensions, '.png']; // for y-structure

const ignoreFolders = [
  'ios',
  'android',
  '.vscode',
  '.bundle',
  '__tests__',
  'node_modules',
  '.git',
];
const ignoreFiles = [
  '.DS_Store',
  '.eslintrc.js',
  '.gitignore',
  '.prettierrc.js',
  '.watchmanconfig',
];

function walk(dir, validExtensions) {
  let results = [];

  fs.readdirSync(dir).forEach(file => {
    const filepath = path.join(dir, file);
    const relativePath = path.relative(ROOT_DIR, filepath);
    const stat = fs.statSync(filepath);

    if (
      stat.isDirectory() &&
      !ignoreFolders.includes(path.basename(filepath))
    ) {
      results = results.concat(walk(filepath, validExtensions));
    } else if (
      stat.isFile() &&
      !ignoreFiles.includes(path.basename(filepath)) &&
      validExtensions.includes(path.extname(file))
    ) {
      results.push(filepath);
    }
  });

  return results;
}

// ðŸ“ Build file list for structure
const structureFiles = walk(COMPONENT_DIR, structureExtensions);
const structureList = structureFiles.map(file => path.relative(ROOT_DIR, file));
fs.writeFileSync(OUTPUT_STRUCTURE_FILE, structureList.join('\n'), 'utf8');

// ðŸ“„ Build file list for code dump
const codeFiles = walk(COMPONENT_DIR, codeExtensions);
let bundle = '';
codeFiles.forEach(file => {
  const relativePath = path.relative(ROOT_DIR, file);
  const code = fs.readFileSync(file, 'utf8');
  bundle += `\n\n--- FILE: ${relativePath} ---\n\n${code}`;
});
fs.writeFileSync(OUTPUT_CODE_FILE, bundle, 'utf8');

console.log(`âœ… Structure exported to ${OUTPUT_STRUCTURE_FILE}`);
console.log(
  `âœ… ${codeFiles.length} code files exported to ${OUTPUT_CODE_FILE}`,
);


--- FILE: index.js ---

//*index.js
import {AppRegistry, LogBox} from 'react-native';
import App from './App';
import {name as appName} from './app.json';

LogBox.ignoreAllLogs(true);

AppRegistry.registerComponent(appName, () => App);


--- FILE: jest.config.js ---

//* jest.config.js
module.exports = {
  preset: 'react-native',
};


--- FILE: metro.config.js ---

//* metro.config.js
const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');

const config = {
  server: {
    enhanceMiddleware: middleware => {
      return (req, res, next) => {
        if (req.url.startsWith('/debugger-ui')) {
          res.writeHead(404);
          res.end();
          return;
        }
        return middleware(req, res, next);
      };
    },
  },
};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);


--- FILE: package.json ---

{
  "name": "kitchen-queue",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "android": "react-native run-android",
    "ios": "react-native run-ios",
    "lint": "eslint .",
    "start": "react-native start",
    "start-clean": "react-native start --reset-cache",
    "pod-clean": "cd ios && pod install --repo-update && cd ..",
    "gradle-clean": "cd android && ./gradlew clean && cd ..",
    "clean-project": "rm -rf node_modules && yarn cache clean && yarn install && yarn pod-clean && yarn gradle-clean",
    "clean-and-start": "rm -rf node_modules && yarn cache clean && yarn install && yarn pod-clean && yarn gradle-clean && yarn start-clean",
    "open-studio": "open -a 'Android Studio'",
    "export-project": "node exportComponents.js",
    "test": "jest"
  },
  "dependencies": {
    "@dicebear/collection": "9.2.2",
    "@dicebear/core": "9.2.2",
    "@react-native-async-storage/async-storage": "2.1.2",
    "@react-native-clipboard/clipboard": "1.16.2",
    "@react-native-firebase/app": "^21.12.0",
    "@react-native-firebase/auth": "^21.12.0",
    "@react-native-firebase/firestore": "^21.12.0",
    "@react-navigation/native": "7.0.17",
    "@react-navigation/native-stack": "7.3.1",
    "@shopify/flash-list": "1.7.6",
    "pluralize": "8.0.0",
    "react": "19.0.0",
    "react-native": "0.78.1",
    "react-native-config": "1.5.5",
    "react-native-device-info": "14.0.4",
    "react-native-gesture-handler": "2.24.0",
    "react-native-haptic-feedback": "2.3.3",
    "react-native-permissions": "5.2.6",
    "react-native-reanimated": "3.17.1",
    "react-native-safe-area-context": "^5.3.0",
    "react-native-screens": "4.9.2",
    "react-native-svg": "15.11.2",
    "react-native-toast-message": "2.2.1",
    "react-native-uuid": "2.0.3",
    "react-native-vector-icons": "10.2.0",
    "react-redux": "9.2.0",
    "redux": "5.0.1",
    "redux-persist": "6.0.0",
    "redux-saga": "1.3.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.10",
    "@babel/helpers": "^7.26.10",
    "@babel/runtime": "^7.26.10",
    "@react-native-community/cli": "15.1.3",
    "@react-native-community/cli-platform-android": "15.1.3",
    "@react-native-community/cli-platform-ios": "15.1.3",
    "@react-native/babel-preset": "0.78.1",
    "@react-native/eslint-config": "0.78.1",
    "@react-native/metro-config": "0.78.1",
    "@react-native/typescript-config": "0.78.1",
    "react-test-renderer": "19.0.0"
  },
  "resolutions": {
    "@babel/runtime": "^7.26.10",
    "@babel/helpers": "^7.26.10"
  },
  "engines": {
    "node": ">=18"
  }
}


--- FILE: react-native.config.js ---

//* react-native.config.js
module.exports = {
  project: {
    ios: {},
    android: {},
  },
  assets: ['./src/fonts'],
  dependencies: {
    'react-native-vector-icons': {
      platforms: {
        android: null, // ðŸ‘ˆ Tells autolink to ignore it for Android native builds
      },
    },
  },
};


--- FILE: src/KQ-UI/KQBottomSheet.jsx ---

//* KQBottomSheet.jsx
import React, {useEffect, useRef, useState} from 'react';
import {
  View,
  Animated,
  StyleSheet,
  Dimensions,
  TouchableWithoutFeedback,
} from 'react-native';
import {PanGestureHandler, State} from 'react-native-gesture-handler';

const {height} = Dimensions.get('window');

const KQBottomSheet = ({
  visible,
  onClose,
  children,
  snapPoints = [0.01, 0.9], // Default snap points
}) => {
  const translateY = useRef(new Animated.Value(height)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  const [isFullyVisible, setIsFullyVisible] = useState(visible);
  const [heightMulti, setHeightMulti] = useState(0.8);

  useEffect(() => {
    if (visible) {
      setIsFullyVisible(true); // Ensure component is mounted
      Animated.parallel([
        Animated.spring(translateY, {
          toValue: height * (1 - snapPoints[1]),
          speed: 7,
          bounciness: 3,
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 1,
          duration: 250, // Smooth fade-in
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.spring(translateY, {
          toValue: height, // Move off-screen
          speed: 5,
          bounciness: 0,
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start(() => {
        setTimeout(() => {
          setIsFullyVisible(false); // Only unmount AFTER animation completes
        }, 500);
      });
    }
  }, [visible]);

  if (!isFullyVisible) return null; // Prevent rendering when fully hidden

  const handleGesture = event => {
    const {translationY} = event.nativeEvent;

    if (translationY >= 0) {
      translateY.setValue(height * (1 - snapPoints[1]) + translationY);
    }
  };

  const handleStateChange = event => {
    const {translationY, velocityY} = event.nativeEvent;

    if (event.nativeEvent.state === State.END) {
      if (translationY > height * 0.5 || velocityY > 1.5) {
        Animated.timing(translateY, {
          toValue: height,
          duration: 250,
          useNativeDriver: true,
        }).start(() => onClose());
      } else {
        Animated.spring(translateY, {
          toValue: height * (1 - snapPoints[1]),
          speed: 7,
          bounciness: 3,
          useNativeDriver: true,
        }).start();
      }
    }
  };

  return (
    <TouchableWithoutFeedback
      onPress={e => {
        if (e.target === e.currentTarget) {
          onClose(); // Only close if tapping outside the modal
        }
      }}
      accessible={false} // Prevents interference with child components
    >
      <Animated.View style={[styles.overlay, {opacity}]}>
        <Animated.View
          style={[
            styles.sheet,
            {transform: [{translateY}]},
            {height: height * heightMulti},
          ]}>
          <PanGestureHandler
            onGestureEvent={handleGesture}
            onHandlerStateChange={handleStateChange}>
            <View style={styles.handleContainer}>
              <View style={styles.handle} />
            </View>
          </PanGestureHandler>
          <View style={styles.viewableArea}>{children}</View>
        </Animated.View>
      </Animated.View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'flex-end',
  },
  sheet: {
    width: '100%',
    height: height,
    backgroundColor: '#fff',
    borderTopLeftRadius: 15,
    borderTopRightRadius: 15,
  },
  handleContainer: {
    alignItems: 'center',
    paddingTop: 15,
    paddingBottom: 15,
  },
  handle: {
    width: 40,
    height: 5,
    backgroundColor: '#c4c4c4',
    borderRadius: 10,
  },
  viewableArea: {
    flex: 1,
    marginHorizontal: 5,
    // borderWidth: 1,
    marginBottom: 55,
  },
});

export default __DEV__ ? KQBottomSheet : React.memo(KQBottomSheet);


--- FILE: src/KQ-UI/KQButton.jsx ---

//* KQButton.jsx
import React, {useCallback} from 'react';
import {StyleSheet, TouchableOpacity, View} from 'react-native';
import {Text} from '../KQ-UI/';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {
  useColors,
  useFontStyles,
  useButtonStyles,
  useButtonSizes,
} from './KQUtilities';
import {useCoreInfo} from '../utilities/coreInfo';

const KQButton = ({
  children,
  onPress,
  style = {},
  textStyle = {},
  outerTextStyle = {},
  type = 'filled',
  size = 'small',
  color = 'primary',
  textSize = 'small',
  textColor = 'white',
  fontType = 'open-6',
  hapticFeedback = 'light',
  disabled = false,
  ...props
}) => {
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();
  const buttonColor = useColors(disabled ? 'basic' : color);
  const buttonStyle = useButtonStyles(type, buttonColor);
  const buttonSize = useButtonSizes(size);

  const fontStyles = useFontStyles(
    fontType,
    textSize,
    type === 'filled' ? textColor : buttonColor,
  );

  const handlePress = useCallback(() => {
    useHaptics(core?.userSettings?.hapticStrength || hapticFeedback);
    if (onPress) onPress();
  }, [core?.userSettings?.hapticStrength, hapticFeedback, onPress]);

  return (
    <TouchableOpacity
      style={[ButtonStyles.buttonOC, buttonStyle, buttonSize, style]}
      onPress={!disabled ? handlePress : null}
      disabled={disabled}
      {...props}>
      <View style={outerTextStyle}>
        <Text
          numberOfLines={1}
          style={[ButtonStyles.buttonText, fontStyles, textStyle]}>
          {children}
        </Text>
      </View>
    </TouchableOpacity>
  );
};

const ButtonStyles = StyleSheet.create({
  buttonOC: {
    borderRadius: 5,
    margin: 5,
    alignContent: 'center',
    alignItems: 'center',
    justifyContent: 'center',
  },
  buttonText: {
    fontSize: 16,
    textAlign: 'center',
  },
});

export default __DEV__ ? KQButton : React.memo(KQButton);


--- FILE: src/KQ-UI/KQDropdown.jsx ---

//* KQDropdown.jsx

import React, {useMemo, useState} from 'react';
import {
  View,
  TouchableOpacity,
  Platform,
  KeyboardAvoidingView,
} from 'react-native';
import {Modal, Text, ScrollView, Input} from '../KQ-UI/';
import {Icons} from '../components/IconListRouter';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useCoreInfo} from '../utilities/coreInfo';

const KQDropdown = ({
  label = '',
  customLabel = '',
  labelStyles = {},
  required = false,
  validation = false,
  validationMessage = '',
  value = null,
  setValue = () => {},
  placeholder = '',
  onPress = () => {},
  caption,
  hapticFeedback = 'light',
  mapData,
  ...props
}) => {
  const isIOS = Platform.OS === 'ios';
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();
  const [showDropModal, setShowDropModal] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);
  const [customValue, setCustomValue] = useState('');

  const handleOnPress = () => {
    useHaptics(core?.userSettings?.hapticStrength || hapticFeedback);
    setSelectedItem(value); // set to current value on open
    setShowDropModal(true);
    onPress();
  };

  const renderStyles = useMemo(() => {
    if (isIOS && value === null) {
      return {
        color: '#373d4350',
        padding: 0,
      };
    }

    if (!isIOS && value === null) {
      return {
        color: '#373d43',
        padding: 0,
        opacity: 0.8,
      };
    }
  }, [value, placeholder]);

  const handleCancel = () => {
    setShowDropModal(false);
    setSelectedItem(null);
    setCustomValue('');
  };

  const handleSave = item => {
    setShowDropModal(false);

    if (item?.key === 'custom') {
      const cleaned = customValue.trim();
      const newItem = {
        index: -1,
        key: cleaned.toLowerCase().replace(/\s+/g, '-'),
        label: cleaned,
      };
      setValue(newItem);
    } else {
      setValue(item);
    }
  };

  const handleClear = () => {
    setSelectedItem(null);
    setValue(null);
    setCustomValue('');
  };

  return (
    <View style={styles.dropContainer}>
      {label && (
        <View style={styles.labelContainer}>
          <View style={styles.labelContainer}>
            <Text
              size="small"
              font="open-6"
              style={[styles.label(validation, props.disabled), labelStyles]}>
              {label} {required && '*'}
            </Text>
          </View>
        </View>
      )}
      <View style={styles.dropWrapper}>
        <TouchableOpacity onPress={() => handleOnPress()} style={{flex: 1}}>
          <Text style={renderStyles}>{value?.label || placeholder}</Text>
        </TouchableOpacity>

        {value && (
          <TouchableOpacity
            onPress={() => handleClear()}
            style={{paddingHorizontal: 5}}>
            <Icons.Close />
          </TouchableOpacity>
        )}

        <TouchableOpacity
          onPress={() => handleOnPress()}
          style={{paddingHorizontal: 5}}>
          <Icons.ChevronDown />
        </TouchableOpacity>
      </View>
      {caption && (
        <View style={styles.captionContainer}>
          <View style={{flex: 1}}>
            <Text
              size="xSmall"
              kqColor="dark90"
              font="open-5"
              numberOfLines={1}>
              ({caption})
            </Text>
          </View>
        </View>
      )}
      <Modal
        visible={showDropModal}
        fullScreen
        hideHeader
        onClose={() => setShowDropModal(false)}>
        <View style={styles.modalContainer}>
          <View style={styles.headerContainer}>
            <TouchableOpacity
              style={styles.headerButtonContainer}
              onPress={handleCancel}>
              <View style={styles.headerButtonIconLeft}>
                <View style={{position: 'relative', left: 4}}>
                  <Icons.Back />
                </View>
              </View>
              <View style={styles.headerButtonTextLeft}>
                <Text>Cancel</Text>
              </View>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.headerButtonContainer}
              onPress={() => handleSave(selectedItem)}>
              <View style={styles.headerButtonTextRight}>
                <Text>Select</Text>
              </View>
              <View style={styles.headerButtonIconRight}>
                <Icons.Check size={20} />
              </View>
            </TouchableOpacity>
          </View>
          <View style={{flex: 1}}>
            <ScrollView>
              <View style={{flex: 1}}>
                {mapData?.map((item, index) => {
                  const isCustomField = item.key === 'custom';
                  return (
                    <View
                      key={index}
                      style={{borderBottomWidth: 1, borderColor: '#373d4380'}}>
                      {isCustomField ? (
                        <View
                          style={{
                            paddingHorizontal: 5,
                            paddingVertical: 8,
                          }}>
                          {customLabel && (
                            <Text size="xSmall" font="open-5" style={{}}>
                              {customLabel}
                            </Text>
                          )}
                          <KeyboardAvoidingView>
                            <Input
                              value={customValue}
                              onChangeText={text => {
                                setCustomValue(text);
                                setSelectedItem({
                                  index: 0,
                                  key: 'custom',
                                  label: 'Custom (Enter Your Own)',
                                });
                              }}
                              placeholder="Type here..."
                              containerStyles={{
                                marginHorizontal: 0,
                                marginVertical: 0,
                                paddingHorizontal: 0,
                                marginTop: 5,
                              }}
                              wrapperStyles={{borderBottomWidth: 0}}
                            />
                          </KeyboardAvoidingView>
                        </View>
                      ) : (
                        <TouchableOpacity
                          style={{
                            height: 48,
                            alignItems: 'flex-start',
                            justifyContent: 'center',
                            paddingHorizontal: 5,
                          }}
                          onPress={() => setSelectedItem(item)}>
                          <View style={{flexDirection: 'row'}}>
                            <View style={{flex: 1}}>
                              <Text
                                size={
                                  selectedItem?.index === item.index
                                    ? 'small'
                                    : 'xSmall'
                                }
                                font={
                                  selectedItem?.index === item.index
                                    ? 'open-7'
                                    : 'open-5'
                                }>
                                {item.label}
                              </Text>
                            </View>
                            {selectedItem?.index === item.index && (
                              <View>
                                <Icons.Check color={'#63B76C'} size={20} />
                              </View>
                            )}
                          </View>
                        </TouchableOpacity>
                      )}
                    </View>
                  );
                })}
              </View>
            </ScrollView>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = {
  dropContainer: {
    marginHorizontal: 5,
    marginVertical: 10,
    paddingHorizontal: 2,
  },
  labelContainer: {position: 'relative', left: 0},
  label: (validation, disabled) => ({
    color: validation ? '#fE4949' : disabled ? '#373d4390' : '#373d43',
  }),
  dropWrapper: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
    paddingTop: 2,
    paddingBottom: 4,
  },
  captionContainer: {
    flexDirection: 'row',
    paddingHorizontal: 2,
    marginTop: 2,
  },
  textInputContainer: {
    flex: 1,
    paddingHorizontal: 1,
    paddingVertical: 3,
  },
  modalContainer: {flex: 1, flexDirection: 'column'},
  headerContainer: {
    height: 50,
    marginHorizontal: 5,
    marginBottom: 5,
    flexDirection: 'row',
  },
  headerButtonContainer: {
    flex: 1,
    flexDirection: 'row',
  },
  headerButtonIconRight: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 5,
  },
  headerButtonIconLeft: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerButtonTextLeft: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    paddingHorizontal: 5,
  },
  headerButtonTextRight: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingHorizontal: 5,
    marginRight: 5,
  },
};

export default __DEV__ ? KQDropdown : React.memo(KQDropdown);


--- FILE: src/KQ-UI/KQInput.jsx ---

//* KQInput.jsx
import React, {useMemo} from 'react';
import {View, TextInput, StyleSheet, Keyboard} from 'react-native';
import {Text} from '../KQ-UI/';
import {useColors, useFontStyles} from './KQUtilities';

const KQInput = ({
  label = '',
  labelStyles = {},
  required = false,
  validation = false,
  validationMessage = '',
  value = '',
  onChangeText = () => {},
  capitalize = false,
  capitalMode = 'none',
  multiline = false,
  multiHeight = 'medium',
  scrollEnabled = true,
  caption = '',
  accessoryRight = null,
  counter = false,
  maxCount = 250,
  containerStyles = {},
  wrapperStyles = {},
  ...props
}) => {
  const fontStyles = useFontStyles('open-6', 'small', 'black');
  const showCount = value?.length || 0;

  const multiMode = useMemo(() => {
    if (!multiline) return {};

    const heightMap = {
      small: {minHeight: 20, maxHeight: 40},
      medium: {minHeight: 20, maxHeight: 75},
      large: {minHeight: 20, maxHeight: 150},
      xLarge: {minHeight: 20, maxHeight: 250},
      full: {minHeight: 20},
    };

    return {...(heightMap[multiHeight] || heightMap.medium)};
  }, [multiline, multiHeight]);

  const capMode = useMemo(
    () => (multiline ? 'sentences' : capitalize ? capitalMode : 'none'),
    [capitalize, capitalMode, multiline],
  );

  const InputInfoContainer = ({children}) => {
    if (caption || counter || validationMessage) {
      return (
        <View
          style={{
            flexDirection: 'row',
            paddingHorizontal: 2,
            marginTop: 2,
          }}>
          {children}
        </View>
      );
    }
    return null;
  };

  const handleTextChange = text => {
    if (text.length > maxCount) {
      text = text.substring(0, maxCount); // Trim excess characters
    }
    onChangeText(text); // Update state
  };

  return (
    <View style={[styles.inputContainer, {...containerStyles}]}>
      {label && (
        <View style={styles.labelContainer}>
          <Text
            size="small"
            font="open-6"
            style={[styles.label(validation, props.disabled), labelStyles]}>
            {label} {required && '*'}
          </Text>
        </View>
      )}
      <View style={[styles.inputWrapper, {...wrapperStyles}]}>
        <View style={styles.textInputContainer}>
          <TextInput
            value={value}
            onChangeText={handleTextChange}
            autoCapitalize={capMode}
            multiline={multiline}
            allowFontScaling={false}
            style={[fontStyles, multiMode, {padding: 0}]}
            onSubmitEditing={Keyboard.dismiss}
            {...props}
          />
        </View>
        {accessoryRight && (
          <View style={styles.accessoriesContainer}>{accessoryRight()}</View>
        )}
      </View>
      <InputInfoContainer>
        {caption && (
          <View style={{flex: 1}}>
            <Text
              size="xSmall"
              kqColor="dark90"
              font="open-5"
              numberOfLines={1}>
              ({caption})
            </Text>
          </View>
        )}
        {validation && (
          <View style={{flex: 1}}>
            <Text
              size="xSmall"
              kqColor="danger"
              font="open-5"
              numberOfLines={1}>
              ({validationMessage})
            </Text>
          </View>
        )}
        {counter && (
          <View style={{flex: caption ? 0 : 1, alignItems: 'flex-end'}}>
            <Text
              size="xSmall"
              kqColor={showCount >= maxCount ? 'danger' : 'dark90'}
              font="open-5"
              numberOfLines={1}>
              ({showCount} / {maxCount})
            </Text>
          </View>
        )}
      </InputInfoContainer>
    </View>
  );
};

const styles = {
  inputContainer: {
    marginHorizontal: 5,
    marginVertical: 10,
    paddingHorizontal: 2,
  },
  labelContainer: {position: 'relative', left: 0},
  label: (validation, disabled) => ({
    color: validation ? '#DA2C43' : disabled ? '#373d4390' : '#373d43',
  }),
  inputWrapper: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
  },
  textInputContainer: {
    flex: 1,
    paddingHorizontal: 1,
    paddingVertical: 3,
  },
  accessoriesContainer: {
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
};

export default __DEV__ ? KQInput : React.memo(KQInput);


--- FILE: src/KQ-UI/KQLayout.jsx ---

//* KQLayout.jsx
import React from 'react';
import {
  TouchableWithoutFeedback,
  Keyboard,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  View,
} from 'react-native';
import NavHeader from '../components/NavHeader';

const KQLayout = ({
  children,
  bgColor = '#ffffff',
  headerTitle = '',
  headerColor = '#319177',
  textColor = '#ffffff',
  LeftButton = '',
  RightButton = '',
  LeftAction = null,
  RightAction = null,
  sheetOpen = false,
  useHeader = true,
  useKeyboardHandling = false,
  innerViewStyles = {},
  outerViewStyles = {},
}) => {
  if (useKeyboardHandling) {
    return (
      <View
        style={[
          {flex: 1, backgroundColor: bgColor, paddingBottom: 25},
          outerViewStyles,
        ]}>
        <TouchableWithoutFeedback onPress={Keyboard.dismiss} accessible={false}>
          <View style={{flex: 1}}>
            {useHeader && (
              <NavHeader
                title={headerTitle}
                headerColor={headerColor}
                textColor={textColor}
                LeftButton={LeftButton}
                RightButton={RightButton}
                LeftAction={LeftAction}
                RightAction={RightAction}
                sheetOpen={sheetOpen}
              />
            )}
            <KeyboardAvoidingView
              style={{flex: 1}}
              behavior={Platform.OS === 'ios' ? 'padding' : undefined}
              keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}>
              <ScrollView
                onScrollBeginDrag={Keyboard.dismiss}
                contentContainerStyle={{flexGrow: 1}}>
                <View style={[{flex: 1}, innerViewStyles]}>{children}</View>
              </ScrollView>
            </KeyboardAvoidingView>
          </View>
        </TouchableWithoutFeedback>
      </View>
    );
  } else {
    return (
      <View
        style={[
          {flex: 1, backgroundColor: bgColor, paddingBottom: 25},
          outerViewStyles,
        ]}>
        {useHeader && (
          <NavHeader
            title={headerTitle}
            headerColor={headerColor}
            textColor={textColor}
            LeftButton={LeftButton}
            RightButton={RightButton}
            LeftAction={LeftAction}
            RightAction={RightAction}
            sheetOpen={sheetOpen}
          />
        )}
        <View style={[{flex: 1}, innerViewStyles]}>{children}</View>
      </View>
    );
  }
};

export default KQLayout;


--- FILE: src/KQ-UI/KQModal.jsx ---

//* KQModal.jsx
import React, {useEffect, useRef, useState} from 'react';
import {
  View,
  Keyboard,
  TouchableOpacity,
  Modal,
  StatusBar,
  Pressable,
  Dimensions,
} from 'react-native';
import {Icons} from '../components/IconListRouter';
import {Text} from '../KQ-UI';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import {useColors} from './KQUtilities';
import {useCoreInfo} from '../utilities/coreInfo';

const KQModal = ({
  visible,
  title = '',
  children,
  height = '90%',
  width = '90%',
  headerFont = 'open-6',
  headerSize = 'small',
  headerTextColor = 'white',
  headerColor = 'primary',
  headerBorderColor = 'primary',
  hideHeader = false,
  hideTitle = false,
  hideClose = false,
  fullScreen = false,
  hapticFeedback = 'light',
  onClose,
}) => {
  const useHaptics = setHapticFeedback();
  const core = useCoreInfo();
  const insets = useSafeAreaInsets();
  const isClosingRef = useRef(false);

  const handleClose = (event = null) => {
    const isBackdropTap = event?.target === event?.currentTarget;
    const isManualCall = !event;

    if ((isBackdropTap || isManualCall) && !isClosingRef.current) {
      isClosingRef.current = true;

      useHaptics(core?.userSettings?.hapticStrength || hapticFeedback);
      Keyboard.dismiss();

      setTimeout(() => {
        onClose?.();
        isClosingRef.current = false;
      }, 100);
    }
  };

  const Header = () => {
    if (hideHeader) {
      return null;
    }
    return (
      <View
        style={[
          styles.headerWrapper(fullScreen),
          {
            borderColor: useColors(headerBorderColor),
            backgroundColor: useColors(headerColor),
          },
        ]}>
        <View style={styles.headerContainer}>
          {!hideTitle && (
            <Text
              kqColor={useColors(headerTextColor)}
              font={headerFont}
              size={headerSize}>
              {title}
            </Text>
          )}
        </View>
        {!hideClose && (
          <TouchableOpacity
            style={styles.closeButton}
            onPress={() => handleClose()}>
            <Icons.Close size={25} color={'white'} />
          </TouchableOpacity>
        )}
      </View>
    );
  };

  const [screenSize, setScreenSize] = useState({
    height: Dimensions.get('window').height,
    width: Dimensions.get('window').width,
  });

  useEffect(() => {
    const updateScreenSize = () => {
      setScreenSize({
        height: Dimensions.get('window').height,
        width: Dimensions.get('window').width,
      });
    };

    const subscription = Dimensions.addEventListener(
      'change',
      updateScreenSize,
    );

    return () => subscription?.remove();
  }, []);

  const prsHeight = Math.min(Math.max(parseFloat(height), 75), 100);
  const prsWidth = Math.min(Math.max(parseFloat(width), 75), 100);

  const topHeight = fullScreen
    ? 0
    : insets.top + (screenSize.height - (screenSize.height * prsHeight) / 100);
  const btmHeight = fullScreen
    ? 0
    : insets.bottom +
      (screenSize.height - (screenSize.height * prsHeight) / 100);
  const midHeight = screenSize.height - topHeight - btmHeight;

  const midLeftWidth = fullScreen
    ? 0
    : insets.left + (screenSize.width - (screenSize.width * prsWidth) / 100);
  const midRightWidth = fullScreen
    ? 0
    : insets.right + (screenSize.width - (screenSize.width * prsWidth) / 100);

  if (!visible) {
    return null;
  }

  return (
    <Modal
      visible={visible}
      animationType="fade"
      transparent={true}
      statusBarTranslucent
      onRequestClose={handleClose}>
      <StatusBar
        barStyle={fullScreen ? 'dark-content' : 'light-content'}
        backgroundColor={'rgba(0,0,0,0.5)'}
        translucent
      />
      <View style={styles.wrapper}>
        <Pressable
          style={styles.pressTop(topHeight, screenSize)}
          onPress={handleClose}
        />
        <View style={styles.container}>
          <Pressable
            style={styles.pressLeft(midLeftWidth, midHeight)}
            onPress={handleClose}
          />
          <View style={styles.subContainer(fullScreen, midHeight, insets)}>
            <Header />
            {children}
          </View>
          <Pressable
            style={styles.pressRight(midRightWidth, midHeight)}
            onPress={handleClose}
          />
        </View>
        <Pressable
          style={styles.pressBtm(btmHeight, screenSize)}
          onPress={handleClose}
        />
      </View>
    </Modal>
  );
};

export default __DEV__ ? KQModal : React.memo(KQModal);

const styles = {
  wrapper: {
    flex: 1,
    flexDirection: 'column',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  pressTop: (topHeight, screenSize) => ({
    height: topHeight,
    width: screenSize.width,
    backgroundColor: 'transparent',
  }),
  pressBtm: (btmHeight, screenSize) => ({
    height: btmHeight,
    width: screenSize.width,
    backgroundColor: 'transparent',
  }),
  pressLeft: (midLeftWidth, midHeight) => ({
    width: midLeftWidth,
    height: midHeight,
    backgroundColor: 'transparent',
  }),
  pressRight: (midRightWidth, midHeight) => ({
    width: midRightWidth,
    height: midHeight,
    backgroundColor: 'transparent',
  }),
  container: {flex: 1, flexDirection: 'row'},
  subContainer: (fullScreen, midHeight, insets) => ({
    flex: 1,
    height: midHeight,
    borderWidth: 1,
    borderColor: '#319177',
    backgroundColor: '#fff',
    paddingTop: fullScreen ? insets.top : 0,
    paddingBottom: fullScreen ? insets.bottom : 0,
    borderRadius: fullScreen ? 0 : 10,
    shadowColor: fullScreen ? '' : 'black',
    shadowOffset: fullScreen ? {} : {width: 3, height: 4},
    shadowOpacity: fullScreen ? 0 : 0.5,
    elevation: fullScreen ? 0 : 7,
  }),

  headerWrapper: fullScreen => ({
    flexDirection: 'row',
    borderWidth: fullScreen ? 0 : 1,
    borderTopRightRadius: fullScreen ? 0 : 8,
    borderTopLeftRadius: fullScreen ? 0 : 8,
    // borderColor: '#319177',
    // backgroundColor: '#319177',
  }),
  headerContainer: {
    flex: 1,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  closeButton: {
    position: 'absolute',
    zIndex: 999,
    right: 0,
    borderWidth: 1.5,
    backgroundColor: '#319177',
    justifyContent: 'center',
    alignItems: 'center',
    margin: 5,
    width: 30,
    height: 30,
    borderRadius: 8,
    borderColor: 'white',
  },
};


--- FILE: src/KQ-UI/KQScrollView.jsx ---

//* KQScrollView.jsx
import React, {useState, useRef, useEffect} from 'react';
import {ScrollView, View, StyleSheet} from 'react-native';

const KQScrollView = ({children, style}) => {
  const [scrollBarHeight, setScrollBarHeight] = useState(0);
  const [scrollBarTop, setScrollBarTop] = useState(0);
  const [layoutHeight, setLayoutHeight] = useState(0);
  const [contentHeight, setContentHeight] = useState(0);

  const scrollViewRef = useRef();

  useEffect(() => {
    if (layoutHeight > 0 && contentHeight > layoutHeight) {
      const visibleRatio = layoutHeight / contentHeight;
      const calculatedHeight = layoutHeight * visibleRatio;
      const minHeight = 30;
      setScrollBarHeight(Math.max(calculatedHeight, minHeight));
      setScrollBarTop(0);
    } else {
      setScrollBarHeight(0);
      setScrollBarTop(0);
    }
  }, [layoutHeight, contentHeight]);

  const handleLayout = event => {
    const {height} = event.nativeEvent.layout;
    setLayoutHeight(height);
  };

  const handleContentSizeChange = (width, height) => {
    setContentHeight(height);
  };

  const handleScroll = event => {
    const {layoutMeasurement, contentOffset, contentSize} = event.nativeEvent;
    const scrollRatio =
      contentOffset.y / (contentSize.height - layoutMeasurement.height);
    const calculatedTop =
      scrollRatio * (layoutMeasurement.height - scrollBarHeight);
    setScrollBarTop(calculatedTop);
  };

  return (
    <View style={[styles.container, style]}>
      <ScrollView
        ref={scrollViewRef}
        onScroll={handleScroll}
        onLayout={handleLayout}
        onContentSizeChange={handleContentSizeChange}
        scrollEventThrottle={16}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}>
        {children}
      </ScrollView>
      {scrollBarHeight > 0 && (
        <View style={styles.scrollBar}>
          <View
            style={[
              styles.scrollBarThumb,
              {
                height: scrollBarHeight,
                top: scrollBarTop,
              },
            ]}
          />
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    position: 'relative',
    marginHorizontal: 3,
    paddingHorizontal: 5,
  },
  scrollContent: {
    flexGrow: 1,
    paddingRight: 10,
    paddingTop: 5,
    paddingBottom: 5,
  },
  scrollBar: {
    position: 'absolute',
    right: 2,
    top: 2,
    bottom: 2,
    width: 4,
    backgroundColor: 'transparent',
    borderRadius: 2,
  },
  scrollBarThumb: {
    position: 'absolute',
    left: 0,
    right: 0,
    backgroundColor: '#373d4380',
    borderRadius: 3,
  },
});

export default KQScrollView;


--- FILE: src/KQ-UI/KQText.jsx ---

//* KQText.jsx
import React from 'react';
import {Text} from 'react-native';
import {useFontStyles} from './KQUtilities';

const KQText = ({
  children,
  italic = false,
  centered = false,
  style,
  size = 'small',
  kqColor = 'black',
  font = 'open-6',
  ...props
}) => {
  const fontStyles = useFontStyles(font, size, kqColor);

  return (
    <Text
      allowFontScaling={false}
      style={[
        fontStyles,
        {
          fontStyle: italic ? 'italic' : 'normal',
          textAlign: centered ? 'center' : 'left',
        },
        style,
      ]}
      {...props}>
      {children}
    </Text>
  );
};

export default __DEV__ ? KQText : React.memo(KQText);


--- FILE: src/KQ-UI/KQToast.jsx ---

//*KQToast.jsx
import {BaseToast} from 'react-native-toast-message';

const toastStyles = {
  baseStyle: {
    top: 60,
    minHeight: 75,
    paddingVertical: 10,
  },
  primary: {borderLeftColor: '#319177'},
  success: {borderLeftColor: '#63B76C'},
  info: {borderLeftColor: '#009DC4'},
  warning: {borderLeftColor: '#FCC945'},
  danger: {borderLeftColor: '#DA2C43'},
  dark: {borderLeftColor: '#373d43'},
  basic: {borderLeftColor: '#C4C4C4'},
  textStyle1: {
    fontSize: 16,
    color: '#000',
    fontFamily: 'OpenSans-Bold',
    fontWeight: 700,
  },
  textStyle2: {
    fontSize: 14,
    color: '#000',
    fontFamily: 'OpenSans-SemiBold',
    fontWeight: 600,
  },
};

const toastConfig = {
  primary: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.primary]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  success: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.success]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  info: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.info]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  warning: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.warning]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  danger: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.danger]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  dark: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.dark]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
  basic: props => (
    <BaseToast
      {...props}
      style={[toastStyles.baseStyle, toastStyles.basic]}
      text1Style={toastStyles.textStyle1}
      text2Style={toastStyles.textStyle2}
      text1NumberOfLines={2}
      text2NumberOfLines={3}
      topOffset={100}
    />
  ),
};

export default toastConfig;


--- FILE: src/KQ-UI/KQUtilities.jsx ---

//* KQUtilities.jsx
import {Platform} from 'react-native';

export const useColors = color => {
  if (!color || typeof color !== 'string') return '#000000'; // Default to black

  const colors = {
    black: '#000000',
    white: '#ffffff',
    primary: '#319177',
    success: '#63B76C',
    info: '#009DC4',
    warning: '#FCC945',
    danger: '#DA2C43',
    dark: '#373d43',
    dark90: '#373d4390',
    basic: '#C4C4C4',
  };

  const normalizedColor = color.trim().toLowerCase();

  // If it's a predefined color, return it
  if (colors[normalizedColor]) {
    return colors[normalizedColor];
  }

  // If it's a valid hex or RGB(A) color, return it as is
  if (/^#([0-9A-F]{3}){1,2}$/i.test(color) || color.startsWith('rgb')) {
    return color;
  }

  return '#000000'; // Default fallback
};

const fontLookup = {
  // NotoSans mappings
  'noto-1': {ios: 'NotoSans', android: 'NotoSans-Thin', weight: 100},
  'noto-2': {ios: 'NotoSans', android: 'NotoSans-ExtraLight', weight: 200},
  'noto-3': {ios: 'NotoSans', android: 'NotoSans-Light', weight: 300},
  'noto-4': {ios: 'NotoSans', android: 'NotoSans-Regular', weight: 400},
  'noto-5': {ios: 'NotoSans', android: 'NotoSans-Medium', weight: 500},
  'noto-6': {ios: 'NotoSans', android: 'NotoSans-SemiBold', weight: 600},
  'noto-7': {ios: 'NotoSans', android: 'NotoSans-Bold', weight: 700},
  'noto-8': {ios: 'NotoSans', android: 'NotoSans-ExtraBold', weight: 800},
  'noto-9': {ios: 'NotoSans', android: 'NotoSans-Black', weight: 900},

  // Montserrat mappings
  'mont-1': {ios: 'Montserrat', android: 'Montserrat-Thin', weight: 100},
  'mont-2': {ios: 'Montserrat', android: 'Montserrat-ExtraLight', weight: 200},
  'mont-3': {ios: 'Montserrat', android: 'Montserrat-Light', weight: 300},
  'mont-4': {ios: 'Montserrat', android: 'Montserrat-Regular', weight: 400},
  'mont-5': {ios: 'Montserrat', android: 'Montserrat-Medium', weight: 500},
  'mont-6': {ios: 'Montserrat', android: 'Montserrat-SemiBold', weight: 600},
  'mont-7': {ios: 'Montserrat', android: 'Montserrat-Bold', weight: 700},
  'mont-8': {ios: 'Montserrat', android: 'Montserrat-ExtraBold', weight: 800},
  'mont-9': {ios: 'Montserrat', android: 'Montserrat-Black', weight: 900},

  // OpenSans mappings
  'open-3': {ios: 'OpenSans-Light', android: 'OpenSans-Light', weight: 300},
  'open-4': {ios: 'OpenSans-Regular', android: 'OpenSans-Regular', weight: 400},
  'open-5': {ios: 'OpenSans-Medium', android: 'OpenSans-Medium', weight: 500}, // Default
  'open-6': {
    ios: 'OpenSans-SemiBold',
    android: 'OpenSans-SemiBold',
    weight: 600,
  },
  'open-7': {ios: 'OpenSans-Bold', android: 'OpenSans-Bold', weight: 700},
  'open-8': {
    ios: 'OpenSans-ExtraBold',
    android: 'OpenSans-ExtraBold',
    weight: 800,
  },

  // Special cases (no weight variations)
  cherry: {
    ios: 'CherryBlossom',
    android: 'Cherry-Blossom',
    weight: 500,
  },
  banana: {
    ios: 'BananaChips-Regular',
    android: 'BananaChips-Regular',
    weight: 500,
    lineHeightFactor: 0.8, // Adjusts large vertical space
  },
};

// Default settings
const DEFAULT_FONT = 'open-5';

export const useFonts = (font = DEFAULT_FONT) => {
  const normalizedFont = font.trim().toLowerCase();
  const fontData = fontLookup[normalizedFont] || fontLookup[DEFAULT_FONT];

  return Platform.OS === 'ios'
    ? {fontFamily: fontData.ios, fontWeight: fontData.weight}
    : {fontFamily: fontData.android};
};

export const useFontSizes = (size = 'medium', font = 'OpenSans') => {
  const sizes = {
    tiny: 12,
    xSmall: 14,
    small: 16,
    medium: 18, // Default
    large: 20,
    xLarge: 24,
    giant: 28,
    massive: 36,
    gargantuan: 48,
  };

  // Scaling factors based on font
  const fontScale = {
    cherry: 1.1, // Slightly larger
    banana: 2, // Twice the size
  };

  const baseSize = sizes[size] || sizes.medium;
  const scaleFactor = fontScale[font.toLowerCase()] || 1;
  return {fontSize: baseSize * scaleFactor};
};

export const useFontStyles = (
  font = 'open-5',
  size = 'medium',
  color = 'black',
) => {
  return {
    ...useFonts(font), // âœ… Returns { fontFamily, fontWeight }
    ...useFontSizes(size, font), // âœ… Returns { fontSize }
    color: useColors(color), // âœ… Assign color as a string
  };
};

export const useButtonStyles = (type = 'filled', color = 'primary') => {
  const statusColor = useColors(color);

  const styles = {
    filled: {
      backgroundColor: statusColor,
      elevation: 3,
      shadowColor: '#373d43',
      shadowOffset: {width: 2, height: 3},
      shadowOpacity: 0.3,
    },
    outline: {
      backgroundColor: 'transparent',
      borderColor: statusColor,
      borderWidth: 2,
    },
    ghost: {
      backgroundColor: 'transparent',
    },
  };

  return styles[type] || styles.filled;
};

export const useButtonSizes = (size = 'medium') => {
  const sizes = {
    tiny: 30,
    small: 35,
    medium: 40,
    large: 50,
    giant: 60,
  };

  return {
    height: sizes[size] ?? sizes.medium,
    paddingHorizontal: 12,
  };
};


--- FILE: src/KQ-UI/index.js ---

//* index.js (KQ-UI)
export {default as Text} from './KQText';
export {default as BottomSheet} from './KQBottomSheet';
export {default as Toast} from './KQToast';
export {default as Layout} from './KQLayout';
export {default as Modal} from './KQModal';
export {default as Button} from './KQButton';
export {default as Input} from './KQInput';
export {default as Dropdown} from './KQDropdown';
export {default as ScrollView} from './KQScrollView';


--- FILE: src/components/CurvedBottomBar.jsx ---

//*CurvedBottomBar.jsx
import React from 'react';
import Svg, {
  Path,
  Defs,
  Filter,
  FeOffset,
  FeGaussianBlur,
  FeMerge,
  FeMergeNode,
} from 'react-native-svg';

const CurvedBottomBar = props => {
  const {
    width = width || 500,
    height = height || 60,
    fill = fill || '#fff',
    stroke = stroke || '#373d4370',
    strokeWidth = strokeWidth || 1,
    shadowStroke = shadowStroke || '#373d4360',
    shadowStrokeWidth = shadowStrokeWidth || 2,
  } = props;

  const startX = 0;
  const endX = width - 0;
  const topY = 2;
  const bottomY = height;

  const leftCurveStartX = width / 2 - 65;
  const leftCurveEndX = width / 2 - 30;
  const rightCurveStartX = width / 2 + 30;
  const rightCurveEndX = width / 2 + 65;

  const d = `
  M ${startX},${bottomY}
  L ${startX},20
  C ${startX},20 ${topY},${topY} 25,${topY}
  L ${leftCurveStartX},${topY}
  C ${leftCurveStartX},${topY} ${width / 2 - 40},${topY} ${leftCurveEndX},25
  C ${width / 2 - 25},38 ${width / 2 - 15},44 ${width / 2},44
  C ${width / 2 + 15},44 ${width / 2 + 25},38 ${rightCurveStartX},25
  C ${width / 2 + 40},${topY} ${rightCurveEndX},${topY} ${rightCurveEndX},${topY}
  L ${endX - 20},${topY}
  C ${endX - 25},${topY} ${endX - 2},${topY} ${endX},20
  L ${endX},${bottomY}`;

  return (
    <Svg width={width} height={height}>
      <Defs>
        <Filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
          <FeOffset dx="0" dy="3" />
          <FeGaussianBlur stdDeviation="3" result="blurred" />
          <FeMerge>
            <FeMergeNode in="blurred" />
            <FeMergeNode in="SourceGraphic" />
          </FeMerge>
        </Filter>
      </Defs>

      <Path
        d={d}
        fill="none"
        stroke={shadowStroke}
        strokeWidth={shadowStrokeWidth}
        filter="url(#shadow)"
      />

      <Path d={d} fill={fill} stroke={stroke} strokeWidth={strokeWidth} />
    </Svg>
  );
};

export default CurvedBottomBar;


--- FILE: src/components/FlashCell.jsx ---

//* FlashCell.jsx
import React from 'react';
import {Pressable, View} from 'react-native';
import {Text} from '../KQ-UI';
import {
  displayMeasurements,
  formatMeasurement,
} from '../utilities/measurements';
import pluralize from 'pluralize';
import {Icons} from './IconListRouter';

const FlashCell = props => {
  const {
    item,
    core,
    setShowItemInfo,
    setSelectedItem,
    cupboardView,
    groupedView,
    noQuantity,
  } = props;

  const renderDisplayText = item => {
    const flashCellOrder = core?.userSettings?.flashCellOrder || [];
    const displayText = flashCellOrder
      .map(field => item[field.key])
      .filter(Boolean)
      .join(' ');

    return displayText || item.itemName;
  };

  const formatMeasurementWithPlural = (packageSize, measurement, itemName) => {
    if (packageSize !== undefined && measurement !== undefined) {
      if (packageSize === 1 && measurement === 'each') {
        return '';
      }

      if (measurement === 'each') {
        return `${packageSize} ${pluralize(itemName)}`;
      }

      const match = displayMeasurements.find(m => m.key === measurement);

      if (match) {
        const label = match.label;
        return `${packageSize} ${packageSize > 1 ? pluralize(label) : label}`;
      }

      // Custom value fallback
      const formatted = formatMeasurement(measurement);
      return `${packageSize} ${
        packageSize > 1 ? pluralize(formatted) : formatted
      }`;
    }

    return '';
  };

  const displayRemaining = (packageSize, remainingAmount) => {
    let percent = (remainingAmount / packageSize) * 100;
    return ` (${percent.toFixed(0)}% left)`;
  };

  const QuantityDisplay = () => {
    if (noQuantity) {
      return null;
    }
    return (
      <View style={styles.qtyWrapper}>
        <View style={styles.qtyContainer}>
          <View style={styles.qtyTop}>
            <Text size="tiny">Qty</Text>
          </View>
          <View style={styles.qtyBottom}>
            <Text size="medium" numberOfLines={1}>
              {item.quantity || item.count}
            </Text>
          </View>
        </View>
      </View>
    );
  };

  const InfoDisplay = () => {
    return (
      <View style={styles.display}>
        <Text numberOfLines={1} size="small" font="open-7">
          {renderDisplayText(item)}
        </Text>
        <Text size="xSmall" numberOfLines={1}>
          {formatMeasurementWithPlural(
            item.packageSize,
            item.measurement,
            item.itemName,
          )}
          {item?.remainingAmount &&
            displayRemaining(item.packageSize, item.remainingAmount)}
        </Text>
      </View>
    );
  };

  const SlideDisplay = () => {
    if (cupboardView && groupedView) {
      return null;
    }
    return (
      <View style={styles.slideWrapper}>
        <View style={styles.slideLeft}>
          <Icons.ChevronLeft color="#373d4390" />
        </View>
        <View style={styles.slideRight}>
          <Icons.ChevronLeft color="#373d4390" />
        </View>
      </View>
    );
  };

  return (
    <Pressable
      onPress={() => {
        setSelectedItem(item);
        setShowItemInfo(true);
      }}>
      <View style={styles.cellContainer}>
        <QuantityDisplay />
        <InfoDisplay />
        <SlideDisplay />
      </View>
    </Pressable>
  );
};

const styles = {
  cellContainer: {
    borderBottomWidth: 1,
    borderColor: '#373d4380',
    flexDirection: 'row',
    marginLeft: 10,
    marginRight: 10,
    height: 65,
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  qtyWrapper: {
    height: 60,
    width: 60,
    justifyContent: 'center',
    alignItems: 'center',
  },
  qtyContainer: {
    width: 50,
    height: 50,
    borderWidth: 1.25,
    borderColor: '#373d4380',
    borderRadius: 8,
    flexDirection: 'column',
    elevation: 5,
    shadowColor: '#373d4380',
    shadowOffset: {width: 0, height: 1},
    shadowOpacity: 0.2,
    backgroundColor: '#fff',
  },
  qtyTop: {
    alignItems: 'center',
    paddingTop: 2,
  },
  qtyBottom: {
    flex: 1,
    alignItems: 'center',
    paddingBottom: 1,
  },
  display: {flex: 1, justifyContent: 'center', marginLeft: 5},
  slideWrapper: {
    width: 35,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
  },
  slideLeft: {position: 'absolute', left: 6},
  slideRight: {position: 'absolute', left: 12},
};

export default __DEV__ ? FlashCell : React.memo(FlashCell);


--- FILE: src/components/IconListRouter.jsx ---

//*IconListRouter.jsx
import ADIcons from 'react-native-vector-icons/AntDesign';
import FAIcons from 'react-native-vector-icons/FontAwesome';
import FA5Icons from 'react-native-vector-icons/FontAwesome5';
import MCIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import MIIcons from 'react-native-vector-icons/MaterialIcons';
import IIcons from 'react-native-vector-icons/Ionicons';
import EIcons from 'react-native-vector-icons/Entypo';
import FIcons from 'react-native-vector-icons/Fontisto';
import FEIcons from 'react-native-vector-icons/Feather';
import SIIcons from 'react-native-vector-icons/SimpleLineIcons';
import MIcons from 'react-native-vector-icons/MaterialIcons';
import ZOIcons from 'react-native-vector-icons/Zocial';
import {Keyboard} from 'react-native';

export const Icons = {
  Account: props => (
    <MCIcons name="account-circle" size={20} color="#000" {...props} />
  ),
  AddList: props => (
    <MCIcons name="playlist-plus" size={20} color="#000" {...props} />
  ),
  Back: props => (
    <MIIcons name="arrow-back-ios" size={20} color="#000" {...props} />
  ),
  Barcode: props => (
    <FAIcons name="barcode" size={20} color="#000" {...props} />
  ),
  Check: props => <FA5Icons name="check" size={20} color="#000" {...props} />,
  ChevronDown: props => (
    <FEIcons name="chevron-down" size={20} color="#000" {...props} />
  ),
  ChevronUp: props => (
    <FEIcons name="chevron-up" size={20} color="#000" {...props} />
  ),
  ChevronLeft: props => (
    <FEIcons name="chevron-left" size={20} color="#000" {...props} />
  ),
  CirclePlus: props => (
    <ADIcons name="pluscircleo" size={20} color="#000" {...props} />
  ),
  Close: props => <MCIcons name="close" size={20} color="#000" {...props} />,
  Cupboards: props => (
    <MCIcons name="wardrobe" size={20} color="#000" {...props} />
  ),
  Dev: props => <MCIcons name="dev-to" size={20} color="#000" {...props} />,
  Edit: props => <MIIcons name="edit-note" size={20} color="#000" {...props} />,
  EyeOn: props => <MCIcons name="eye" size={20} color="#000" {...props} />,
  EyeOff: props => <MCIcons name="eye-off" size={20} color="#000" {...props} />,
  Favorite: props => <MCIcons name="star" size={20} color="#000" {...props} />,
  Filter: props => (
    <IIcons name="filter-outline" size={20} color="#000" {...props} />
  ),
  Forward: props => (
    <MIIcons name="arrow-forward-ios" size={20} color="#000" {...props} />
  ),
  Home: props => <MCIcons name="home" size={20} color="#000" {...props} />,
  Help: props => (
    <MCIcons name="help-circle" size={20} color="#000" {...props} />
  ),
  Keyboard: props => (
    <MCIcons name="keyboard-variant" size={20} color="#000" {...props} />
  ),
  Menu: props => <FEIcons name="menu" size={20} color="#000" {...props} />,
  MenuList: props => <MCIcons name="menu" size={20} color="#000" {...props} />,
  LightOn: props => (
    <MIIcons name="flashlight-on" size={20} color="#000" {...props} />
  ),
  LightOff: props => (
    <MIIcons name="flashlight-off" size={20} color="#000" {...props} />
  ),
  Logout: props => <MIIcons name="logout" size={20} color="#000" {...props} />,
  Merge: props => (
    <MCIcons name="set-merge" size={20} color="#000" {...props} />
  ),
  Plus: props => <MCIcons name="plus" size={20} color="#000" {...props} />,
  Profile: props => (
    <ADIcons name="profile" size={20} color="#000" {...props} />
  ),
  Recipe: props => (
    <MCIcons name="treasure-chest" size={20} color="#000" {...props} />
  ),
  Save: props => (
    <MCIcons name="content-save" size={20} color="#000" {...props} />
  ),
  Search: props => <MIIcons name="search" size={20} color="#000" {...props} />,
  Settings: props => (
    <FA5Icons name="wrench" size={20} color="#000" {...props} />
  ),
  Shopping: props => (
    <FAIcons name="shopping-cart" size={20} color="#000" {...props} />
  ),
  Split: props => (
    <MCIcons name="set-split" size={20} color="#000" {...props} />
  ),
  Wave: props => <MCIcons name="wave" size={20} color="#000" {...props} />,
  Waves: props => <MCIcons name="waves" size={20} color="#000" {...props} />,
};


--- FILE: src/components/NavHeader.jsx ---

//*NavHeader.jsx
import React, {useCallback} from 'react';
import {Alert, TouchableOpacity, View} from 'react-native';
import {useNavigation} from '@react-navigation/native';
import {Text} from '../KQ-UI';
import {Icons} from './IconListRouter';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {useDispatch} from 'react-redux';
import {useShoppingCart} from '../hooks/useHooks';
import {NavHeaderStyles} from '../styles/Styles';
import {useCoreInfo} from '../utilities/coreInfo';

const NavHeader = ({
  title = '',
  headerColor = '#319177',
  textColor = '#000',
  LeftButton = 'None',
  RightButton = 'None',
  LeftAction,
  RightAction,
  sheetOpen,
}) => {
  const navigation = useNavigation();
  const useHaptics = setHapticFeedback();
  const dispatch = useDispatch();
  const shopping = useShoppingCart();
  const core = useCoreInfo();
  let fadeText = '#ffffff60';

  const cartList =
    shopping?.items?.filter(item => item.status === 'shopping-cart') ?? [];

  const handleSignOut = useCallback(() => {
    Alert.alert('Logging Out', 'Are you sure you want to logout?', [
      {text: 'Cancel', style: 'destructive'},
      {
        text: 'Confirm',
        onPress: () => {
          useHaptics(core?.userSettings?.hapticStrength || 'light');
          dispatch({type: 'LOGOUT_AND_CLEAR'});
        },
      },
    ]);
  }, [core?.userSettings?.hapticStrength, dispatch]);

  const NavButtonComponent = ({
    position,
    action,
    navigate,
    goBack,
    title,
    icon,
  }) => {
    const handlePress = useCallback(() => {
      if (navigate) navigation.navigate(navigate);
      if (goBack) navigation.goBack();
      if (action) action();
      useHaptics(core?.userSettings?.hapticStrength || 'light');
    }, [navigate, goBack, action, core?.userSettings?.hapticStrength]);

    const isLeft = position === 'Left';

    if (sheetOpen) {
      return (
        <View
          style={[
            isLeft ? NavHeaderStyles.leftWrapper : NavHeaderStyles.rightWrapper,
            {flex: 1},
          ]}>
          {isLeft && icon && (
            <View style={NavHeaderStyles.iconPosition}>{icon}</View>
          )}
          <View
            style={
              isLeft
                ? NavHeaderStyles.leftContainer
                : NavHeaderStyles.rightContainerAlt
            }>
            {title && (
              <Text style={{color: sheetOpen ? fadeText : textColor}}>
                {title}
              </Text>
            )}
          </View>
          {!isLeft && icon && (
            <View style={NavHeaderStyles.iconPosition}>{icon}</View>
          )}
        </View>
      );
    } else {
      return (
        <TouchableOpacity onPress={handlePress}>
          <View
            style={
              isLeft
                ? NavHeaderStyles.leftWrapper
                : NavHeaderStyles.rightWrapper
            }>
            {isLeft && icon && (
              <View style={NavHeaderStyles.iconPosition}>{icon}</View>
            )}
            <View
              style={
                isLeft
                  ? NavHeaderStyles.leftContainer
                  : NavHeaderStyles.rightContainerAlt
              }>
              {title && <Text style={{color: textColor}}>{title}</Text>}
            </View>
            {!isLeft && icon && (
              <View style={NavHeaderStyles.iconPosition}>{icon}</View>
            )}
          </View>
        </TouchableOpacity>
      );
    }
  };

  // âœ… Toggle memo for NavButton
  const NavButton = __DEV__
    ? NavButtonComponent
    : React.memo(NavButtonComponent);

  const renderButton = (buttonType, position) => {
    if (!buttonType || buttonType === 'None') return null;

    const allowedLeftButtons = [
      'Back',
      'Cancel',
      'Cancel-WA',
      'Cancel-Scan',
      'Close',
      'Merge',
      'Split',
      'To-List',
    ];
    const allowedRightButtons = [
      'Scan',
      'Checkout',
      'Edit',
      'Logout',
      'Save',
      'Submit',
      'To-Cart',
      'Torch-On',
      'Torch-Off',
      'Update',
    ];

    if (
      (position === 'Left' && !allowedLeftButtons.includes(buttonType)) ||
      (position === 'Right' && !allowedRightButtons.includes(buttonType))
    ) {
      console.warn(
        `Invalid placement: Button "${buttonType}" is not allowed on the ${position} side.`,
      );
      return null;
    }

    const buttonProps = {
      position,
      title: '',
      icon: null,
      action: null,
      navigate: null,
      goBack: false,
      showCondition: true,
    };

    switch (buttonType) {
      case 'Back':
        buttonProps.title = 'Back';
        buttonProps.icon = (
          <Icons.Back size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.goBack = true;
        break;

      case 'Cancel':
        buttonProps.title = 'Cancel';
        buttonProps.goBack = true;
        break;

      case 'Cancel-WA':
        buttonProps.title = 'Cancel';
        buttonProps.action = () => LeftAction();
        break;

      case 'Cancel-Scan':
        buttonProps.title = 'Cancel';
        buttonProps.action = () => LeftAction();
        break;

      case 'Checkout':
        buttonProps.title = 'Checkout';
        buttonProps.showCondition = cartList?.length > 0;
        buttonProps.icon = (
          <Icons.Forward size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Close':
        buttonProps.title = 'Close';
        buttonProps.action = () => LeftAction();
        break;

      case 'Edit':
        buttonProps.title = 'Edit';
        buttonProps.icon = (
          <Icons.Edit size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Logout':
        buttonProps.title = 'Logout';
        buttonProps.icon = (
          <Icons.Logout size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = handleSignOut;
        break;

      case 'Merge':
        buttonProps.title = 'Grouped';
        buttonProps.navigate = 'CupboardList-Single';
        buttonProps.icon = (
          <View style={{marginRight: 5}}>
            <Icons.Merge size={25} color={sheetOpen ? fadeText : textColor} />
          </View>
        );
        break;

      case 'Save':
        buttonProps.title = 'Save';
        buttonProps.icon = (
          <Icons.Save size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Scan':
        buttonProps.title = 'Scan';
        buttonProps.icon = (
          <Icons.Barcode size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      case 'Split':
        buttonProps.title = 'Single';
        buttonProps.navigate = 'CupboardList-Group';
        buttonProps.icon = (
          <View style={{marginRight: 5}}>
            <Icons.Split size={25} color={sheetOpen ? fadeText : textColor} />
          </View>
        );
        break;

      case 'To-Cart':
        buttonProps.title = 'Cart';
        buttonProps.navigate = 'ShoppingCart';
        buttonProps.icon = <Icons.Forward size={20} color={textColor} />;
        buttonProps.showCondition = cartList?.length > 0;
        break;

      case 'To-List':
        buttonProps.title = 'List';
        buttonProps.navigate = 'ShoppingList';
        buttonProps.icon = (
          <Icons.Back size={20} color={sheetOpen ? fadeText : textColor} />
        );
        break;
      case 'Torch-On':
        buttonProps.title = 'Light On';
        buttonProps.icon = (
          <Icons.LightOn size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;
      case 'Torch-Off':
        buttonProps.title = 'Light Off';
        buttonProps.icon = (
          <Icons.LightOff size={20} color={sheetOpen ? fadeText : textColor} />
        );
        buttonProps.action = () => RightAction();
        break;

      default:
        console.warn(`Unknown buttonType: "${buttonType}"`);
        return null;
    }

    if (!buttonProps.showCondition) return null;

    return <NavButton {...buttonProps} />;
  };

  return (
    <View
      style={[
        NavHeaderStyles.header,
        {backgroundColor: headerColor ?? '#fff', height: 50},
      ]}>
      <View style={NavHeaderStyles.titleContainer}>
        <Text style={{color: textColor}}>{title}</Text>
      </View>
      <View style={NavHeaderStyles.buttonContainer}>
        <View style={NavHeaderStyles.buttonRows}>
          <View style={NavHeaderStyles.sideContainers}>
            {renderButton(LeftButton, 'Left')}
          </View>
          <View style={NavHeaderStyles.sideContainers}>
            {renderButton(RightButton, 'Right')}
          </View>
        </View>
      </View>
    </View>
  );
};

export default __DEV__ ? NavHeader : React.memo(NavHeader);


--- FILE: src/components/NavMenu.jsx ---

//*NavMenu.jsx
import React, {useMemo} from 'react';
import {Alert, TouchableOpacity, View} from 'react-native';
import CurvedBottomBar from './CurvedBottomBar';
import {Icons} from '../components/IconListRouter';
import {useNavigation} from '@react-navigation/native';
import {getNavBarHeight} from '../utilities/deviceUtils';
import {
  CurvedBarStyles,
  MenuButtonStyles,
  NavMenuStyles,
} from '../styles/Styles';
import {Text} from '../KQ-UI';
import {useCoreInfo} from '../utilities/coreInfo';
import {setHapticFeedback} from '../hooks/setHapticFeedback';

const NavMenu = props => {
  const {bottomHeight, bottomWidth, toggleMenu, device, setIsSheetOpen} = props;
  const core = useCoreInfo();
  const useHaptics = setHapticFeedback();
  const navigation = useNavigation();

  const navHeight = useMemo(
    () => getNavBarHeight(device, bottomHeight),
    [device, bottomHeight],
  );

  const userItems = [
    {
      id: 'shopping',
      title: 'Shopping',
      icon: <Icons.Shopping size={25} color={'#000'} />,
      screen: 'ShoppingList',
    },
    {
      id: 'cupboard',
      title: 'Cupboard',
      icon: <Icons.Cupboards size={25} color={'#000'} />,
      screen: 'CupboardList-Single',
    },
  ];

  const getNavBarLayout = (items = []) => {
    const requiredItems = [
      {
        id: 'home',
        title: 'Home',
        icon: <Icons.Home size={27} color={'#000'} />,
        screen: 'Home',
      },
      {
        id: 'account',
        title: 'Account',
        icon: <Icons.Account size={25} color={'#000'} />,
        screen: 'Account',
      },
    ];

    // Combine required and user items, Home first, Account last
    let allItems = [requiredItems[0], ...items, requiredItems[1]];

    // Ensure odd number of slots (to keep center slot open)
    if (allItems.length % 2 === 0) {
      allItems.splice(Math.floor(allItems.length / 2), 0, {id: 'spacer'}); // Center spacer
    }

    return allItems;
  };

  const navItems = getNavBarLayout(userItems);

  const handleNavPress = item => {
    useHaptics(core?.userSettings?.hapticStrength || 'light');
    setIsSheetOpen(false);
    const allowedScreens = [
      'Home',
      'ShoppingList',
      'CupboardList-Single',
      'Account',
    ];

    if (allowedScreens.includes(item.screen)) {
      navigation.navigate(item.screen);
    } else {
      Alert.alert('Coming Soon', `${item.title} screen not yet available.`);
    }
  };

  return (
    <View style={NavMenuStyles.container}>
      <View style={{height: navHeight}}>
        <CurvedBottomBar
          height={bottomHeight}
          width={bottomWidth}
          fill={CurvedBarStyles.fillColor}
          stroke={CurvedBarStyles.strokeColor}
          strokeWidth={CurvedBarStyles.strokeWidth}
          shadowStroke={CurvedBarStyles.shadowStroke}
          shadowStrokeWidth={CurvedBarStyles.shadowStrokeWidth}
        />
        <View style={MenuButtonStyles.wrapper}>
          {navItems.map((item, index) => {
            if (item.id === 'spacer') {
              return (
                <View key={index} style={MenuButtonStyles.container}>
                  <TouchableOpacity
                    style={MenuButtonStyles.button}
                    onPress={toggleMenu}>
                    <Icons.Menu size={30} color={'#fff'} />
                  </TouchableOpacity>
                </View>
              );
            }
            return (
              <TouchableOpacity
                key={index}
                onPress={() => handleNavPress(item)}
                style={MenuButtonStyles.menuButton}>
                {item.icon}
                <Text size="tiny" font="open-6">
                  {item.title}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>
      </View>
    </View>
  );
};

export default NavMenu;


--- FILE: src/components/SelectedItemInfo.jsx ---

//* SelectedItemInfo.jsx
import {useNavigation} from '@react-navigation/native';
import React from 'react';
import {View} from 'react-native';
import {ListStyles, SelectItemStyles} from '../styles/Styles';
import {categoryColors, formatCategories} from '../utilities/categories';
import {formatMeasurement} from '../utilities/measurements';
import {Button, Text, ScrollView} from '../KQ-UI';

const SelectedItemInfo = props => {
  const {
    selectedItem,
    setShowItemInfo,
    navigate,
    groupedView = false,
    cupboardView = false,
  } = props;
  console.log('selectedItem', selectedItem);

  const navigation = useNavigation();

  const handleUpdateItem = itemId => {
    navigation.navigate(navigate?.to, {
      itemId,
      navigateBackTo: navigate?.backTo,
    });
    setShowItemInfo(false);
  };

  const ItemRow = ({title, info, info2}) => {
    const asNote = title === 'Notes';
    const remain = title === 'Remaining Amount' || title === 'Total Remaining';

    if (!info) {
      return null;
    } else {
      return (
        <View
          style={
            asNote
              ? SelectItemStyles.itemNoteContainer
              : SelectItemStyles.itemContainer
          }>
          <View style={SelectItemStyles.titleWrap}>
            <Text size="small">{title}:</Text>
          </View>
          <View
            style={[
              asNote
                ? SelectItemStyles.infoNoteWrap
                : SelectItemStyles.infoWrap,
            ]}>
            <Text
              size="small"
              style={[
                asNote
                  ? SelectItemStyles.textNoteStyles
                  : SelectItemStyles?.textStyles,
              ]}
              numberOfLines={asNote ? 0 : 1}>
              {info}
            </Text>
          </View>
          {remain && (
            <View>
              <Text size="small" style={{paddingTop: 3, paddingHorizontal: 1}}>
                ({((info / info2) * 100).toFixed(0)}% left)
              </Text>
            </View>
          )}
        </View>
      );
    }
  };

  const BannerField = ({children, backgroundColor}) => {
    return (
      <View
        style={{
          marginHorizontal: 5,
          marginBottom: 5,
          borderRadius: 10,
          backgroundColor: backgroundColor || '#319177',
          alignItems: 'center',
          justifyContent: 'center',
        }}>
        <Text
          font="banana"
          centered
          style={{
            fontSize: 65,
            color: 'white',
            position: 'relative',
            top: -9,
          }}
          numberOfLines={1}>
          {children}
        </Text>
      </View>
    );
  };

  return (
    <View style={{flex: 1}}>
      {selectedItem && (
        <View style={SelectItemStyles.container}>
          <BannerField backgroundColor={categoryColors(selectedItem?.category)}>
            {formatCategories(selectedItem?.category)}
          </BannerField>
          {groupedView ? (
            <View
              style={{
                marginHorizontal: 5,
                padding: 5,
              }}>
              <Text centered size="xSmall">
                Can't update grouped items.
              </Text>
              <Text centered size="xSmall">
                Please close and select single view.
              </Text>
            </View>
          ) : (
            <View style={SelectItemStyles.updateContainer}>
              <Button
                color="info"
                type="outline"
                size="small"
                onPress={() => handleUpdateItem(selectedItem?.itemId)}>
                Update Item
              </Button>
            </View>
          )}
          <ScrollView contentContainerStyle={SelectItemStyles.infoContainer}>
            <ItemRow title="Item Name" info={selectedItem?.itemName} />
            <ItemRow title="Brand" info={selectedItem?.brandName} />
            <ItemRow title="Description" info={selectedItem?.description} />
            {!cupboardView && (
              <ItemRow title="Quantity" info={selectedItem?.quantity} />
            )}
            <ItemRow
              title={groupedView ? 'Total Remaining' : 'Remaining Amount'}
              info={selectedItem?.remainingAmount}
              info2={selectedItem?.packageSize}
            />
            <ItemRow
              title={groupedView ? 'Total Package Size' : 'Package Size'}
              info={selectedItem?.packageSize}
            />
            <ItemRow
              title="Measurement"
              info={formatMeasurement(selectedItem?.measurement)}
            />
            {selectedItem?.notes && (
              <ItemRow title="Notes" info={selectedItem?.notes} />
            )}
          </ScrollView>
        </View>
      )}
    </View>
  );
};

export default SelectedItemInfo;


--- FILE: src/components/SplashScreen.jsx ---

//*SplashScreen.jsx
import React from 'react';
import {View, Text, StyleSheet, ActivityIndicator, Image} from 'react-native';

const SplashScreen = () => {
  const logo = require('../images/AppLogo_350.png');
  return (
    <View style={styles.container}>
      <View style={{marginBottom: -24}}>
        <Image source={logo} style={styles.image} />
      </View>
      <View style={{position: 'absolute', top: '44%', left: '50%'}}>
        <ActivityIndicator size="large" color="#319177" />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 36,
    padding: 5,
    fontFamily: 'Montserrat-Bold',
  },
  indicator: {
    marginVertical: 5,
    paddingTop: 8,
    paddingBottom: 5,
    paddingLeft: 8,
    paddingRight: 6,
  },
  image: {},
});

export default SplashScreen;


--- FILE: src/components/SwipeableItem.jsx ---

//* SwipeableItem.jsx
import {FlashList} from '@shopify/flash-list';
import React, {useCallback, useEffect, useRef} from 'react';
import FlashCell from './FlashCell';
import Swipeable from 'react-native-gesture-handler/ReanimatedSwipeable';
import {setHapticFeedback} from '../hooks/setHapticFeedback';
import {ListStyles} from '../styles/Styles';
import {Animated, TouchableOpacity, View} from 'react-native';
import {Text} from '../KQ-UI';

const SwipeableItem = props => {
  const {
    list,
    core,
    showItemInfo,
    setSelectedItem,
    setShowItemInfo,
    leftButtons = [],
    rightButtons = [],
    cupboardView = false,
    groupedView = false,
    noQuantity = false,
  } = props;

  const swipeableRefs = useRef(new Map());
  const currentlyOpenRef = useRef(null);
  const useHaptics = setHapticFeedback();

  const closeSwipeable = itemId => {
    const swipeableRef = swipeableRefs.current.get(itemId);
    if (swipeableRef) {
      swipeableRef.close();
    }
  };

  const handleSwipeableOpen = itemId => {
    if (currentlyOpenRef.current && currentlyOpenRef.current !== itemId) {
      closeSwipeable(currentlyOpenRef.current);
    }
    currentlyOpenRef.current = itemId;
  };

  useEffect(() => {
    if (showItemInfo && currentlyOpenRef.current) {
      const ref = swipeableRefs.current.get(currentlyOpenRef.current);
      if (ref) {
        ref.close();
        currentlyOpenRef.current = null;
      }
    }
  }, [showItemInfo]);

  useEffect(() => {
    return () => {
      swipeableRefs.current.clear();
      currentlyOpenRef.current = null;
    };
  }, []);

  const closeAllSwipeables = () => {
    swipeableRefs.current.forEach(ref => {
      if (ref && typeof ref.close === 'function') {
        ref.close();
      }
    });
    currentlyOpenRef.current = null;
  };

  const renderRightActions = itemId => {
    if (rightButtons.length === 0) return null;

    return (
      <View style={ListStyles.actionsContainer}>
        {rightButtons.map((button, index) => (
          <Animated.View
            key={index}
            style={[ListStyles.actionButton, button.style]}>
            <TouchableOpacity
              onPress={() => {
                button.action(itemId);
                closeSwipeable(itemId);
                useHaptics(core?.userSettings?.hapticStrength || 'light');
              }}>
              <View style={ListStyles.buttonContainer}>
                <Text size="xSmall" font="open-7" kqColor="white">
                  {button.text1}
                </Text>
                {button.text2 && (
                  <Text size="xSmall" font="open-7" kqColor="white">
                    {button.text2}
                  </Text>
                )}
              </View>
            </TouchableOpacity>
          </Animated.View>
        ))}
      </View>
    );
  };

  const renderLeftActions = itemId => {
    if (leftButtons.length === 0) return null;

    return (
      <View style={ListStyles.actionsContainer}>
        {leftButtons.map((button, index) => (
          <Animated.View
            key={index}
            style={[ListStyles.actionButton, button.style]}>
            <TouchableOpacity
              onPress={() => {
                button.action(itemId);
                closeSwipeable(itemId);
                useHaptics(core?.userSettings?.hapticStrength || 'light');
              }}>
              <View style={ListStyles.buttonContainer}>
                <Text size="xSmall" font="open-7" kqColor="white">
                  {button.text1}
                </Text>
                {button.text2 && (
                  <Text size="xSmall" font="open-7" kqColor="white">
                    {button.text2}
                  </Text>
                )}
              </View>
            </TouchableOpacity>
          </Animated.View>
        ))}
      </View>
    );
  };

  const renderSwipeableItem = useCallback(
    ({item}) => (
      <Swipeable
        ref={ref => swipeableRefs.current.set(item.itemId, ref)}
        onSwipeableOpen={() => handleSwipeableOpen(item.itemId)}
        renderRightActions={() => renderRightActions(item.itemId)}
        renderLeftActions={() => renderLeftActions(item.itemId)}
        rightThreshold={200}
        leftThreshold={200}
        friction={1}
        overshootFriction={8}>
        <FlashCell
          item={item}
          core={core}
          setSelectedItem={setSelectedItem}
          setShowItemInfo={setShowItemInfo}
          showItemInfo={showItemInfo}
          closeAllSwipeables={closeAllSwipeables}
          cupboardView={cupboardView}
          groupedView={groupedView}
          noQuantity={noQuantity}
        />
      </Swipeable>
    ),
    [setSelectedItem, setShowItemInfo],
  );

  return (
    <FlashList
      data={list}
      renderItem={renderSwipeableItem}
      keyExtractor={item => item.itemId}
      estimatedItemSize={70}
    />
  );
};

export default SwipeableItem;


--- FILE: src/hooks/setHapticFeedback.jsx ---

//*setHapticFeedback.jsx
import HapticFeedback from 'react-native-haptic-feedback';

export const setHapticFeedback = () => {
  const triggerHaptic = props => {
    const options = {
      enableVibrateFallback: true,
      ignoreAndroidSystemSettings: false,
    };
    // console.log('props:', props);
    switch (props) {
      case 'off':
        break;
      case 'light':
        HapticFeedback.trigger('impactLight', options);
        break;
      case 'medium':
        HapticFeedback.trigger('impactMedium', options);
        break;
      case 'heavy':
        HapticFeedback.trigger('impactHeavy', options);
        break;
      case 'success':
        HapticFeedback.trigger('notificationSuccess', options);
        break;
      case 'warning':
        HapticFeedback.trigger('notificationWarning', options);
        break;
      case 'error':
        HapticFeedback.trigger('notificationError', options);
        break;
      default:
        HapticFeedback.trigger('impactLight', options);
        break;
    }
  };

  return triggerHaptic;
};


--- FILE: src/hooks/useHooks.jsx ---

//*useHooks.jsx
import {useSelector} from 'react-redux';

export const useDeviceInfo = () => {
  return useSelector(state => state.deviceInfo?.deviceInfo);
};

export const useAuth = () => {
  return useSelector(state => state.user?.isAuthenticated);
};

export const useUser = () => {
  return useSelector(state => state.user?.data);
};

export const useLoginError = () => {
  return useSelector(state => state.user?.error);
};

export const useProfile = () => {
  return useSelector(state => state.profile?.profile);
};

export const useProfileError = () => {
  return useSelector(state => state.profile?.error);
};

export const useAccount = () => {
  return useSelector(state => state.account?.account);
};

export const useAccountError = () => {
  return useSelector(state => state.account?.error);
};

export const useShoppingCart = () => {
  return useSelector(state => state.shopping?.shopping);
};

export const useShoppingCartError = () => {
  return useSelector(state => state.shopping?.error);
};

export const useCupboard = () => {
  return useSelector(state => state.cupboard?.cupboard);
};

export const useCupboardError = () => {
  return useSelector(state => state.cupboard?.error);
};

export const useAllowedProfiles = () => {
  return useSelector(state => state.account?.allowedProfiles);
};

export const useExistingInvite = () => {
  return useSelector(state => state.invites?.existingInvite || null);
};

export const useFoodData = () => {
  return useSelector(state => state.edamam?.foodData);
};

export const useFoodDataError = () => {
  return useSelector(state => state.edamam?.error);
};

export const useFoodDataLoading = () => {
  return useSelector(state => state.edamam?.loading);
};


--- FILE: src/redux/reducers/_root.reducer.jsx ---

//*_root.reducer.jsx

import {combineReducers} from 'redux';
import userReducer from './user.reducer';
import profileReducer from './profile.reducer';
import accountReducer from './account.reducer';
import shoppingReducer from './shopCart.reducer';
import cupboardReducer from './cupboard.reducer';
import deviceReducer from './device.reducer';
import invitesReducer from './invites.reducer';
import edamamReducer from './edamam.reducer';

const rootReducer = combineReducers({
  user: userReducer,
  profile: profileReducer,
  account: accountReducer,
  shopping: shoppingReducer,
  cupboard: cupboardReducer,
  deviceInfo: deviceReducer,
  invites: invitesReducer,
  edamam: edamamReducer,
});

export default rootReducer;


--- FILE: src/redux/reducers/account.reducer.jsx ---

//* account.reducer.jsx
const initialState = {
  account: null,
  allowedProfiles: [],
  error: null,
};

const accountReducer = (state = initialState, action) => {
  switch (action.type) {
    // âœ… Account set or created
    case 'SET_ACCOUNT':
    case 'ACCOUNT_CREATE_SUCCESS':
      return {...state, account: action.payload, error: null};

    case 'ACCOUNT_CREATE_FAILURE':
    case 'ACCOUNT_FETCH_FAILED':
      return {...state, error: action.payload};

    // âœ… Allowed profiles
    case 'SET_ALLOWED_PROFILES':
      return {...state, allowedProfiles: action.payload};
    case 'FETCH_ALLOWED_PROFILES_FAILED':
      return {...state, error: action.payload};

    // ðŸ”„ Reset
    case 'RESET_ACCOUNT_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default accountReducer;


--- FILE: src/redux/reducers/cupboard.reducer.jsx ---

//* cupboard.reducer.jsx
const initialState = {
  cupboard: null,
  loading: false,
  error: null,
};

const cupboardReducer = (state = initialState, action) => {
  switch (action.type) {
    // ðŸ”„ Fetching
    case 'FETCH_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'SET_CUPBOARD':
      return {...state, cupboard: action.payload, loading: false, error: null};
    case 'CUPBOARD_SET_FAILED': // âœ… fixed name
      return {...state, loading: false, error: action.payload};
    // âž• Add Item
    case 'ADD_ITEM_TO_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_ADD_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // âœï¸ Update Item
    case 'UPDATE_ITEM_IN_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_UPDATE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // âŒ Delete Item
    case 'DELETE_ITEM_FROM_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_DELETE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // âŒ Delete List
    case 'DELETE_LIST_FROM_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_DELETE_LIST_FAILED':
      return {...state, loading: false, error: action.payload};

    // ðŸ“¦ Batch Add
    case 'BATCH_TO_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_BATCH_ADD_START':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_BATCH_ADD_SUCCESS':
      return {...state, loading: false, error: null};
    case 'CUPBOARD_BATCH_ADD_FAILED':
      return {...state, loading: false, error: action.payload};

    // â™»ï¸ Reset
    case 'RESET_CUPBOARD':
      return {...state, loading: true, error: null};
    case 'CUPBOARD_RESET_FAILED':
      return {...state, loading: false, error: action.payload};

    case 'RESET_CUPBOARD_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default cupboardReducer;


--- FILE: src/redux/reducers/device.reducer.jsx ---

//*device.reducer.jsx
const initialState = {
  deviceInfo: null,
  error: null,
};

const deviceReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'SET_DEVICE_INFO':
      return {...state, deviceInfo: action.payload, error: null};
    case 'DEVICE_INFO_FETCH_FAILED':
      return {...state, error: action.payload};
    case 'RESET_DEVICE_INFO_STATE':
      return initialState;
    default:
      return state;
  }
};

export default deviceReducer;


--- FILE: src/redux/reducers/edamam.reducer.jsx ---

//* edamam.reducer.jsx
const initialState = {
  foodData: null,
  error: null,
  loading: false,
};

const edamamReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'FETCH_FOOD_DATA':
      return {...state, loading: true, error: null};

    case 'SET_FOOD_DATA':
      return {...state, foodData: action.payload, loading: false};

    case 'FOOD_API_FETCH_FAILED':
      return {...state, error: action.payload, loading: false};

    case 'RESET_FOOD_DATA':
      return {...initialState};
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default edamamReducer;


--- FILE: src/redux/reducers/invites.reducer.jsx ---

//* invites.reducer.jsx
const initialState = {
  existingInvite: null,
  error: null,
};

const invitesReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'SET_EXISTING_INVITE':
      return {
        ...state,
        existingInvite: action.payload,
        error: null,
      };
    case 'ADD_INVITE':
      return {
        ...state,
        existingInvite: action.payload,
        error: null,
      };
    case 'UPDATE_INVITE':
      return {
        ...state,
        existingInvite: {
          ...state.existingInvite,
          ...action.payload,
        },
        error: null,
      };
    case 'DELETE_INVITE':
      return {
        ...state,
        existingInvite: null,
        error: null,
      };
    case 'CLEAR_EXISTING_INVITE':
      return {
        ...state,
        existingInvite: null,
        error: null,
      };
    case 'INVITE_ACTION_FAILED':
      return {
        ...state,
        error: action.payload,
      };
    default:
      return state;
  }
};

export default invitesReducer;


--- FILE: src/redux/reducers/profile.reducer.jsx ---

//* profile.reducer.jsx
const initialState = {
  profile: null,
  error: null,
};

const profileReducer = (state = initialState, action) => {
  switch (action.type) {
    // âœ… Fetched and set
    case 'SET_PROFILE':
      return {...state, profile: action.payload};

    // âœ… New profile created
    case 'PROFILE_CREATE_SUCCESS':
      return {...state, profile: action.payload, error: null};
    case 'PROFILE_CREATE_FAILURE':
      return {...state, error: action.payload};

    // âœ… Profile updated
    case 'UPDATE_PROFILE_SUCCESS':
      return {
        ...state,
        profile: {
          ...state.profile,
          ...action.payload,
        },
      };
    case 'UPDATE_PROFILE_FAILED':
    case 'PROFILE_FETCH_FAILED':
      return {...state, error: action.payload};

    // ðŸ”„ Reset cases
    case 'RESET_PROFILE_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default profileReducer;


--- FILE: src/redux/reducers/shopCart.reducer.jsx ---

//*shopCart.reducer.jsx
const initialState = {
  shopping: null,
  loading: false,
  error: null,
};

const shoppingReducer = (state = initialState, action) => {
  switch (action.type) {
    // ðŸ”„ Fetching
    case 'FETCH_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SET_SHOP_CART':
      return {...state, shopping: action.payload, loading: false, error: null};
    case 'SHOP_CART_SET_FAILED':
      return {...state, loading: false, error: action.payload};

    // âž• Add Item
    case 'ADD_ITEM_TO_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_ADD_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // âœï¸ Update Item
    case 'UPDATE_ITEM_IN_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_UPDATE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // âŒ Delete Item
    case 'DELETE_ITEM_FROM_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_DELETE_ITEM_FAILED':
      return {...state, loading: false, error: action.payload};

    // âŒ Delete List
    case 'DELETE_LIST_FROM_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_DELETE_LIST_FAILED':
      return {...state, loading: false, error: action.payload};

    // ðŸ“¦ Batch Add
    case 'BATCH_TO_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_BATCH_ADD_START':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_BATCH_ADD_SUCCESS':
      return {...state, loading: false, error: null};
    case 'SHOP_CART_BATCH_ADD_FAILED':
      return {...state, loading: false, error: action.payload};

    // â™»ï¸ Reset
    case 'RESET_SHOP_CART':
      return {...state, loading: true, error: null};
    case 'SHOP_CART_RESET_FAILED':
      return {...state, loading: false, error: action.payload};

    case 'RESET_SHOP_CART_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default shoppingReducer;


--- FILE: src/redux/reducers/user.reducer.jsx ---

//* user.reducer.jsx
const initialState = {
  data: null,
  loading: false,
  error: null,
  isAuthenticated: false,
};

const userReducer = (state = initialState, action) => {
  switch (action.type) {
    // ðŸ” Signup Flow
    case 'USER_SIGNUP_REQUEST':
      return {...state, loading: true, error: null};
    case 'USER_SIGNUP_SUCCESS':
      return {
        ...state,
        data: action.payload,
        loading: false,
        error: null,
        isAuthenticated: true,
      };
    case 'USER_SIGNUP_FAILURE':
      return {
        ...state,
        loading: false,
        error: action.error,
        isAuthenticated: false,
      };

    // ðŸ”“ Login Flow
    case 'LOGIN_REQUEST':
      return {...state, loading: true, error: null};
    case 'SET_USER':
      return {
        ...state,
        data: action.payload,
        loading: false,
        error: null,
        isAuthenticated: true,
      };
    case 'LOGIN_FAILED':
      return {
        ...state,
        loading: false,
        error: action.payload,
        isAuthenticated: false,
      };

    // ðŸ”’ Logout & Reset
    case 'UNSET_USER':
      return {...initialState, loading: false};
    case 'LOGOUT':
      return initialState;
    case 'RESET_USER_STATE':
    case 'RESET_ALL_STATE':
      return initialState;

    default:
      return state;
  }
};

export default userReducer;


--- FILE: src/redux/sagas/_root.saga.jsx ---

import {all, fork} from 'redux-saga/effects';
import userSaga from './user.saga';
import profileSaga from './profile.saga';
import accountSaga from './account.saga';
import shoppingSaga from './shopCart.saga';
import cupboardSaga from './cupboard.saga';
import deviceSaga from './device.saga';
import {invitesSaga} from './invites.saga';
import edamamSaga from './edamam.saga';
import loginSaga from './login.saga';

export default function* rootSaga() {
  yield all([
    fork(userSaga),
    fork(profileSaga),
    fork(accountSaga),
    fork(shoppingSaga),
    fork(cupboardSaga),
    fork(deviceSaga),
    fork(invitesSaga),
    fork(edamamSaga),
    fork(loginSaga),
  ]);
}


--- FILE: src/redux/sagas/account.saga.jsx ---

//*account.saga.jsx
import {put, takeLatest, call, all} from 'redux-saga/effects';
import {getFirestore, getDoc, doc} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';

const db = getFirestore(getApp());

// New Process
function* fetchAccount(action) {
  const {account, id} = action.payload;
  // console.log('[Saga] Fetching account for ID:', accountId);

  try {
    const accountRef = doc(db, 'accounts', account);
    const accountDoc = yield call(getDoc, accountRef);

    if (accountDoc.exists) {
      const accountData = accountDoc.data();
      // console.log('[Saga] âœ… Account Data:', accountData);

      const isAllowed = accountData?.allowedUsers?.includes(id);

      if (isAllowed) {
        yield put({
          type: 'SET_ACCOUNT',
          payload: {
            ...accountData,
            lastUpdated: accountData?.lastUpdated || null,
            createdOn: accountData?.createdOn || null,
          },
        });
        console.log('Account Set');
      } else {
        yield put({type: 'SET_ACCOUNT', payload: null});
      }
    } else {
      yield put({type: 'SET_ACCOUNT', payload: null});
    }
  } catch (error) {
    yield put({type: 'ACCOUNT_FETCH_FAILED', payload: error.message});
  }
}

// Needs update
function* fetchAllowedProfiles(action) {
  const {allowedUsers} = action.payload;
  try {
    const profilesPromises = allowedUsers.map(userId =>
      call(getDoc, doc(db, 'profiles', userId)),
    );

    const profilesSnapshots = yield all(profilesPromises);

    const allowedProfiles = profilesSnapshots
      .map(snapshot => {
        if (!snapshot.exists) return null;

        const profileData = snapshot.data();
        return {
          id: snapshot.id,
          firstName: profileData?.firstName || '',
          lastName: profileData?.lastName || '',
          onlineName: profileData?.onlineName || '',
          email: profileData?.email || '',
          role: profileData?.role || 'user',
        };
      })
      .filter(Boolean);

    yield put({type: 'SET_ALLOWED_PROFILES', payload: allowedProfiles});
  } catch (error) {
    // console.error('[Saga] âŒ Fetch Allowed Profiles Error:', error);
    yield put({type: 'FETCH_ALLOWED_PROFILES_FAILED', payload: error.message});
  }
}

export default function* accountSaga() {
  yield takeLatest('FETCH_ACCOUNT', fetchAccount);
  yield takeLatest('FETCH_ALLOWED_PROFILES', fetchAllowedProfiles);
}


--- FILE: src/redux/sagas/cupboard.saga.jsx ---

//*cupboard.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import uuid from 'react-native-uuid';
import Toast from 'react-native-toast-message';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
  writeBatch,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';

const db = getFirestore(getApp());

function* fetchCupboard(action) {
  const {cupboardID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      let cupboardData = cupboardDoc.data();

      if (!cupboardData.items) {
        cupboardData = {...cupboardData, items: []};

        yield call(() =>
          updateDoc(cupboardRef, {
            items: [],
            lastUpdated: new Date().toISOString(),
          }),
        );
      }

      let cupboard = {
        ...cupboardData,
        lastUpdated: cupboardData?.lastUpdated || null,
      };

      yield put({type: 'SET_CUPBOARD', payload: cupboard});
      console.log('Cupboard Set');
    } else {
      yield put({type: 'SET_CUPBOARD', payload: null});
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_SET_FAILED', payload: error.message});
  }
}

function* addItemToCupboard(action) {
  const {cupboardID, newItem, profileID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();

      const updatedItems = [
        ...(cupboardData.items || []),
        {...newItem, itemId: uuid.v4(), itemDate: new Date().toISOString()},
      ];

      yield call(() =>
        updateDoc(cupboardRef, {
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Added',
        text2: `${newItem.itemName} added to the cupboard.`,
      });
    } else {
      yield put({
        type: 'CUPBOARD_ADD_ITEM_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Add Item',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_ADD_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Add Item',
      text2: `${newItem.itemName} could not be added. Please try again later.`,
    });
  }
}

function* updateItemInCupboard(action) {
  const {cupboardID, updatedItem, profileID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();
      const updatedItems = cupboardData?.items?.map(item =>
        item.itemId === updatedItem.itemId ? updatedItem : item,
      );

      yield call(() =>
        updateDoc(cupboardRef, {
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Updated',
        text2: `${updatedItem.itemName} updated in the cupboard.`,
      });
    } else {
      yield put({
        type: 'CUPBOARD_UPDATE_ITEM_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Update Item',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_UPDATE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Update Item',
      text2: `${updatedItem.itemName} could not be updated. Please try again later.`,
    });
  }
}

function* deleteItemFromCupboard(action) {
  const {cupboardID, itemId, itemName, profileID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();

      const updatedItems = cupboardData?.items?.filter(
        item => item.itemId !== itemId,
      );

      yield call(() =>
        updateDoc(cupboardRef, {
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Deleted',
        text2: `${itemName} removed from the cupboard.`,
      });
    } else {
      yield put({
        type: 'CUPBOARD_DELETE_ITEM_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Delete Item',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_DELETE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Delete Item',
      text2: `${itemName} could not be removed. Please try again later.`,
    });
  }
}

function* batchToCupboard(action) {
  const {cupboardID, items, profileID} = action.payload;

  try {
    yield put({type: 'CUPBOARD_BATCH_ADD_START'});

    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      const cupboardData = cupboardDoc.data();
      const batch = writeBatch(db);
      let updatedItems = [...(cupboardData.items || [])];

      items.forEach(item => {
        const {
          itemName,
          brandName,
          description,
          packageSize,
          measurement,
          category,
          notes,
        } = item;

        for (let i = 0; i < item.quantity; i++) {
          const newItem = {
            itemName: itemName || '',
            brandName: brandName || '',
            description: description || '',
            packageSize: Number(packageSize) || 1,
            remainingAmount: Number(packageSize) || 1,
            measurement: measurement || '',
            category: category || '',
            notes: notes || '',
            itemId: uuid.v4(),
            itemDate: new Date().toISOString(),
            quantity: 1,
          };

          updatedItems.push(newItem);
        }
      });

      batch.update(cupboardRef, {
        items: updatedItems,
        lastUpdated: new Date().toISOString(),
        lastUpdatedBy: profileID,
      });

      yield call(() => batch.commit());

      Toast.show({
        type: 'success',
        text1: 'Items Added',
        text2: `Items were added to the cupboard.`,
      });

      yield put({type: 'CUPBOARD_BATCH_ADD_SUCCESS'});
    } else {
      yield put({
        type: 'CUPBOARD_BATCH_ADD_FAILED',
        payload: 'Cupboard not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Batch Add Failed',
        text2: 'Cupboard not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_BATCH_ADD_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Batch Add Failed',
      text2:
        'Items could not be added to the cupboard. Please try again later.',
    });
  }
}

function* resetCupboard(action) {
  const {cupboardID, profileID} = action.payload;
  try {
    const cupboardRef = doc(db, 'cupboards', cupboardID);
    const cupboardDoc = yield call(getDoc, cupboardRef);

    if (cupboardDoc.exists) {
      yield call(() =>
        updateDoc(cupboardRef, {
          items: [],
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Cupboard Reset',
        text2: 'Your cupboard has been cleared.',
      });
    } else {
      Toast.show({
        type: 'warning',
        text1: 'No Cupboard Found',
        text2: 'Could not find a cupboard to reset.',
      });
    }
  } catch (error) {
    yield put({type: 'CUPBOARD_RESET_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Reset Failed',
      text2: 'Your cupboard could not be reset. Please try again later.',
    });
  }
}

export default function* cupboardSaga() {
  yield takeLatest('FETCH_CUPBOARD', fetchCupboard);
  yield takeLatest('ADD_ITEM_TO_CUPBOARD', addItemToCupboard);
  yield takeLatest('UPDATE_ITEM_IN_CUPBOARD', updateItemInCupboard);
  yield takeLatest('DELETE_ITEM_FROM_CUPBOARD', deleteItemFromCupboard);
  yield takeLatest('BATCH_TO_CUPBOARD', batchToCupboard);
  yield takeLatest('RESET_CUPBOARD', resetCupboard);
}


--- FILE: src/redux/sagas/device.saga.jsx ---

//* device.saga.jsx
import {put, takeLatest, call, takeEvery} from 'redux-saga/effects';
import {
  getBrand,
  getDeviceType,
  isLandscape,
  getModel,
  getSystemName,
  getSystemVersion,
  hasNotch,
} from 'react-native-device-info';
import {Dimensions, PixelRatio} from 'react-native';
import {eventChannel} from 'redux-saga';

function createDimensionChannel() {
  return eventChannel(emitter => {
    const updateDimensions = () => emitter(Dimensions.get('window'));
    const subscription = Dimensions.addEventListener(
      'change',
      updateDimensions,
    );
    return () => subscription?.remove();
  });
}

function* watchDeviceDimensions() {
  const channel = createDimensionChannel();
  try {
    while (true) {
      yield takeEvery(channel, fetchDeviceInfo);
    }
  } finally {
    channel.close();
  }
}

function* fetchDeviceInfo() {
  try {
    const {width, height} = Dimensions.get('window');
    const pixelRatio = PixelRatio.get();
    const pixelWidth = width * pixelRatio;
    const pixelHeight = height * pixelRatio;

    const ratio = (
      Math.sqrt(Math.pow(pixelWidth, 2) + Math.pow(pixelHeight, 2)) / 100
    ).toFixed(2);

    const brand = yield call(getBrand);
    const formattedBrand = brand.charAt(0).toUpperCase() + brand.slice(1);

    // Calculate device size
    let sizeForDevice = 'xSmall';

    if (pixelWidth >= 1300) {
      sizeForDevice = 'xLarge'; // Ultra-sized phones
    } else if (pixelWidth >= 1250) {
      sizeForDevice = 'large'; // Large phones
    } else if (pixelWidth >= 1200) {
      sizeForDevice = 'medium'; // Standard flagships
    } else if (pixelWidth >= 1000) {
      sizeForDevice = 'small'; // Smaller phones
    } else {
      sizeForDevice = 'xSmall'; // Compact phones
    }

    const deviceInfo = {
      dimensions: {
        height: Number(height.toFixed(0)),
        width: Number(width.toFixed(0)),
      },
      screen: {
        pixelHeight: pixelHeight,
        pixelWidth: pixelWidth,
        ratio: Number(ratio),
      },
      system: {
        brand: formattedBrand,
        device: yield call(getDeviceType),
        deviceSize: sizeForDevice,
        model: yield call(getModel),
        os: yield call(getSystemName),
        version: yield call(getSystemVersion),
        notch: yield call(hasNotch),
      },
      view: yield call(isLandscape) ? 'Landscape' : 'Portrait',
    };

    yield put({type: 'SET_DEVICE_INFO', payload: deviceInfo});
  } catch (error) {
    yield put({type: 'DEVICE_INFO_FETCH_FAILED', payload: error.message});
  }
}

export default function* deviceSaga() {
  yield takeLatest('FETCH_DEVICE_INFO', fetchDeviceInfo);
  yield watchDeviceDimensions(); // Listens for dimension changes
}


--- FILE: src/redux/sagas/edamam.saga.jsx ---

//* edaman.saga.jsx
import {takeLatest, call, put} from 'redux-saga/effects';
import Config from 'react-native-config';

function* fetchFoodData(action) {
  const {barcode} = action.payload;
  const appId = Config.EDAMAM_APP_ID;
  const appKey = Config.EDAMAM_APP_KEY;
  const url = `https://api.edamam.com/api/food-database/v2/parser?app_id=${appId}&app_key=${appKey}&upc=${barcode}`;
  try {
    const response = yield call(fetch, url);

    if (response.ok) {
      const data = yield response.json();

      if (data.hints && data.hints.length > 0) {
        yield put({type: 'SET_FOOD_DATA', payload: data});
      } else {
        yield put({
          type: 'FOOD_API_FETCH_FAILED',
          payload: `No food found for UPC: ${barcode}`,
        });
      }
    } else {
      yield put({
        type: 'FOOD_API_FETCH_FAILED',
        payload: `API error: ${response.status}`,
      });
    }
  } catch (error) {
    yield put({type: 'FOOD_API_FETCH_FAILED', payload: error.message});
  }
}

// Watcher saga for Edamam API actions
export default function* edamamSaga() {
  yield takeLatest('FETCH_FOOD_DATA', fetchFoodData);
}


--- FILE: src/redux/sagas/invites.saga.jsx ---

//* invites.saga.jsx
import {put, call, takeLatest} from 'redux-saga/effects';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';

const db = getFirestore(getApp());

function* addInviteSaga(action) {
  if (!action.payload?.email) {
    console.error('Email is missing in action payload.');
    return;
  }
  try {
    const docRef = doc(db, 'accountInvites', 'bGk0rcOM1lpPyV1WdG7c');
    const docSnapshot = yield call(getDoc, docRef);

    let updatedInvites = [];

    if (docSnapshot.exists) {
      const docData = docSnapshot.data();
      updatedInvites = docData.invites
        ? [...docData.invites, action.payload]
        : [action.payload];
    } else {
      updatedInvites = [action.payload];
    }

    yield call(() => updateDoc(docRef, {invites: updatedInvites}));
  } catch (error) {
    console.error('Failed to add invite:', error);
  }
}

function* checkInvitesSaga(action) {
  try {
    const docRef = doc(db, 'accountInvites', 'bGk0rcOM1lpPyV1WdG7c');
    const docSnapshot = yield call(getDoc, docRef);

    if (docSnapshot.exists) {
      const {invites = []} = docSnapshot.data();
      const foundInvite = invites.find(
        invite => invite.email === action.payload.email,
      );

      if (foundInvite) {
        action.payload.resolve(foundInvite); // Resolve with the found invite
        yield put({type: 'SET_EXISTING_INVITE', payload: foundInvite});
      } else {
        action.payload.resolve(null); // Resolve with null if no invite found
        yield put({type: 'INVITE_NOT_FOUND'});
      }
    } else {
      action.payload.resolve(null); // Resolve with null if no doc found
      yield put({type: 'INVITE_NOT_FOUND'});
    }
  } catch (error) {
    console.error('Error checking invites:', error);
    action.payload.reject(error); // Reject with the error
    yield put({type: 'CHECK_INVITES_FAILED', payload: error.message});
  }
}

function* updateInviteSaga(action) {
  if (!action.payload?.email) {
    console.error('Email is missing in action payload.');
    return;
  }
  try {
    const docRef = doc(db, 'accountInvites', 'bGk0rcOM1lpPyV1WdG7c');
    const docSnapshot = yield call(getDoc, docRef);

    if (!docSnapshot.exists) {
      console.error('Document not found.');
      return;
    }

    const {invites = []} = docSnapshot.data();
    const updatedInvites = invites.map(invite =>
      invite.email === action.payload.email
        ? {...invite, toExpire: invite.toExpire || new Date().toISOString()}
        : invite,
    );

    yield call(updateDoc, docRef, {invites: updatedInvites});
    yield put({type: 'INVITE_UPDATED', payload: action.payload.email});
  } catch (error) {
    console.error('Failed to update invite:', error);
    yield put({type: 'UPDATE_INVITE_FAILED', payload: error.message});
  }
}

function* deleteInviteSaga(action) {
  if (!action.payload?.email) {
    console.error('Email is missing in action payload.');
    return;
  }
  try {
    const docRef = doc(db, 'accountInvites', 'bGk0rcOM1lpPyV1WdG7c');
    const docSnapshot = yield call(getDoc, docRef);

    if (!docSnapshot.exists) {
      console.error('Document not found.');
      return;
    }

    const {invites = []} = docSnapshot.data();
    const updatedInvites = invites.filter(
      invite => invite.email !== action.payload.email,
    );

    yield call(updateDoc, docRef, {invites: updatedInvites});
    yield put({type: 'INVITE_DELETED', payload: action.payload.email});
  } catch (error) {
    console.error('Failed to delete invite:', error);
    yield put({type: 'DELETE_INVITE_FAILED', payload: error.message});
  }
}

// Watcher saga
export function* invitesSaga() {
  yield takeLatest('ADD_INVITE', addInviteSaga);
  yield takeLatest('CHECK_INVITES', checkInvitesSaga);
  yield takeLatest('UPDATE_INVITE', updateInviteSaga);
  yield takeLatest('DELETE_INVITE', deleteInviteSaga);
}


--- FILE: src/redux/sagas/login.saga.jsx ---

//* login.saga.jsx
import {put, takeLatest, select, call} from 'redux-saga/effects';

// Step 1: Fetch profile using user.uid
function* handleLogin(action) {
  try {
    console.log('Starting login...');
    const uid = action.payload;

    // âœ… Step 1: Fetch Profile
    yield put({type: 'FETCH_PROFILE', payload: {uid}});

    // Wait until profile is set in Redux
    const profile = yield call(waitForProfile);

    // âœ… Step 2: Fetch Account using profile.account & profile.id
    const {account, id} = profile;
    yield put({type: 'FETCH_ACCOUNT', payload: {account, id}});

    // Wait until account is set in Redux
    const accountData = yield call(waitForAccount);

    // âœ… Step 3: Fetch shoppingCart and cupboard
    const {shoppingCartID, cupboardID} = accountData;
    yield put({type: 'FETCH_SHOP_CART', payload: {shoppingCartID}});
    yield put({type: 'FETCH_CUPBOARD', payload: {cupboardID}});
  } catch (error) {
    console.log('Login failed');
    yield put({type: 'LOGIN_SEQUENCE_FAILED', payload: error.message});
  }
}

function* waitForProfile() {
  while (true) {
    const profile = yield select(state => state.profile.profile);
    if (profile) return profile;
    yield new Promise(resolve => setTimeout(resolve, 50));
  }
}

function* waitForAccount() {
  while (true) {
    const account = yield select(state => state.account.account);
    if (account) return account;
    yield new Promise(resolve => setTimeout(resolve, 50));
  }
}

export default function* loginSaga() {
  yield takeLatest('START_LOGIN', handleLogin);
}


--- FILE: src/redux/sagas/profile.saga.jsx ---

//*profile.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import Toast from 'react-native-toast-message';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';

const db = getFirestore(getApp());

// New Process
function* fetchProfile(action) {
  const {uid} = action.payload;

  try {
    const profileRef = doc(db, 'profiles', uid);
    const profileDoc = yield call(getDoc, profileRef);

    if (profileDoc.exists) {
      const profileData = profileDoc.data();
      yield put({
        type: 'SET_PROFILE',
        payload: {
          ...profileData,
          lastUpdated: profileData?.lastUpdated || null,
          createdOn: profileData?.createdOn || null,
        },
      });
      console.log('Profile Set');
    } else {
      yield put({type: 'SET_PROFILE', payload: null});
    }
  } catch (error) {
    yield put({type: 'PROFILE_FETCH_FAILED', payload: error.message});
  }
}

// Needs update
function* updateProfile(action) {
  const {userId, updatedData} = action.payload;
  try {
    const profileRef = doc(db, 'profiles', userId);
    const updatedProfile = {
      ...updatedData,
      lastUpdated: new Date().toISOString(),
    };

    yield call(updateDoc, profileRef, updatedProfile);
    yield put({type: 'UPDATE_PROFILE_SUCCESS', payload: updatedProfile});

    Toast.show({
      type: 'success',
      text1: 'Profile Updated',
      text2: 'Your profile has been updated.',
    });
  } catch (error) {
    // console.error('[Saga] âŒ Update Profile Error:', error);
    yield put({type: 'UPDATE_PROFILE_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Profile Update Failed',
      text2: 'Your profile could not be updated.',
    });
  }
}

export default function* profileSaga() {
  yield takeLatest('FETCH_PROFILE', fetchProfile);
  yield takeLatest('UPDATE_PROFILE_REQUEST', updateProfile);
}


--- FILE: src/redux/sagas/shopCart.saga.jsx ---

//*shopCart.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import uuid from 'react-native-uuid';
import Toast from 'react-native-toast-message';
import {
  getFirestore,
  getDoc,
  updateDoc,
  doc,
  writeBatch,
} from '@react-native-firebase/firestore';
import {getApp} from '@react-native-firebase/app';

const db = getFirestore(getApp());

function* fetchShopCart(action) {
  const {shoppingCartID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      let shopCartData = shopCartDoc.data();

      if (!shopCartData.items) {
        shopCartData = {...shopCartData, items: []};

        yield call(() =>
          updateDoc(shopCartRef, {
            items: [],
            lastUpdated: new Date().toISOString(),
          }),
        );
      }

      let shopCart = {
        ...shopCartData,
        lastUpdated: shopCartData?.lastUpdated || null,
      };

      yield put({type: 'SET_SHOP_CART', payload: shopCart});
      console.log('ShopCart Set');
    } else {
      yield put({type: 'SET_SHOP_CART', payload: null});
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_SET_FAILED', payload: error.message});
  }
}

function* addItemToShopCart(action) {
  const {shoppingCartID, newItem, profileID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();

      const updatedItems = [
        ...(shopCartData.items || []),
        {...newItem, itemId: uuid.v4(), itemDate: new Date().toISOString()},
      ];

      yield call(() =>
        updateDoc(shopCartRef, {
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Added',
        text2: `${newItem.itemName} added to the shopping list.`,
      });
    } else {
      yield put({
        type: 'SHOP_CART_ADD_ITEM_FAILED',
        payload: 'Shopping cart not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Add Item',
        text2: 'Shopping cart not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_ADD_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Add Item',
      text2: `${newItem.itemName} could not be added. Please try again later.`,
    });
  }
}

function* updateItemInShopCart(action) {
  const {shoppingCartID, updatedItem, updateType, profileID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();
      const updatedItems = shopCartData?.items?.map(item =>
        item.itemId === updatedItem.itemId ? updatedItem : item,
      );

      yield call(() =>
        updateDoc(shopCartRef, {
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );

      if (updateType === 'updateList') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} was updated in the shopping list.`,
        });
      } else if (updateType === 'updateCart') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} was updated in the shopping cart.`,
        });
      } else if (updateType === 'toCart') {
        Toast.show({
          type: 'success',
          text1: 'Item Added',
          text2: `${updatedItem.itemName} moved to the shopping cart.`,
        });
      } else if (updateType === 'toList') {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} moved to the shopping list.`,
        });
      } else if (updateType === 'toCupboard') {
        // No toast needed, as the cupboard logic handles it
      } else {
        Toast.show({
          type: 'success',
          text1: 'Item Updated',
          text2: `${updatedItem.itemName} updated to the shopping list.`,
        });
      }
    } else {
      yield put({
        type: 'SHOP_CART_UPDATE_ITEM_FAILED',
        payload: 'Shopping cart not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Update Item',
        text2: 'Shopping cart not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_UPDATE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Update Item',
      text2: `${updatedItem.itemName} could not be updated. Please try again later.`,
    });
  }
}

function* deleteItemFromShopCart(action) {
  const {shoppingCartID, itemId, itemName, profileID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();

      const updatedItems = shopCartData?.items?.filter(
        item => item.itemId !== itemId,
      );

      yield call(() =>
        updateDoc(shopCartRef, {
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );

      Toast.show({
        type: 'success',
        text1: 'Item Deleted',
        text2: `${itemName} removed from the shopping cart.`,
      });
    } else {
      yield put({
        type: 'SHOP_CART_DELETE_ITEM_FAILED',
        payload: 'Shopping cart not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Failed to Delete Item',
        text2: 'Shopping cart not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_DELETE_ITEM_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Failed to Delete Item',
      text2: `${itemName} could not be removed. Please try again later.`,
    });
  }
}

function* deleteListFromShopCart(action) {
  const {shoppingCartID, items, profileID} = action.payload;

  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();

      const updatedItems = shopCartData?.items?.filter(
        item => !items.some(cartItem => cartItem.itemId === item.itemId),
      );

      yield call(() =>
        updateDoc(shopCartRef, {
          items: updatedItems,
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_DELETE_LIST_FAILED', payload: error.message});
  }
}

function* batchToShopping(action) {
  const {shoppingCartID, items, status, profileID} = action.payload;

  try {
    yield put({type: 'SHOP_CART_BATCH_ADD_START'});

    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      const shopCartData = shopCartDoc.data();
      const batch = writeBatch(db);
      let updatedItems = [...(shopCartData.items || [])];

      items.forEach(item => {
        const {
          itemName,
          brandName,
          description,
          packageSize,
          measurement,
          category,
          notes,
        } = item;

        for (let i = 0; i < item.quantity; i++) {
          const newItem = {
            itemName: itemName || '',
            brandName: brandName || '',
            description: description || '',
            packageSize: Number(packageSize) || 1,
            measurement: measurement || '',
            category: category || '',
            notes: notes || '',
            itemId: uuid.v4(),
            itemDate: new Date().toISOString(),
            quantity: 1,
            status:
              status === 'shopping-list' ? 'shopping-list' : 'shopping-cart',
          };

          updatedItems.push(newItem);
        }
      });

      batch.update(shopCartRef, {
        items: updatedItems,
        lastUpdated: new Date().toISOString(),
        lastUpdatedBy: profileID,
      });

      yield call(() => batch.commit());

      yield put({type: 'SET_SHOP_CART', payload: {shoppingCartID}});

      Toast.show({
        type: 'success',
        text1: 'Items Added',
        text2: `Items were added to your ${
          status === 'shopping-list' ? 'shopping list' : 'shopping cart'
        }.`,
      });

      yield put({type: 'SHOP_CART_BATCH_ADD_SUCCESS'});
    } else {
      yield put({
        type: 'SHOP_CART_BATCH_ADD_FAILED',
        payload: 'Shopping cart not found.',
      });

      Toast.show({
        type: 'danger',
        text1: 'Batch Add Failed',
        text2: 'Shopping cart not found. Please try again later.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_BATCH_ADD_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Batch Add Failed',
      text2:
        'Items could not be added to the shopping cart. Please try again later.',
    });
  }
}

function* resetShopCart(action) {
  const {shoppingCartID, profileID} = action.payload;
  try {
    const shopCartRef = doc(db, 'shoppingCarts', shoppingCartID);
    const shopCartDoc = yield call(getDoc, shopCartRef);

    if (shopCartDoc.exists) {
      yield call(() =>
        updateDoc(shopCartRef, {
          items: [],
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: profileID,
        }),
      );

      yield put({type: 'SET_SHOP_CART', payload: {shoppingCartID}});

      Toast.show({
        type: 'success',
        text1: 'Shopping List Reset',
        text2: 'Your shopping list has been cleared.',
      });
    } else {
      Toast.show({
        type: 'warning',
        text1: 'No Shopping List Found',
        text2: 'Could not find a shopping list to reset.',
      });
    }
  } catch (error) {
    yield put({type: 'SHOP_CART_RESET_FAILED', payload: error.message});

    Toast.show({
      type: 'danger',
      text1: 'Reset Failed',
      text2: 'Your shopping list could not be reset. Please try again later.',
    });
  }
}

export default function* shopCartSaga() {
  yield takeLatest('FETCH_SHOP_CART', fetchShopCart);
  yield takeLatest('ADD_ITEM_TO_SHOP_CART', addItemToShopCart);
  yield takeLatest('UPDATE_ITEM_IN_SHOP_CART', updateItemInShopCart);
  yield takeLatest('DELETE_ITEM_FROM_SHOP_CART', deleteItemFromShopCart);
  yield takeLatest('DELETE_LIST_FROM_SHOP_CART', deleteListFromShopCart);
  yield takeLatest('BATCH_TO_SHOP_CART', batchToShopping);
  yield takeLatest('RESET_SHOP_CART', resetShopCart);
}


--- FILE: src/redux/sagas/user.saga.jsx ---

//* user.saga.jsx
import {put, takeLatest, call} from 'redux-saga/effects';
import {getAuth} from '@react-native-firebase/auth';
import {persistor} from '../../../store';

const auth = getAuth();

const getErrorMessage = error => {
  console.log(error.code);
  switch (error.code) {
    case 'auth/invalid-credential':
    case 'auth/wrong-password':
    case 'auth/user-not-found':
      return 'The email or password provided is incorrect. Please try again.';
    case 'auth/user-disabled':
      return 'The user account has been disabled. Please contact support.';
    case 'auth/email-already-in-use':
      return 'The email address is already in use by another account.';
    case 'auth/invalid-email':
      return 'The email address is not valid. Please check and try again.';
    default:
      return 'An unknown error occurred. Please try again later.';
  }
};

// New Process
function* loginUser(action) {
  try {
    const {email, password} = action.payload;

    const userCredential = yield call(
      [auth, auth.signInWithEmailAndPassword],
      email,
      password,
    );

    const user = userCredential?.user;

    if (user?.emailVerified) {
      yield put({type: 'SET_USER', payload: user});
      console.log('User Set');
      yield put({type: 'START_LOGIN', payload: user.uid});
    } else {
      yield put({
        type: 'LOGIN_FAILED',
        payload: 'Email is not verified. Please verify your email to log in.',
      });
    }
  } catch (error) {
    const friendlyMessage = getErrorMessage(error);
    yield put({type: 'LOGIN_FAILED', payload: friendlyMessage});
  }
}

// No changes needed
function* logoutUser() {
  try {
    yield call([auth, auth.signOut]);
    yield put({type: 'UNSET_USER'});
  } catch (error) {
    const friendlyMessage = getErrorMessage(error);
    yield put({type: 'LOGOUT_FAILED', payload: friendlyMessage});
  }
}

// No changes needed
function* logOutAndClear() {
  try {
    yield call([auth, auth.signOut]);
    yield put({type: 'UNSET_USER'});
    yield put({type: 'RESET_ALL_STATE'});
    yield call([persistor, persistor.purge]);
    yield call([persistor, persistor.flush]);
  } catch (error) {
    const friendlyMessage = getErrorMessage(error);
    yield put({type: 'LOGOUT_FAILED', payload: friendlyMessage});
  }
}

export default function* userSaga() {
  yield takeLatest('LOGIN_REQUEST', loginUser);
  yield takeLatest('LOGOUT', logoutUser);
  yield takeLatest('LOGOUT_AND_CLEAR', logOutAndClear);
}


--- FILE: src/screens/Account/Account.jsx ---

//* Account.jsx
import React from 'react';
import {useRoute} from '@react-navigation/native';
import {Layout, Text} from '../../KQ-UI';

const Account = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton="Logout"
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Text>Account</Text>
    </Layout>
  );
};

export default Account;


--- FILE: src/screens/Auth/Auth.jsx ---

//* Auth.jsx
import React, {useEffect, useRef} from 'react';
import {
  Animated,
  Image,
  Platform,
  StatusBar,
  TouchableWithoutFeedback,
} from 'react-native';
import MCIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import {useDispatch} from 'react-redux';
import {Button, Input, Layout} from '../../KQ-UI';
import {useDeviceInfo} from '../../hooks/useHooks';

function Auth(props) {
  const {bgColor} = props;
  const [email, setEmail] = React.useState('');
  const [password, setPassword] = React.useState('');
  const [secureTextEntry, setSecureTextEntry] = React.useState(true);
  const dispatch = useDispatch();
  const device = useDeviceInfo();

  const logoPosition = useRef(
    new Animated.Value(Platform.OS === 'ios' ? 330 : 370),
  ).current;
  const formOpacity = useRef(new Animated.Value(0)).current;
  const formTranslateY = useRef(new Animated.Value(50)).current;

  useEffect(() => {
    const screenHeight = device?.dimensions?.height || 800; // Default fallback
    const deviceSize = device?.system?.deviceSize || 'unknown';
    const os = device?.system?.os || 'unknown';

    const getLogoFinalPosition = (screenHeight, deviceSize, os) => {
      switch (`${deviceSize}-${os}`) {
        case 'xSmall-iOS':
          return screenHeight * 0.1;
        case 'xSmall-Android':
          return screenHeight * 0.12;

        case 'small-iOS':
          return screenHeight * 0.12;
        case 'small-Android':
          return screenHeight * 0.14;

        case 'medium-iOS':
          return screenHeight * 0.14;
        case 'medium-Android':
          return screenHeight * 0.16;

        case 'large-iOS':
          return screenHeight * 0.16;
        case 'large-Android':
          return screenHeight * 0.18;

        case 'xLarge-iOS': // iPhone Pro Max / Large Tablets
          return screenHeight * 0.18;
        case 'xLarge-Android': // Android XL devices
          return screenHeight * 0.2;

        default:
          return screenHeight * 0.18; // Fallback for unknown sizes
      }
    };

    const finalPosition = getLogoFinalPosition(screenHeight, deviceSize, os);

    Animated.timing(logoPosition, {
      toValue: finalPosition,
      duration: 1000,
      useNativeDriver: false,
    }).start();

    setTimeout(() => {
      Animated.parallel([
        Animated.timing(formOpacity, {
          toValue: 1,
          duration: 500,
          useNativeDriver: true,
        }),
        Animated.timing(formTranslateY, {
          toValue: 0,
          duration: 700,
          useNativeDriver: true,
        }),
      ]).start();
    }, 800);
  }, [device]); // Recalculate when `device` changes

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  const renderIcon = () => (
    <TouchableWithoutFeedback onPress={toggleSecureEntry}>
      <MCIcons
        name={secureTextEntry ? 'eye-off' : 'eye'}
        size={20}
        color={'#000'}
      />
    </TouchableWithoutFeedback>
  );

  const isValidEmail = email => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  const isValidPassword = password => password.length >= 8;
  const canSignIn = isValidEmail(email) && isValidPassword(password);

  const handleSignIn = () => {
    if (canSignIn) {
      dispatch({
        type: 'LOGIN_REQUEST',
        payload: {email, password},
      });
    }
  };

  const logo = require('../../images/AppLogo_350.png');

  return (
    <Layout useHeader={false} innerViewStyles={{justifyContent: 'center'}}>
      <StatusBar backgroundColor={bgColor} barStyle="light-content" />
      <Animated.View
        style={{
          position: 'absolute',
          top: logoPosition,
          width: '100%',
          alignItems: 'center',
        }}>
        <Image source={logo} />
      </Animated.View>
      <Animated.View
        style={{
          opacity: formOpacity,
          transform: [{translateY: formTranslateY}],
        }}>
        <Input
          placeholder="Email"
          capitalize={false}
          value={email}
          onChangeText={setEmail}
        />
        <Input
          placeholder="Password"
          value={password}
          onChangeText={setPassword}
          accessoryRight={renderIcon}
          secureTextEntry={secureTextEntry}
          capitalize={false}
        />
        <Button
          status={canSignIn ? 'primary' : 'basic'}
          onPress={handleSignIn}
          disabled={!canSignIn}>
          Sign In
        </Button>
      </Animated.View>
    </Layout>
  );
}

export default Auth;


--- FILE: src/screens/CenterMenu/CenterMenu.jsx ---

//*CenterMenu.jsx
import React, {useCallback, useReducer} from 'react';
import {Alert, ScrollView, TouchableOpacity, View} from 'react-native';
import {useNavigation} from '@react-navigation/native';
import {useDispatch} from 'react-redux';
import {useShoppingCart} from '../../hooks/useHooks';
import {setHapticFeedback} from '../../hooks/setHapticFeedback';
import {menuArray} from './CenterMenuArray';
import {Icons} from '../../components/IconListRouter';
import {CMStyles} from '../../styles/Styles';
import {Text} from '../../KQ-UI';
import {useCoreInfo} from '../../utilities/coreInfo';

function CenterMenu(props) {
  const {toggleMenu} = props;
  const navigation = useNavigation();
  const useHaptics = setHapticFeedback();
  const dispatch = useDispatch();
  const core = useCoreInfo();
  const shopping = useShoppingCart();
  const cartList =
    shopping?.items?.filter(item => item.status === 'shopping-cart') ?? [];

  const handleOnPress = useCallback(
    action => {
      if (action === 'console') return;
      if (action === 'Logout') {
        handleSignOut();
        return;
      }

      useHaptics(core?.userSettings?.hapticStrength || 'light');
      toggleMenu();

      if (typeof action === 'string') {
        navigation.navigate(action);
      } else if (typeof action === 'object' && action.screen) {
        navigation.navigate(action.screen, action.params || {});
      }
    },
    [core?.userSettings?.hapticStrength, toggleMenu, navigation],
  );

  const handleSignOut = useCallback(() => {
    Alert.alert('Logging Out', 'Are you sure you want to logout?', [
      {text: 'Cancel', style: 'destructive'},
      {
        text: 'Confirm',
        onPress: () => {
          useHaptics(core?.userSettings?.hapticStrength || 'light');
          dispatch({type: 'LOGOUT'});
        },
      },
    ]);
  }, [core?.userSettings?.hapticStrength, dispatch]);

  const sectionReducer = (state, action) => {
    return {...state, [action]: !state[action]};
  };

  const initialState = menuArray.reduce((acc, section) => {
    acc[section.section] = section.defaultOpen;
    return acc;
  }, {});

  const [sectionStates, dispatchSection] = useReducer(
    sectionReducer,
    initialState,
  );

  const toggleSection = useCallback(
    sectionName => dispatchSection(sectionName),
    [dispatchSection],
  );

  const SectionHeaderComponent = ({title, state, onPress}) => {
    return (
      <View style={CMStyles.shContainer}>
        <View style={CMStyles.shLine}></View>
        <View style={{flex: 1, zIndex: 2}}>
          <View style={[CMStyles.shTWrap, {flex: 1}]}>
            <TouchableOpacity style={CMStyles.shTO} onPress={onPress}>
              {state ? <Icons.ChevronUp /> : <Icons.ChevronDown />}
            </TouchableOpacity>
          </View>
        </View>

        <View style={CMStyles.shTitleWrap}>
          <View style={CMStyles.shTitle}>
            <Text>{title}</Text>
          </View>
        </View>
      </View>
    );
  };

  const SectionHeader = __DEV__
    ? SectionHeaderComponent
    : React.memo(SectionHeaderComponent);

  const SectionComponent = ({title, state, onPress, data}) => {
    return (
      <>
        <SectionHeader title={title} state={state} onPress={onPress} />
        {state ? (
          <View style={CMStyles.sectionExpanded}>
            {data.map((item, index) =>
              item.action === 'ShoppingCart' && cartList.length === 0 ? null : (
                <TouchableOpacity
                  key={index}
                  onPress={() => handleOnPress(item.action)}
                  style={CMStyles.sectionTO}>
                  <View style={CMStyles.sectionIcon}>{item.icon}</View>
                  <Text>{item.title}</Text>
                </TouchableOpacity>
              ),
            )}
          </View>
        ) : (
          <View style={CMStyles.sectionCollapsed}>
            <Text size="xSmall">(Hidden: Expand to View)</Text>
          </View>
        )}
      </>
    );
  };

  const Section = __DEV__ ? SectionComponent : React.memo(SectionComponent);

  return (
    <ScrollView style={{backgroundColor: '#fff'}}>
      {menuArray.map((section, index) => (
        <Section
          key={index}
          title={section.section}
          state={sectionStates[section.section]}
          onPress={() => toggleSection(section.section)}
          data={section.items}
        />
      ))}
    </ScrollView>
  );
}

export default CenterMenu;


--- FILE: src/screens/CenterMenu/CenterMenuArray.jsx ---

//* CenterMenuArray.jsx
import {Icons} from '../../components/IconListRouter';

export const menuArray = [
  {
    section: 'Shopping',
    defaultOpen: true,
    items: [
      // future feature
      // {
      //   title: 'Scan to',
      //   icon: <Icons.Barcode />,
      //   action: 'console',
      // },
      {
        title: 'Add to',
        icon: <Icons.AddList />,
        action: {
          screen: 'ShoppingItems',
          params: {
            title: 'Add Item(s)',
            itemId: null,
            navigateBackTo: 'ShoppingList',
          },
        },
      },

      {
        title: 'View List',
        icon: <Icons.MenuList />,
        action: 'ShoppingList',
      },
      {
        title: 'View Cart',
        icon: <Icons.Shopping />,
        action: 'ShoppingCart',
      },
    ],
  },
  {
    section: 'Cupboard',
    defaultOpen: true,
    items: [
      // future feature
      // {
      //   title: 'Scan to',
      //   icon: <Icons.Barcode />,
      //   action: 'console',
      // },
      {
        title: 'Add to',
        icon: <Icons.AddList />,
        action: {
          screen: 'CupboardItems',
          params: {
            title: 'Add Item(s)',
            itemId: null,
            navigateBackTo: 'CupboardList-Single',
          },
        },
      },
      {
        title: 'View List',
        icon: <Icons.Cupboards />,
        action: 'CupboardList-Single',
      },
    ],
  },
  // future feature
  // {
  //   section: 'Recipe',
  //   defaultOpen: false,
  //   items: [
  //     {
  //       title: 'Search',
  //       icon: <Icons.Search />,
  //       action: 'console',
  //     },
  //     {
  //       title: 'Add to',
  //       icon: <Icons.AddList />,
  //       action: 'console',
  //     },
  //     {
  //       title: 'View List',
  //       icon: <Icons.Recipe />,
  //       action: 'console',
  //     },
  //   ],
  // },

  // future feature
  // {
  //   section: 'Favorites',
  //   defaultOpen: false,
  //   items: [
  //     {
  //       title: 'Add to',
  //       icon: <Icons.AddList />,
  //       action: 'console',
  //     },
  //     {
  //       title: 'View List',
  //       icon: <Icons.Favorite />,
  //       action: 'console',
  //     },
  //   ],
  // },
  {
    section: 'Misc',
    defaultOpen: true,
    items: [
      {
        title: 'View Account',
        icon: <Icons.Account />,
        action: 'Account',
      },
      {
        title: 'View Profile',
        icon: <Icons.Profile />,
        action: 'AccountProfile',
      },
      {
        title: 'View Settings',
        icon: <Icons.Settings />,
        action: 'AccountSettings',
      },
      {
        title: 'Get Help',
        icon: <Icons.Help />,
        action: 'AccountHelp',
      },
      {
        title: 'LogOut',
        icon: <Icons.Logout />,
        action: 'Logout',
      },
    ],
  },
  __DEV__
    ? {
        section: '(Development)',
        defaultOpen: true,
        items: [
          {
            title: 'Dev Playground',
            icon: <Icons.Dev />,
            action: 'DevPlayground',
          },
          {
            title: 'Text',
            icon: <Icons.Dev />,
            action: 'DevText',
          },
          {
            title: 'Inputs',
            icon: <Icons.Dev />,
            action: 'DevInputs',
          },
          {
            title: 'Buttons',
            icon: <Icons.Dev />,
            action: 'DevButtons',
          },
          {
            title: 'Modals',
            icon: <Icons.Dev />,
            action: 'DevModals',
          },
          {
            title: 'Dropdowns',
            icon: <Icons.Dev />,
            action: 'DevDropdowns',
          },
        ],
      }
    : null,
].filter(Boolean);


--- FILE: src/screens/Cupboard/CupboardGroup.jsx ---

//* CupboardGroup.jsx
import React, {useState, useMemo} from 'react';
import {useRoute} from '@react-navigation/native';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useCupboard} from '../../hooks/useHooks';
import {ListStyles} from '../../styles/Styles';
import {View} from 'react-native';
import SwipeableItem from '../../components/SwipeableItem';
import SelectedItemInfo from '../../components/SelectedItemInfo';

const CupboardGroup = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  const cupboard = useCupboard();
  const cupboardItems = cupboard?.items ?? [];

  const groupedList = useMemo(() => {
    const map = new Map();

    for (const item of cupboardItems) {
      const {
        itemName,
        brandName,
        category,
        description,
        measurement,
        packageSize,
        remainingAmount,
      } = item;

      if (map.has(itemName)) {
        const group = map.get(itemName);
        group.count++;
        group.items.push(item);

        group.brandName = group.brandName === brandName ? brandName : undefined;
        group.category = group.category === category ? category : undefined;
        group.description =
          group.description === description ? description : undefined;
        group.measurement =
          group.measurement === measurement ? measurement : undefined;

        if (group.measurement) {
          group.packageSize += Number(packageSize || 0);
          group.remainingAmount += Number(remainingAmount || 0);
        } else {
          group.packageSize = undefined;
          group.remainingAmount = undefined;
        }
      } else {
        map.set(itemName, {
          itemName,
          itemId: item.itemId,
          count: 1,
          brandName,
          category,
          description,
          measurement,
          packageSize: Number(packageSize || 0),
          remainingAmount: Number(remainingAmount || 0),
          items: [item],
        });
      }
    }

    return Array.from(map.values());
  }, [cupboardItems]);

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        cupboardView
        groupedView
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
        // navigate={{to: 'UpdateShopItems', backTo: 'ShoppingList'}}
      />
    </BottomSheet>
  );

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton="Merge"
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}
      outerViewStyles={{paddingBottom: 0}}>
      {groupedList.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Cupboard is Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            list={groupedList}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            leftButtons={[]}
            rightButton={[]}
            cupboardView
            groupedView
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default CupboardGroup;


--- FILE: src/screens/Cupboard/CupboardItems.jsx ---

//* CupboardItems.jsx

import {useNavigation, useRoute} from '@react-navigation/native';
import React, {useEffect, useState} from 'react';
import {Dropdown, Input, Layout} from '../../KQ-UI';
import {useCupboard} from '../../hooks/useHooks';
import {displayMeasurements} from '../../utilities/measurements';
import {displayCategories} from '../../utilities/categories';
import {displayCustom, setNumericValue} from '../../utilities/helpers';
import {View} from 'react-native';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';

const CupboardItems = () => {
  const route = useRoute();
  const {title, bgColor, textColor, headerColor, itemId, navigateBackTo} =
    route.params || {};

  const dispatch = useDispatch();
  const core = useCoreInfo();
  const navigation = useNavigation();
  const cupboard = useCupboard();

  console.log('core', core);

  const itemToUpdate =
    cupboard?.items?.find(item => item.itemId === itemId) ?? null;

  const [itemName, setItemName] = useState(itemToUpdate?.itemName ?? null);
  const [brandName, setBrandName] = useState(itemToUpdate?.brandName ?? '');
  const [description, setDescription] = useState(
    itemToUpdate?.description ?? '',
  );
  const [packageSize, setPackageSize] = useState(
    String(itemToUpdate?.packageSize ?? '1'),
  );
  const [remainingAmount, setRemainingAmount] = useState(
    String(itemToUpdate?.quantity ?? '1'),
  );
  const [measurement, setMeasurement] = useState(
    displayCustom(itemToUpdate?.measurement, displayMeasurements) ?? null,
  );
  const [category, setCategory] = useState(
    displayCustom(itemToUpdate?.category, displayMeasurements) ?? null,
  );
  const [notes, setNotes] = useState(itemToUpdate?.notes ?? '');

  const [validation, setValidation] = useState(false);
  const [remainValidation, setRemainValidation] = useState(false);
  const [canSave, setCanSave] = useState(false);

  useEffect(() => {
    if (itemName === null) {
      setValidation(false);
      setCanSave(false);
    } else if (itemName === '') {
      setValidation(true);
      setCanSave(false);
    } else {
      setValidation(false);
      setCanSave(true);
    }
  }, [itemName]);

  useEffect(() => {
    setRemainingAmount(packageSize);
  }, [packageSize]);

  const handleRemainingAmountChange = value => {
    const numericValue = Number(value);
    if (numericValue > Number(packageSize)) {
      setRemainValidation(true);
    } else {
      setRemainValidation(false);
    }
    setRemainingAmount(value);
  };

  const handlePackageChange = value => {
    setNumericValue(setPackageSize(value));
    setNumericValue(setRemainingAmount(value));
  };

  const resetForm = () => {
    setItemName(null);
    setBrandName('');
    setDescription('');
    setPackageSize('1');
    setRemainingAmount('1');
    setMeasurement(null);
    setCategory(null);
    setNotes('');
  };

  const SaveItem = () => {
    if (itemName === '' || itemName === null) {
      setValidation(true);
    } else {
      setValidation(false);

      const newItem = {
        itemName: itemName || '',
        brandName: brandName || '',
        description: description || '',
        packageSize: Number(packageSize) > 0 ? Number(packageSize) : 1,
        remainingAmount:
          Number(remainingAmount) > 0 ? Number(remainingAmount) : 1,
        measurement: measurement?.key || '',
        category: category?.key || '',
        notes: notes || '',
      };

      const updatedItem = {
        ...itemToUpdate,
        ...newItem,
      };

      if (itemToUpdate) {
        dispatch({
          type: 'UPDATE_ITEM_IN_CUPBOARD',
          payload: {
            cupboardID: core.cupboardID,
            updatedItem,
            profileID: core.profileID,
          },
        });
      } else {
        dispatch({
          type: 'ADD_ITEM_TO_CUPBOARD',
          payload: {
            cupboardID: core.cupboardID,
            newItem,
            profileID: core.profileID,
          },
        });
      }

      resetForm();
    }
  };

  const handleClose = () => {
    // dispatch({type: 'RESET_FOOD_DATA'}); // this is for edamam later
    resetForm();
    // setStoredData(null); // this is for edamam later
    navigation.navigate(navigateBackTo);
  };

  const displayRemaining = (packageSize, remainingAmount) => {
    let percent = (remainingAmount / packageSize) * 100;
    return `${percent.toFixed(0)}% left in package`;
  };

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton="Close"
      RightButton={canSave ? 'Save' : null}
      LeftAction={handleClose}
      RightAction={canSave ? SaveItem : null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}>
      <Input
        required
        label="Item Name"
        value={itemName}
        onChangeText={setItemName}
        validation={validation}
        validationMessage="Item Name is required"
        capitalize
        capitalMode="words"
      />
      <Input
        label="Brand Name"
        value={brandName}
        onChangeText={setBrandName}
        capitalize
        capitalMode="words"
      />
      <Input
        label="Description"
        value={description}
        onChangeText={setDescription}
        capitalize
        capitalMode="sentences"
      />
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Input
            label="Package Size"
            value={packageSize}
            onChangeText={setNumericValue(setPackageSize)}
            caption="Example: 12 Eggs"
            capitalMode="sentences"
          />
        </View>
        <View style={{flex: 1}}>
          <Input
            label="Remaining Amount"
            value={remainingAmount}
            onChangeText={handleRemainingAmountChange}
            caption={displayRemaining(packageSize, remainingAmount)}
            // capitalMode="sentences"
          />
        </View>
      </View>
      <Dropdown
        label="Measurement"
        customLabel="Custom Measurement"
        placeholder="Select a measurement"
        value={measurement}
        setValue={setMeasurement}
        caption={'Single is for individual items. Ex: Eggs'}
        mapData={displayMeasurements}
      />
      <Dropdown
        label="Category"
        placeholder="Select a category"
        value={category}
        setValue={setCategory}
        mapData={displayCategories}
      />
      <Input
        label="Notes"
        value={notes}
        onChangeText={setNotes}
        multiline
        multiHeight="large"
        caption="Add notes here"
        counter
        maxCount={250}
      />
    </Layout>
  );
};

export default CupboardItems;


--- FILE: src/screens/Cupboard/CupboardSingle.jsx ---

//* CupboardSingle.jsx
import React, {useCallback, useState} from 'react';
import {useNavigation, useRoute} from '@react-navigation/native';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useAccount, useCupboard} from '../../hooks/useHooks';
import {useDispatch} from 'react-redux';
import {ListStyles} from '../../styles/Styles';
import {View} from 'react-native';
import SwipeableItem from '../../components/SwipeableItem';
import {useCoreInfo} from '../../utilities/coreInfo';
import SelectedItemInfo from '../../components/SelectedItemInfo';

const CupboardSingle = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  const core = useCoreInfo();
  const account = useAccount();
  const cupboard = useCupboard();
  const navigation = useNavigation();
  const dispatch = useDispatch();

  const cupboardList = cupboard?.items ?? [];

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  const handleUpdateItem = itemId => {
    navigation.navigate('CupboardItems', {
      title: 'Update Item',
      itemId,
      navigateBackTo: 'CupboardList-Single',
    });
  };

  const handleDeleteItem = useCallback(
    itemId => {
      if (core.profileID) {
        const item = cupboardList?.find(item => item?.itemId === itemId);
        if (item) {
          dispatch({
            type: 'DELETE_ITEM_FROM_CUPBOARD',
            payload: {
              cupboardID: core.cupboardID,
              itemId: item.itemId,
              itemName: item.itemName,
              profileID: core.profileID,
            },
          });
        }
      }
    },
    [dispatch, core, cupboardList],
  );

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        cupboardView
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
        navigate={{to: 'CupboardItems', backTo: 'CupboardList-Single'}}
      />
    </BottomSheet>
  );

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton="Split"
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{
        justifyContent: 'center',
        alignItems: 'center',
      }}
      outerViewStyles={{paddingBottom: 0}}>
      {cupboardList.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Cupboard List is Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            list={cupboardList}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            cupboardView
            noQuantity
            rightButtons={[
              {
                action: itemId => handleUpdateItem(itemId),
                navigateBackTo: 'CupboardList-Single',
                text1: 'Update',
                text2: 'Item',
                style: ListStyles.updateButton,
              },
              {
                action: itemId => handleDeleteItem(itemId),
                text1: 'Delete',
                style: ListStyles.deleteButton,
              },
            ]}
            leftButtons={[]}
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default CupboardSingle;


--- FILE: src/screens/Dev/DevButtons.jsx ---

//* DevButtons.jsx
import React from 'react';
import {Button, Layout} from '../../KQ-UI';
import {useRoute} from '@react-navigation/native';
import {View} from 'react-native';

const DevButtons = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{
        justifyContent: 'center',
        alignItems: 'center',
      }}>
      <Button
        type="filled" //useButtonType
        size="small" //useButtonSizes
        color="primary" //useColors or allow custom like "white" or "#fff"
        textSize="medium" //useFonts
        fontType="open-6" //useFonts
        textColor="white" //or useColors or allow custom like "white" or "#fff"
        disabled={false} //true or false, default is false and the prop is optional
        onPress={() => {
          console.log('button pressed');
        }}>
        Press Me
      </Button>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Primary"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Primary"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Primary"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Primary
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Success"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Success"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Success"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Success
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Info"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Info"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Info"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Info
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Warning"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Warning"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Warning"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Warning
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Danger"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Danger"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Danger"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Danger
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            color="Dark"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            color="Dark"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            color="Dark"
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Dark
          </Button>
        </View>
      </View>
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Button
            type="filled" //useButtonType
            disabled
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="outline" //useButtonType
            disabled
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
        <View style={{flex: 1}}>
          <Button
            type="ghost" //useButtonType
            disabled
            onPress={() => {
              console.log('button pressed');
            }} //function to run on button press
          >
            Disabled
          </Button>
        </View>
      </View>
    </Layout>
  );
};

export default DevButtons;


--- FILE: src/screens/Dev/DevDropdowns.jsx ---

//* DevDropdowns.jsx
import React, {useState} from 'react';
import {View} from 'react-native';
import {Dropdown, Input, Layout, Text} from '../../KQ-UI';
import {useRoute} from '@react-navigation/native';
import {displayCategories} from '../../utilities/categories';
import {displayMeasurements} from '../../utilities/measurements';

const DevDropdowns = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  const [value, setValue] = useState(null);
  const [value2, setValue2] = useState('');

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}>
      <Input
        label="Item Name"
        placeholder="Enter Item Name"
        value={value2}
        onChangeText={setValue2}
        capitalize={false}
        capitalMode="words"
        caption="Enter Item"
      />
      <Dropdown
        label="Category"
        placeholder="Press to Select"
        value={value}
        setValue={setValue}
        caption="Select a Category"
        mapData={displayMeasurements}
      />
    </Layout>
  );
};

export default DevDropdowns;


--- FILE: src/screens/Dev/DevInputs.jsx ---

//* DevInputs.jsx
import React, {useState} from 'react';
import {useRoute} from '@react-navigation/native';
import {Layout, Input} from '../../KQ-UI';
import {TouchableWithoutFeedback} from 'react-native';
import {Icons} from '../../components/IconListRouter';

const DevInputs = ({}) => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  const [value, setValue] = useState('');
  const [value1, setValue1] = useState('');
  const [value2, setValue2] = useState('');
  const [value3, setValue3] = useState('');
  const [secureTextEntry, setSecureTextEntry] = useState(true);

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  const renderIcon = () => (
    <TouchableWithoutFeedback onPress={toggleSecureEntry}>
      {secureTextEntry ? <Icons.EyeOff /> : <Icons.EyeOn />}
    </TouchableWithoutFeedback>
  );

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      useKeyboardHandling={true}>
      <Input
        label="Email"
        placeholder="Email"
        value={value}
        onChangeText={setValue}
        capitalize={false}
        capitalMode="words"
        caption="Enter your email address"
        // keyboardType="default"
        // keyboardType="number-pad" // ios, has no decimal point
        // keyboardType="decimal-pad"
        // keyboardType="numeric" // ios, shows letters on number pad
        // keyboardType="email-address"
        // keyboardType="phone-pad" // same as numeric
        // keyboardType="url"
      />
      <Input
        label="Password"
        placeholder="Password"
        value={value1}
        onChangeText={setValue1}
        capitalize={false}
        accessoryRight={renderIcon}
        secureTextEntry={secureTextEntry}
        required
        caption="Password must be at least 8 characters long"
        counter
        maxCount={500}
      />
      <Input
        label="Multiple Lines"
        placeholder="Enter text here"
        value={value2}
        onChangeText={setValue2}
        multiline
        // multiHeight="medium"
        required
        caption="Enter a message"
        counter
        maxCount={150}
      />
      <Input
        label="Notes"
        placeholder="Type multiple lines..."
        value={value3}
        onChangeText={setValue3}
        multiline
        multiHeight="large"
        caption="Enter notes"
        counter
        maxCount={250}
      />
    </Layout>
  );
};

export default DevInputs;


--- FILE: src/screens/Dev/DevModals.jsx ---

//* DevModals.jsx
import React, {useState} from 'react';
import {useRoute} from '@react-navigation/native';
import {View} from 'react-native';
import {Button, Layout, Modal, Text} from '../../KQ-UI';

const DevModals = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  const [showModal, setShowModal] = useState(false);
  const [showModal2, setShowModal2] = useState(false);
  const [showModal3, setShowModal3] = useState(false);
  const [showModal4, setShowModal4] = useState(false);

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Modal
        visible={showModal}
        title="Full Screen"
        headerFont="open-6"
        headerSize="small"
        height="95%"
        width="95%"
        fullScreen
        // hideHeader
        // hideTitle
        // hideClose
        onClose={() => setShowModal(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>Full Screen w/ Header</Text>
          <Button onPress={() => setShowModal(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal2}
        title="Full Screen"
        headerFont="open-6"
        headerSize="small"
        height="95%"
        width="95%"
        fullScreen
        hideHeader
        // hideTitle
        // hideClose
        onClose={() => setShowModal2(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>Full Screen w/o Header</Text>
          <Button onPress={() => setShowModal2(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal3}
        title="Modal Title"
        headerFont="open-6"
        headerSize="small"
        height="95%"
        width="95%"
        // fullScreen
        // hideHeader
        hideTitle
        // hideClose
        onClose={() => setShowModal3(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>95% Screen w/o Title</Text>
          <Button onPress={() => setShowModal3(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Modal
        visible={showModal4}
        title="Modal Title"
        headerFont="open-6"
        headerSize="small"
        height="85%"
        width="85%"
        // fullScreen
        // hideHeader
        // hideTitle
        hideClose
        onClose={() => setShowModal4(false)}>
        <View
          style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
          }}>
          <Text>85% Screen w/o Close Button</Text>
          <Button onPress={() => setShowModal4(false)}>Close Modal</Button>
        </View>
      </Modal>
      <Button onPress={() => setShowModal(true)}>Show F/S w/ Header</Button>
      <Button onPress={() => setShowModal2(true)}>Show F/S w/o Header</Button>
      <Button onPress={() => setShowModal3(true)}>
        Show 95% Modal w/o Title
      </Button>
      <Button onPress={() => setShowModal4(true)}>
        Show 85% Modal w/o Close
      </Button>
    </Layout>
  );
};

export default __DEV__ ? DevModals : React.memo(DevModals);


--- FILE: src/screens/Dev/DevPlayground.jsx ---

//* DevPlayground.jsx
import React from 'react';
import {useIsFocused, useRoute} from '@react-navigation/native';
import {Layout, ScrollView, Text} from '../../KQ-UI';
import {
  useAccount,
  useCupboard,
  useProfile,
  useShoppingCart,
} from '../../hooks/useHooks';
import {View} from 'react-native';

const DevPlayground = () => {
  const isFocused = useIsFocused();
  const route = useRoute();
  const profile = useProfile();
  const account = useAccount();
  const shopping = useShoppingCart();
  const cupboard = useCupboard();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  const renderValue = value => {
    if (Array.isArray(value)) {
      return value.map((item, idx) => {
        if (typeof item === 'object' && item !== null) {
          return (
            <View key={idx} style={{marginLeft: 8, marginBottom: 12}}>
              <Text font="open-6" size="xSmall" style={{marginBottom: 4}}>
                {idx}:
              </Text>
              {Object.entries(item)
                .sort(([a, b]) => a.localeCompare(b))
                .map(([k, v], subIdx) => (
                  <Text
                    key={subIdx}
                    font="open-5"
                    size="xSmall"
                    style={{marginLeft: 16}}>
                    â€¢ {k}:{' '}
                    {typeof v === 'object' ? JSON.stringify(v) : String(v)}
                  </Text>
                ))}
            </View>
          );
        }

        return (
          <Text
            key={idx}
            font="open-5"
            size="xSmall"
            style={{marginLeft: 16, marginBottom: 8}}>
            {idx}: {String(item)}
          </Text>
        );
      });
    }

    if (typeof value === 'object' && value !== null) {
      return Object.entries(value)
        .sort(([a, b]) => a.localeCompare(b))
        .map(([k, v], idx) => (
          <Text
            key={idx}
            font="open-5"
            size="xSmall"
            style={{marginLeft: 16, marginBottom: 4}}>
            â€¢ {k}: {typeof v === 'object' ? JSON.stringify(v) : String(v)}
          </Text>
        ));
    }

    return (
      <Text font="open-5" size="xSmall" style={{marginLeft: 16}}>
        {String(value)}
      </Text>
    );
  };

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{}}>
      <ScrollView>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Profile</Text>
          {Object.entries(profile)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Account</Text>
          {Object.entries(account)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Shopping</Text>
          {Object.entries(shopping)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
        <View style={{borderWidth: 1, padding: 5}}>
          <Text>Cupboard</Text>
          {Object.entries(cupboard)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([key, value]) => (
              <View key={key} style={{marginBottom: 8}}>
                <Text font="open-7" size="xSmall">
                  {key}:
                </Text>
                {renderValue(value)}
              </View>
            ))}
        </View>
      </ScrollView>
    </Layout>
  );
};

export default DevPlayground;


--- FILE: src/screens/Dev/DevText.jsx ---

//* DevText.jsx
import React from 'react';
import {useRoute} from '@react-navigation/native';
import {Platform, View} from 'react-native';
import {Layout, Text} from '../../KQ-UI';

const DevText = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  const Row = ({children}) => (
    <View style={{flexDirection: 'row', width: '90%'}}>{children}</View>
  );

  const Cell = ({children}) => (
    <View
      style={{
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        borderWidth: 0.2,
        borderColor: '#00000090',
        margin: 5,
        height: 40,
      }}>
      {children}
    </View>
  );

  const TextBefore = ({font, text, weight, size, ...props}) => (
    <Text
      kqColor="black"
      style={{fontFamily: font, fontWeight: weight, fontSize: size || 20}}
      {...props}>
      {text}
    </Text>
  );

  const TextAfter = ({font, text, size, ...props}) => (
    <Text kqColor="black" font={font} style={{fontSize: size || 20}} {...props}>
      {text}
    </Text>
  );

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Light" weight={300} text="Noto 300" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-3" text="Noto 300" style={{color: 'purple'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Medium" weight={500} text="Noto 500" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-5" text="Noto 500" kqColor="primary" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="NotoSans-Bold" weight={700} text="Noto 700" />
        </Cell>
        <Cell>
          <TextAfter font="Noto-7" text="Noto 700" kqColor="success" />
        </Cell>
      </Row>

      <Row>
        <Cell>
          <TextBefore font="Montserrat-Light" weight={200} text="Mont 300" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-3" text="Mont 300" style={{color: 'blue'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="Montserrat-Medium" weight={500} text="Mont 500" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-5" text="Mont 500" kqColor="info" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="Montserrat-Bold" weight={700} text="Mont 700" />
        </Cell>
        <Cell>
          <TextAfter font="Mont-7" text="Mont 700" kqColor="warning" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Light" weight={300} text="Open 300" />
        </Cell>
        <Cell>
          <TextAfter font="open-3" text="Open 300" style={{color: 'aqua'}} />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Medium" weight={500} text="Open 500" />
        </Cell>
        <Cell>
          <TextAfter font="open-5" text="Open 500" kqColor="danger" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore font="OpenSans-Bold" weight={700} text="Open 700" />
        </Cell>
        <Cell>
          <TextAfter font="open-7" text="Open 700" kqColor="dark" />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore
            font={Platform.OS === 'ios' ? 'CherryBlossom' : 'Cherry-Blossom'}
            weight={500}
            size={22}
            text="Cherry Blossom"
          />
        </Cell>
        <Cell>
          <TextAfter
            font="cherry"
            text="Cherry Blossom"
            size={22}
            kqColor="basic"
          />
        </Cell>
      </Row>
      <Row>
        <Cell>
          <TextBefore
            font="BananaChips-Regular"
            text="Banana Chips"
            size={40}
            weight={500}
          />
        </Cell>
        <Cell>
          <TextAfter
            font="banana"
            text="Banana Chips"
            size={40}
            style={{color: 'gold'}}
          />
        </Cell>
      </Row>
      <Text font="open-6" size="large">
        The quick brown lazy dog.
      </Text>
    </Layout>
  );
};

export default DevText;


--- FILE: src/screens/Home/Home.jsx ---

//* Home.jsx
import React from 'react';
import {useRoute} from '@react-navigation/native';
import {Layout, Text} from '../../KQ-UI';

const Home = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton=""
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{justifyContent: 'center', alignItems: 'center'}}>
      <Text>Home</Text>
    </Layout>
  );
};

export default Home;


--- FILE: src/screens/Legal/LegalArray.js ---

//*LegalArray.js
export const LegalArray = {
  PP: [
    {
      dates: {effective: 'July 1, 2025', written: 'March 23, 2025'},
      version: {previous: '1.0.1', current: '1.0.2'},
      sections: [
        {
          index: 1,
          title: 'Information We Collect',
          clauses: [
            {
              index: 1,
              info: 'We collect and process the following types of information:',
              subClause: [
                {
                  index: 1,
                  info: 'Personal Data: Includes names, email addresses, and profile information provided by users during account creation.',
                },
                {
                  index: 2,
                  info: 'Household Data: Information about items entered by users into the app, such as shopping lists, cupboard inventories, and categories.',
                },
                {
                  index: 3,
                  info: 'Device Information: Information about the device used to access the app, such as device type and operating system, used solely to improve app functionality.',
                },
                {
                  index: 4,
                  info: 'Usage Data: Activity logs related to shopping, cupboard, and event features to enhance user experience.',
                },
                {
                  index: 5,
                  info: 'Third-Party Data: Retrieved via trusted APIs (e.g., barcode lookups and recipe suggestions) and processed according to those servicesâ€™ policies.',
                },
              ],
            },
          ],
        },
        {
          index: 2,
          title: 'How We Use Your Data',
          clauses: [
            {
              index: 1,
              info: 'Data is used to:',
              subClause: [
                {index: 1, info: 'Facilitate and improve core app features.'},
                {
                  index: 2,
                  info: 'Ensure a seamless experience across devices.',
                },
                {index: 3, info: 'Analyze and improve app performance.'},
                {
                  index: 4,
                  info: 'Support barcode lookup and recipe suggestions from third-party APIs.',
                },
              ],
            },
          ],
        },
        {
          index: 3,
          title: 'Data Sharing',
          clauses: [
            {
              index: 1,
              info: 'We do not sell or rent user data. Data is shared only with trusted third-party services strictly for feature functionality.',
              subClause: [
                {
                  index: 1,
                  info: 'Data may be passed to trusted APIs for features like UPC scanning or recipe search.',
                },
              ],
            },
          ],
        },
        {
          index: 4,
          title: 'Data Security',
          clauses: [
            {
              index: 1,
              info: 'We use secure, encrypted systems to store and manage user data. While best efforts are made, no system is entirely immune to risks.',
            },
          ],
        },
        {
          index: 5,
          title: 'User Rights',
          clauses: [
            {
              index: 1,
              info: 'Users have the right to:',
              subClause: [
                {index: 1, info: 'Access their personal data.'},
                {index: 2, info: 'Request corrections to their data.'},
                {
                  index: 3,
                  info: 'Request deletion of their account and associated data.',
                },
              ],
            },
          ],
        },
        {
          index: 6,
          title: "Children's Privacy",
          clauses: [
            {
              index: 1,
              info: 'This app is not intended for children under 13. Use by minors is the responsibility of the account holder.',
            },
          ],
        },
        {
          index: 7,
          title: 'Third-Party Services',
          clauses: [
            {
              index: 1,
              info: 'The app integrates trusted third-party services such as Edamam for features like barcode lookups and recipe suggestions. These services may collect data in accordance with their own privacy policies.',
            },
          ],
        },
        {
          index: 8,
          title: 'Changes to the Privacy Policy',
          clauses: [
            {
              index: 1,
              info: 'This policy may be updated periodically to reflect feature changes or legal requirements. Continued use of the app implies acceptance.',
            },
          ],
        },
      ],
    },
  ],
  TOS: [
    {
      dates: {effective: 'July 1, 2025', written: 'March 23, 2025'},
      version: {previous: '1.0.1', current: '1.0.2'},
      sections: [
        {
          index: 1,
          title: 'Acceptance of Terms',
          clauses: [
            {
              index: 1,
              info: 'By using Kitchen Queue, you agree to these terms. If you do not agree, discontinue use of the app.',
            },
          ],
        },
        {
          index: 2,
          title: 'Purpose of Kitchen Queue',
          clauses: [
            {
              index: 1,
              info: 'Kitchen Queue is designed to help users manage kitchen inventory, shopping lists, and meal planning.',
            },
          ],
        },
        {
          index: 3,
          title: 'User Responsibilities',
          clauses: [
            {
              index: 1,
              info: 'Users must use the app for its intended household planning and food management purposes only.',
            },
            {
              index: 2,
              info: 'Prohibited use includes illegal content, including drug-related items or activity.',
            },
            {
              index: 3,
              info: 'Users are responsible for ensuring their data is accurate and purposeful.',
            },
            {
              index: 4,
              info: 'Kitchen Queue is not responsible for any inaccuracies or misuse of user-entered data.',
            },
          ],
        },
        {
          index: 4,
          title: 'Age Restrictions',
          clauses: [
            {
              index: 1,
              info: 'The app is not intended for users under 13 years old.',
            },
            {
              index: 2,
              info: 'Account holders are responsible for the data entered by any minor users they authorize.',
            },
            {
              index: 3,
              info: 'Unauthorized accounts for children under 13 will be deleted.',
            },
          ],
        },
        {
          index: 5,
          title: 'Data Usage and Limitations',
          clauses: [
            {
              index: 1,
              info: 'Users are fully responsible for managing and verifying their own data within the app.',
            },
          ],
        },
        {
          index: 6,
          title: 'Third-Party Services',
          clauses: [
            {
              index: 1,
              info: 'The app uses services such as Edamam for recipe suggestions and barcode lookups. Users must comply with the terms of these third-party providers.',
            },
          ],
        },
        {
          index: 7,
          title: 'Changes to Terms',
          clauses: [
            {
              index: 1,
              info: 'Terms may be updated from time to time. Continued use of the app confirms your acceptance of any updates.',
            },
          ],
        },
        {
          index: 8,
          title: 'Limitation of Liability',
          clauses: [
            {
              index: 1,
              info: 'Kitchen Queue is not liable for misuse, data errors, or third-party service issues. The app is provided as-is.',
            },
          ],
        },
        {
          index: 9,
          title: 'Governing Law',
          clauses: [
            {
              index: 1,
              info: 'These terms are governed by the laws of the State of North Dakota, USA.',
            },
          ],
        },
        {
          index: 10,
          title: 'Subscriptions and Payments',
          clauses: [
            {
              index: 1,
              info: 'All subscriptions and in-app purchases are handled exclusively through Apple and Googleâ€™s platforms. Kitchen Queue does not process or store any payment data.',
            },
          ],
        },
      ],
    },
  ],

  About: [
    {
      sections: [
        {
          index: 1,
          title: 'Discover Kitchen Queue',
          clauses: [
            {
              index: 1,
              info: 'Kitchen Queue is your ultimate household companion for managing shopping, inventory, and meal planning.',
              subClause: [
                {
                  index: 1,
                  info: 'Create shopping lists and move items between list/cart/cupboard.',
                },
                {
                  index: 2,
                  info: 'Up to 4 users per household, collaborating in real-time.',
                },
                {
                  index: 3,
                  info: 'Barcode scanning and recipe searching powered by Edamam.',
                },
              ],
            },
          ],
        },
        {
          index: 2,
          title: 'Whatâ€™s Coming Soon',
          clauses: [
            {
              index: 1,
              info: 'Recipe Box and Community Recipes',
              subClause: [
                {index: 1, info: 'Store and share your favorite meals.'},
                {
                  index: 2,
                  info: 'Auto-check your cupboard for required ingredients.',
                },
              ],
            },
            {
              index: 2,
              info: 'Smart Meal Planning and UPC History',
              subClause: [
                {
                  index: 1,
                  info: 'View past scanned items and plan meals accordingly.',
                },
              ],
            },
            {
              index: 3,
              info: 'Events and Guest Lists',
              subClause: [
                {
                  index: 1,
                  info: 'Organize shared meals and let guests claim food items.',
                },
              ],
            },
          ],
        },
      ],
    },
  ],
};


--- FILE: src/screens/Legal/PrivacyPolicy.jsx ---

//* PrivacyPolicy.jsx
import React from 'react';
import {View} from 'react-native';
import {LegalStyles} from '../../styles/Styles';
import {LegalArray} from './LegalArray';
import {Text, Button, ScrollView} from '../../KQ-UI';

export default function PrivacyPolicy({
  handlePPConfirm,
  handleCancel,
  hideConfirm,
}) {
  let terms = LegalArray.PP[0];

  const RenderTermData = ({terms}) => {
    return terms.sections.map(section => (
      <View key={section.index} style={LegalStyles.sectionWrapper}>
        <View style={LegalStyles.sectionHeader}>
          <View style={LegalStyles.sectionIndex}>
            <Text size="small">{section.index}.</Text>
          </View>
          <View style={LegalStyles.sectionTitle}>
            <Text size="small">{section.title}:</Text>
          </View>
        </View>
        {section.clauses.map(clause => (
          <View key={clause.index} style={LegalStyles.clauseWrapper}>
            <View style={LegalStyles.clauseHeader}>
              <View style={LegalStyles.clauseIndexSpacing}></View>
              <View style={LegalStyles.clauseTextWrapper}>
                <Text size="small" style={LegalStyles.clauseInfo}>
                  {clause.info}
                </Text>
              </View>
            </View>
            {clause.subClause?.length > 0 && (
              <View style={LegalStyles.subClauseWrapper}>
                {clause.subClause.map(sub => (
                  <View key={sub.index} style={LegalStyles.subClauseHeader}>
                    <View style={LegalStyles.bulletWrapper}>
                      <Text size="small">{'\u2022'}</Text>
                    </View>
                    <View style={LegalStyles.subClauseTextWrapper}>
                      <Text size="small" style={LegalStyles.clauseInfo}>
                        {sub.info}
                      </Text>
                    </View>
                  </View>
                ))}
              </View>
            )}
          </View>
        ))}
      </View>
    ));
  };
  return (
    <View style={LegalStyles.container}>
      <View
        style={[
          LegalStyles.body,
          hideConfirm ? {paddingBottom: 20} : {paddingBottom: 10},
        ]}>
        <ScrollView>
          <RenderTermData terms={terms} />
        </ScrollView>
      </View>
      {!hideConfirm && (
        <View style={LegalStyles.buttonWrapper}>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="danger"
              size="small"
              onPress={() => handleCancel('Privacy Policy')}>
              Cancel
            </Button>
          </View>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="success"
              size="small"
              onPress={() => handlePPConfirm()}>
              Confirm
            </Button>
          </View>
        </View>
      )}
    </View>
  );
}


--- FILE: src/screens/Legal/TermsService.jsx ---

//* TermsService.jsx
import React from 'react';
import {View} from 'react-native';
import {LegalStyles} from '../../styles/Styles';
import {LegalArray} from './LegalArray';
import {Text, Button, ScrollView} from '../../KQ-UI';

export default function TermsService({
  handleTOSConfirm,
  handleCancel,
  hideConfirm,
}) {
  let terms = LegalArray.TOS[0];

  const RenderTermData = ({terms}) => {
    return terms.sections.map(section => (
      <View key={section.index} style={LegalStyles.sectionWrapper}>
        <View style={LegalStyles.sectionHeader}>
          <View style={LegalStyles.sectionIndex}>
            <Text size="small">{section.index}.</Text>
          </View>
          <View style={LegalStyles.sectionTitle}>
            <Text size="small">{section.title}:</Text>
          </View>
        </View>
        {section.clauses.map(clause => (
          <View key={clause.index} style={LegalStyles.clauseWrapper}>
            <View style={LegalStyles.clauseHeader}>
              <View style={LegalStyles.clauseIndexSpacing}></View>
              <View style={LegalStyles.clauseTextWrapper}>
                <Text size="small">{clause.info}</Text>
              </View>
            </View>
            {clause.subClause?.length > 0 && (
              <View style={LegalStyles.subClauseWrapper}>
                {clause.subClause.map(sub => (
                  <View key={sub.index} style={LegalStyles.subClauseHeader}>
                    <View style={LegalStyles.bulletWrapper}>
                      <Text size="small">{'\u2022'}</Text>
                    </View>
                    <View style={LegalStyles.subClauseTextWrapper}>
                      <Text size="small">{sub.info}</Text>
                    </View>
                  </View>
                ))}
              </View>
            )}
          </View>
        ))}
      </View>
    ));
  };

  return (
    <View style={LegalStyles.container}>
      <View
        style={[
          LegalStyles.body,
          hideConfirm ? {paddingBottom: 20} : {paddingBottom: 10},
        ]}>
        <ScrollView>
          <RenderTermData terms={terms} />
        </ScrollView>
      </View>
      {!hideConfirm && (
        <View style={LegalStyles.buttonWrapper}>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="danger"
              size="small"
              onPress={() => handleCancel('Terms of Service')}>
              Cancel
            </Button>
          </View>
          <View style={LegalStyles.buttonCells}>
            <Button
              color="success"
              size="small"
              onPress={() => handleTOSConfirm()}>
              Confirm
            </Button>
          </View>
        </View>
      )}
    </View>
  );
}


--- FILE: src/screens/Shopping/ShoppingCart.jsx ---

//* ShoppingCart.jsx
import React, {useCallback, useState} from 'react';
import {useNavigation, useRoute} from '@react-navigation/native';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useAccount, useShoppingCart} from '../../hooks/useHooks';
import {Alert, View} from 'react-native';
import {ListStyles} from '../../styles/Styles';
import SwipeableItem from '../../components/SwipeableItem';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';
import SelectedItemInfo from '../../components/SelectedItemInfo';

const ShoppingCart = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  const core = useCoreInfo();
  const account = useAccount();
  const shopping = useShoppingCart();
  const navigation = useNavigation();
  const dispatch = useDispatch();

  const shoppingCart =
    shopping?.items.filter(item => item?.status === 'shopping-cart') ?? [];

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  const handleReturnToList = useCallback(
    itemId => {
      const item = shoppingCart.find(item => item.itemId === itemId);
      if (item && core.profileID) {
        const updatedItem = {
          ...item,
          status: 'shopping-list',
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: core.profileID,
        };
        dispatch({
          type: 'UPDATE_ITEM_IN_SHOP_CART',
          payload: {
            shoppingCartID: core.shoppingCartID,
            updatedItem,
            profileID: core.profileID,
            updateType: 'toList',
          },
        });
      }
    },
    [dispatch, core, shoppingCart],
  );

  const handleUpdateItem = itemId => {
    navigation.navigate('ShoppingItems', {
      title: 'Update Item',
      itemId,
      navigateBackTo: 'ShoppingCart',
      statusTo: 'shopping-cart',
    });
  };

  const handleDeleteItem = useCallback(
    itemId => {
      if (core.profileID) {
        const item = shoppingCart.find(item => item.itemId === itemId);
        if (item) {
          dispatch({
            type: 'DELETE_ITEM_FROM_SHOP_CART',
            payload: {
              shoppingCartID: core.shoppingCartID,
              itemId: item.itemId,
              itemName: item.itemName,
              profileID: core.profileID,
            },
          });
        }
      }
    },
    [dispatch, core, shoppingCart],
  );

  const AddToCupboard = () => {
    if (shoppingCart?.length > 0) {
      Alert.alert(
        'Confirm Checkout',
        'Are you ready to move your shopping cart items to your cupboard?',
        [
          {
            text: 'Cancel',
            style: 'destructive',
          },
          {
            text: 'Confirm',
            onPress: () => {
              dispatch({
                type: 'BATCH_TO_CUPBOARD',
                payload: {
                  cupboardID: core.cupboardID,
                  items: shoppingCart,
                  profileID: core.profileID,
                },
              });

              dispatch({
                type: 'DELETE_LIST_FROM_SHOP_CART',
                payload: {
                  shoppingCartID: account.shoppingCartID,
                  items: shoppingCart,
                  profileID: core.profileID,
                },
              });

              navigation.navigate('CupboardList-Single');
            },
          },
        ],
      );
    }
  };

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
        navigate={{to: 'ShoppingItems', backTo: 'ShoppingCart'}}
      />
    </BottomSheet>
  );

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton="To-List"
      RightButton="Checkout"
      LeftAction={null}
      RightAction={AddToCupboard}
      sheetOpen={false}
      innerViewStyles={{
        justifyContent: 'center',
        alignItems: 'center',
      }}
      outerViewStyles={{paddingBottom: 0}}>
      {shoppingCart.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Shopping List is Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            list={shoppingCart}
            core={core}
            showItemInfo={showItemInfo}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            rightButtons={[
              {
                action: itemId => handleReturnToList(itemId),
                text1: 'Return',
                text2: 'to List',
                style: ListStyles.addButton,
              },
              {
                action: itemId => handleUpdateItem(itemId),
                navigateBackTo: 'InCart',
                text1: 'Update',
                text2: 'Item',
                style: ListStyles.updateButton,
              },
              {
                action: itemId => handleDeleteItem(itemId),
                text1: 'Delete',
                style: ListStyles.deleteButton,
              },
            ]}
            leftButtons={[]}
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default ShoppingCart;


--- FILE: src/screens/Shopping/ShoppingItems.jsx ---

//* ShoppingItems.jsx

import {useNavigation, useRoute} from '@react-navigation/native';
import React, {useEffect, useState} from 'react';
import {Dropdown, Input, Layout} from '../../KQ-UI';
import {useShoppingCart} from '../../hooks/useHooks';
import {displayMeasurements} from '../../utilities/measurements';
import {displayCategories} from '../../utilities/categories';
import {displayCustom, setNumericValue} from '../../utilities/helpers';
import {View} from 'react-native';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';

const ShoppingItems = () => {
  const route = useRoute();
  const {
    title,
    bgColor,
    textColor,
    headerColor,
    itemId,
    navigateBackTo,
    statusTo,
  } = route.params || {};

  const dispatch = useDispatch();
  const core = useCoreInfo();
  const navigation = useNavigation();
  const shopping = useShoppingCart();

  const itemToUpdate =
    shopping?.items?.find(item => item.itemId === itemId) ?? null;

  const [itemName, setItemName] = useState(itemToUpdate?.itemName ?? null);
  const [brandName, setBrandName] = useState(itemToUpdate?.brandName ?? '');
  const [description, setDescription] = useState(
    itemToUpdate?.description ?? '',
  );
  const [packageSize, setPackageSize] = useState(
    String(itemToUpdate?.packageSize ?? '1'),
  );
  const [quantity, setQuantity] = useState(
    String(itemToUpdate?.quantity ?? '1'),
  );
  const [measurement, setMeasurement] = useState(
    displayCustom(itemToUpdate?.measurement, displayMeasurements) ?? null,
  );
  const [category, setCategory] = useState(
    displayCustom(itemToUpdate?.category, displayMeasurements) ?? null,
  );
  const [notes, setNotes] = useState(itemToUpdate?.notes ?? '');

  const [validation, setValidation] = useState(false);

  const [canSave, setCanSave] = useState(false);

  const updateType =
    statusTo === 'shopping-list'
      ? 'updateList'
      : statusTo === 'shopping-cart'
      ? 'updateCart'
      : 'updateList';

  useEffect(() => {
    if (itemName === null) {
      setValidation(false);
      setCanSave(false);
    } else if (itemName === '') {
      setValidation(true);
      setCanSave(false);
    } else {
      setValidation(false);
      setCanSave(true);
    }
  }, [itemName]);

  const resetForm = () => {
    setItemName(null);
    setBrandName('');
    setDescription('');
    setPackageSize('1');
    setQuantity('1');
    setMeasurement(null);
    setCategory(null);
    setNotes('');
  };

  const SaveItem = () => {
    if (itemName === '' || itemName === null) {
      setValidation(true);
    } else {
      setValidation(false);

      const newItem = {
        itemName: itemName || '',
        brandName: brandName || '',
        description: description || '',
        packageSize: Number(packageSize) > 0 ? Number(packageSize) : 1,
        quantity: Number(quantity) > 0 ? Number(quantity) : 1,
        measurement: measurement?.key || '',
        category: category?.key || '',
        notes: notes || '',
        status: statusTo || 'shopping-list',
      };

      const updatedItem = {
        ...itemToUpdate,
        ...newItem,
      };

      if (itemToUpdate) {
        dispatch({
          type: 'UPDATE_ITEM_IN_SHOP_CART',
          payload: {
            shoppingCartID: core.shoppingCartID,
            updatedItem,
            updateType,
            profileID: core.profileID,
          },
        });
      } else {
        dispatch({
          type: 'ADD_ITEM_TO_SHOP_CART',
          payload: {
            shoppingCartID: core.shoppingCartID,
            newItem: newItem,
            profileID: core.profileID,
          },
        });
      }

      resetForm();
    }
  };

  const handleClose = () => {
    // dispatch({type: 'RESET_FOOD_DATA'}); // this is for edamam later
    resetForm();
    // setStoredData(null); // this is for edamam later
    navigation.navigate(navigateBackTo);
  };

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton="Close"
      RightButton={canSave ? 'Save' : null}
      LeftAction={handleClose}
      RightAction={canSave ? SaveItem : null}
      sheetOpen={false}
      outerViewStyles={{paddingBottom: 0}}>
      <Input
        required
        label="Item Name"
        value={itemName}
        onChangeText={setItemName}
        validation={validation}
        validationMessage="Item Name is required"
        capitalize
        capitalMode="words"
      />
      <Input
        label="Brand Name"
        value={brandName}
        onChangeText={setBrandName}
        capitalize
        capitalMode="words"
      />
      <Input
        label="Description"
        value={description}
        onChangeText={setDescription}
        capitalize
        capitalMode="sentences"
      />
      <View style={{flexDirection: 'row'}}>
        <View style={{flex: 1}}>
          <Input
            label="Quantity"
            value={quantity}
            onChangeText={setNumericValue(setQuantity)}
            caption="Example: 2 Cartons"
            // capitalMode="sentences"
          />
        </View>
        <View style={{flex: 1}}>
          <Input
            label="Package Size"
            value={packageSize}
            onChangeText={setNumericValue(setPackageSize)}
            caption="Example: 12 Eggs"
            capitalMode="sentences"
          />
        </View>
      </View>
      <Dropdown
        label="Measurement"
        customLabel="Custom Measurement"
        placeholder="Select a measurement"
        value={measurement}
        setValue={setMeasurement}
        caption={'Single is for individual items. Ex: Eggs'}
        mapData={displayMeasurements}
      />
      <Dropdown
        label="Category"
        placeholder="Select a category"
        value={category}
        setValue={setCategory}
        mapData={displayCategories}
      />
      <Input
        label="Notes"
        value={notes}
        onChangeText={setNotes}
        multiline
        multiHeight="large"
        caption="Add notes here"
        counter
        maxCount={250}
      />
    </Layout>
  );
};

export default ShoppingItems;


--- FILE: src/screens/Shopping/ShoppingList.jsx ---

//* ShoppingList.jsx
import React, {useCallback, useState} from 'react';
import {useNavigation, useRoute} from '@react-navigation/native';
import {BottomSheet, Layout, Text} from '../../KQ-UI';
import {useShoppingCart} from '../../hooks/useHooks';
import {View} from 'react-native';
import {ListStyles} from '../../styles/Styles';
import SwipeableItem from '../../components/SwipeableItem';
import {useDispatch} from 'react-redux';
import {useCoreInfo} from '../../utilities/coreInfo';
import SelectedItemInfo from '../../components/SelectedItemInfo';

const ShoppingList = () => {
  const route = useRoute();
  const {title, headerColor, bgColor, textColor, screenLocation} = route.params;
  const shopping = useShoppingCart();
  const navigation = useNavigation();
  const core = useCoreInfo();
  const dispatch = useDispatch();

  const shoppingList =
    shopping?.items?.filter(item => item.status === 'shopping-list') ?? [];

  const [showItemInfo, setShowItemInfo] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  const handleAddToCart = useCallback(
    itemId => {
      const item = shoppingList.find(item => item.itemId === itemId);
      if (item && core.profileID) {
        const updatedItem = {
          ...item,
          status: 'shopping-cart',
          lastUpdated: new Date().toISOString(),
          lastUpdatedBy: core.profileID,
        };
        dispatch({
          type: 'UPDATE_ITEM_IN_SHOP_CART',
          payload: {
            shoppingCartID: core.shoppingCartID,
            updatedItem,
            profileID: core.profileID,
            updateType: 'toCart',
          },
        });
      }
    },
    [dispatch, core.profileID, shoppingList],
  );

  const handleUpdateItem = itemId => {
    navigation.navigate('ShoppingItems', {
      title: 'Update Item',
      itemId,
      navigateBackTo: 'ShoppingList',
      statusTo: 'shopping-list',
    });
  };

  const handleDeleteItem = useCallback(
    itemId => {
      if (core.profileID) {
        const item = shoppingList.find(item => item.itemId === itemId);
        if (item) {
          dispatch({
            type: 'DELETE_ITEM_FROM_SHOP_CART',
            payload: {
              shoppingCartID: core.shoppingCartID,
              itemId: item.itemId,
              itemName: item.itemName,
              profileID: core.profileID,
            },
          });
        }
      }
    },
    [dispatch, core.profileID, shoppingList],
  );

  const SelectedItem = () => (
    <BottomSheet
      visible={showItemInfo}
      onClose={() => setShowItemInfo(false)}
      snapPoints={[0.01, 0.9]}>
      <SelectedItemInfo
        selectedItem={selectedItem}
        setShowItemInfo={setShowItemInfo}
        navigate={{to: 'ShoppingItems', backTo: 'ShoppingList'}}
      />
    </BottomSheet>
  );

  return (
    <Layout
      bgColor={bgColor}
      headerTitle={title}
      headerColor={headerColor}
      textColor={textColor}
      LeftButton=""
      RightButton="To-Cart"
      LeftAction={null}
      RightAction={null}
      sheetOpen={false}
      innerViewStyles={{
        justifyContent: 'center',
        alignItems: 'center',
      }}
      outerViewStyles={{paddingBottom: 0}}>
      {shoppingList.length === 0 ? (
        <View
          style={[
            ListStyles.viewContainer,
            {justifyContent: 'center', alignItems: 'center'},
          ]}>
          <Text>Shopping List is Empty</Text>
        </View>
      ) : (
        <View style={ListStyles.viewContainer}>
          <SwipeableItem
            list={shoppingList}
            core={core}
            showItemInfo={showItemInfo}
            setShowItemInfo={setShowItemInfo}
            setSelectedItem={setSelectedItem}
            rightButtons={[
              {
                action: itemId => handleAddToCart(itemId),
                text1: 'Add',
                text2: 'to Cart',
                style: ListStyles.addButton,
              },
              {
                action: itemId => handleUpdateItem(itemId),
                navigateBackTo: 'ShoppingList',
                text1: 'Update',
                text2: 'Item',
                style: ListStyles.updateButton,
              },
              {
                action: itemId => handleDeleteItem(itemId),
                text1: 'Delete',
                style: ListStyles.deleteButton,
              },
            ]}
            leftButtons={[]}
          />
          <SelectedItem />
        </View>
      )}
    </Layout>
  );
};

export default ShoppingList;


--- FILE: src/styles/Styles.jsx ---

//* Styles.jsx
import {StyleSheet} from 'react-native';

export const AppStyles = StyleSheet.create({
  navMenu: {
    height: 90,
  },
  safeArea: {
    flex: 1,
    margin: 5,
  },
  globalContainer: {
    flex: 1,
  },
});

export const NavMenuStyles = StyleSheet.create({
  container: {flex: 1},
  wrapper: {
    height: '100%',
    width: '100%',
    position: 'absolute',
    backgroundColor: 'transparent',
    flexDirection: 'row',
    padding: 5,
  },
});

export const CurvedBarStyles = StyleSheet.create({
  fillColor: '#f7f7f7',
  strokeColor: '#373d4340',
  strokeWidth: 1.5,
  shadowStroke: '#373d4320',
  shadowStrokeWidth: 4,
});

export const MenuButtonStyles = StyleSheet.create({
  wrapper: {
    height: '100%',
    width: '100%',
    position: 'absolute',
    flexDirection: 'row',
    zIndex: 2000, // Bottom Layer
    paddingHorizontal: 5,
  },
  container: {
    flex: 1,
    height: 65,
    position: 'relative',
    top: -21,
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    zIndex: 2100, // Middle Layer
  },
  button: {
    borderWidth: 1,
    height: 55,
    width: 55,
    borderRadius: 30,
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    borderColor: '#c4c4c480',
    backgroundColor: '#319177',
    zIndex: 2300, // Over Layer
  },
  menuButton: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2200, // Top Layer
  },
});

export const ListStyles = StyleSheet.create({
  actionButton: {
    alignItems: 'center',
    borderRadius: 5,
    justifyContent: 'center',
    marginHorizontal: 3,
    width: 90,
    // height: 60,
  },
  actionsContainer: {
    alignItems: 'top',
    flexDirection: 'row',
    justifyContent: 'flex-end',
    paddingRight: 10,
    paddingLeft: 5,
    paddingVertical: 5,
    // borderBottomWidth: 1,
    borderColor: '#c4c4c4',
  },
  addButton: {
    backgroundColor: '#44B3B3',
  },
  bottomInnerContainer: {
    borderColor: '#c4c4c4',
    borderTopWidth: 1,
    height: 58,
    justifyContent: 'center',
    marginHorizontal: -5,
  },
  bottomLeft: {
    flex: 1,
    paddingLeft: 10,
    paddingRight: 5,
  },
  bottomRight: {
    flex: 1,
    paddingLeft: 5,
    paddingRight: 10,
  },
  bottomCenter: {width: '50%', paddingLeft: 5, paddingRight: 5},
  buttonContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    // padding: 2,
    width: '100%',
    height: '100%',
    backgroundColor: 'transparent',
  },
  buttonText: {
    color: '#fff',
    textAlign: 'center',
  },
  container: {
    backgroundColor: '#ffffff',
    width: '100%',
    flex: 1,
  },
  deleteButton: {
    backgroundColor: '#fE4949',
  },
  viewContainer: {
    flex: 1,
    backgroundColor: '#ffffff',
    width: '100%',
  },
  updateButton: {
    backgroundColor: '#0077A2',
  },
  bottomSheet: {
    zIndex: 9000,
    borderColor: 'transparent',
    borderRadius: 18,
  },

  rmcContainer: {flex: 1},
  rmcImage: {alignItems: 'center', justifyContent: 'center'},
  rmcTitle: {
    marginHorizontal: 5,
    marginVertical: 2,
    alignItems: 'center',
    paddingVertical: 2,
  },
  rmcBrand: {
    marginHorizontal: 5,
    marginTop: 2,
    marginBottom: 5,
    alignItems: 'center',
    paddingVertical: 2,
  },
  rmcScroll: {
    flex: 1,
    paddingVertical: 5,
    paddingHorizontal: 5,
  },
  rmcScrollShellTop: {height: 5},
  rmcScrollShellBottom: {height: 15},
  rmcScrollWrapper: {
    paddingVertical: 2,
    paddingHorizontal: 5,
  },
  rmcNutrientLabel: {
    flex: 1,
    borderBottomWidth: 1,
    padding: 2,
    paddingBottom: 1,
    justifyContent: 'center',
  },
  rmcNutrientValue: {
    borderBottomWidth: 1,
    alignItems: 'flex-end',
    padding: 2,
    paddingBottom: 1,
    justifyContent: 'center',
  },
  rmcContents: {borderWidth: 0, marginTop: 10, paddingHorizontal: 5},
  rmcButtonWrapper: {flexDirection: 'row', paddingHorizontal: 5},
  rmcButtonContainer: {flex: 1, marginHorizontal: 5},
  rmcDisclaimer: {marginTop: 3, marginHorizontal: 5, paddingHorizontal: 2},
});

export const NavHeaderStyles = StyleSheet.create({
  header: {
    alignItems: 'center',
    backgroundColor: '#fff',
    borderColor: '#c4c4c490',
    borderBottomWidth: 1,
    elevation: 5,
    shadowColor: '#c4c4c490',
    shadowOffset: {width: 0, height: 4},
    shadowOpacity: 0.8,
  },
  titleContainer: {
    position: 'absolute',
    top: 0,
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2000,
  },
  buttonContainer: {
    position: 'absolute',
    top: 0,
    width: '100%',
    height: '100%',
    zIndex: 2001,
  },
  buttonRows: {flexDirection: 'row', height: '100%'},
  sideContainers: {
    flex: 1,
    justifyContent: 'center',
    paddingLeft: 15,
  },
  leftWrapper: {flexDirection: 'row', marginLeft: 0},
  leftContainer: {flex: 1, justifyContent: 'center'},
  rightWrapper: {flexDirection: 'row', marginRight: 10},
  rightContainer: {
    flex: 1,
    justifyContent: 'center',
    alignContent: 'flex-end',
    alignItems: 'flex-end',
  },
  rightContainerAlt: {
    flex: 1,
    justifyContent: 'center',
    alignContent: 'flex-end',
    alignItems: 'flex-end',
    marginRight: 5,
  },
  iconPosition: {position: 'relative', top: 1},
  textStyles: {
    fontSize: 16,
  },
});

export const ScreenStyles = StyleSheet.create({
  container: {
    backgroundColor: '#ffffff',
    flex: 1,
  },
  error: {
    color: 'red',
    flex: 1,
    fontSize: 18,
    textAlign: 'center',
  },
  errorContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  success: {
    color: 'green',
    flex: 1,
    fontSize: 22,
    marginBottom: 20,
    marginTop: 20,
    textAlign: 'center',
  },
  successContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  viewContainer: {
    flex: 1,
    paddingBottom: 2,
    padding: 5,
  },
  viewInnerTopContainer: {
    alignItems: 'center',
    paddingTop: 20,
    paddingBottom: 5,
    paddingHorizontal: 15,
  },
  scrollContainer: {
    flex: 1,
    paddingVertical: 10,
  },
});

export const SelectItemStyles = StyleSheet.create({
  container: {
    marginHorizontal: 2.5,
    flex: 1,
  },
  imageContainer: {
    flex: 0.3,
    alignItems: 'center',
    justifyContent: 'center',
  },
  updateContainer: {
    padding: 0,
    marginVertical: -5,
  },
  infoContainer: {
    flex: 0.7,
    paddingHorizontal: 5,
  },
  itemContainer: {
    flexDirection: 'row',
    borderBottomWidth: 1.5,
    borderRadius: 8,
    borderBottomColor: '#c4c4c490',
    paddingBottom: 6,
    paddingTop: 3,
  },
  itemNoteContainer: {
    borderRadius: 8,
    borderBottomColor: '#c4c4c4',
    paddingBottom: 3,
    paddingTop: 7,
  },
  titleWrap: {paddingTop: 3, paddingHorizontal: 3},
  infoWrap: {
    flex: 1,
    paddingTop: 3,
    paddingHorizontal: 4,
  },
  infoNoteWrap: {
    paddingTop: 3,
    paddingHorizontal: 4,
  },
  textStyles: {textAlign: 'right'},
  textNoteStyles: {letterSpacing: 0.2, textAlign: 'justify'},
});

export const LegalStyles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'column',
    paddingVertical: 15,
  },
  body: {
    flex: 1,
  },
  buttonWrapper: {
    flexDirection: 'row',
  },
  buttonCells: {
    flex: 1,
    paddingHorizontal: 5,
  },
  sectionWrapper: {
    marginVertical: 5,
  },
  sectionHeader: {
    flexDirection: 'row',
  },
  sectionIndex: {
    width: 40,
    alignItems: 'flex-end',
    paddingRight: 3,
    paddingVertical: 3,
  },
  sectionTitle: {
    flex: 1,
    alignItems: 'flex-start',
    paddingLeft: 3,
    paddingVertical: 3,
  },
  clauseWrapper: {},
  clauseHeader: {
    flexDirection: 'row',
  },
  clauseIndexSpacing: {width: 39},
  clauseTextWrapper: {
    flex: 1,
    paddingVertical: 3,
    paddingLeft: 3,
    paddingRight: 20,
    paddingBottom: 5,
  },
  subClauseWrapper: {},
  subClauseHeader: {flexDirection: 'row'},
  bulletWrapper: {
    width: 55,
    alignItems: 'flex-end',
    paddingRight: 3,
  },
  subClauseTextWrapper: {
    flex: 1,
    paddingVertical: 2,
    paddingLeft: 3,
    paddingRight: 25,
    paddingBottom: 10,
  },
  clauseInfo: {},
});

export const SettingsStyles = StyleSheet.create({
  card: {
    marginTop: 15,
    marginHorizontal: 15,
    backgroundColor: '#319177',
    borderTopRightRadius: 8,
    borderTopLeftRadius: 8,
    borderWidth: 1,
    borderBottomWidth: 0.5,
    borderColor: '#c4c4c4',
  },
  cardTitle: {marginVertical: 10, color: '#fff'},
  topContainer: {
    borderTopWidth: 1,
    borderColor: '#c4c4c4',
    height: 70,
    backgroundColor: '#fff',
    flexDirection: 'row',
    height: 70,
  },
  innerTopContainer: {
    width: 70,
    padding: 8,
  },
  quantityCell: {
    borderWidth: 1,
    borderRadius: 8,
    borderColor: '#c4c4c4',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  infoCell: {
    flex: 1,
    marginVertical: 5,
    marginRight: 5,
    justifyContent: 'center',
    padding: 0,
  },
  bottomContainer: {
    marginHorizontal: 15,
    borderWidth: 1,
    borderTopWidth: 0.5,
    borderBottomRightRadius: 8,
    borderBottomLeftRadius: 8,
    paddingVertical: 7,
    borderColor: '#c4c4c4',
  },
  buttonContainer: {alignContent: 'center', alignItems: 'center'},

  listContainer: {
    paddingHorizontal: 10,
  },
  itemContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 15,
    marginVertical: 5,
    borderRadius: 5,
    borderWidth: 1,
    borderColor: '#dcdcdc',
  },
  description: {
    marginVertical: 10,
  },
  segmentedButtonContainer: {
    flexDirection: 'row',
    paddingHorizontal: 15,
    gap: 10,
  },
  hapticButton: {
    elevation: 3,
    shadowColor: '#373d43',
    shadowOffset: {width: 1, height: 2},
    shadowOpacity: 0.3,
    borderRadius: 5,
    marginVertical: 10,
    marginHorizontal: 5,
    alignContent: 'center',
    alignItems: 'center',
    justifyContent: 'center',
    borderColor: '#319177',
    height: 45,
  },
  hbInner: {
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    flex: 1,
    width: '100%',
    flexDirection: 'row',
  },
});

export const KQDropStyles = StyleSheet.create({
  dropdownContainer: {
    marginVertical: 5,
    marginHorizontal: 7,
  },
  labelContainer: {
    marginBottom: 4,
    marginLeft: 5,
  },
  dropdown: {
    borderWidth: 1,
    borderRadius: 5,
    borderColor: '#c4c4c4',
    minHeight: 40,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 8,
  },
  iconContainer: {
    width: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  sheetContentContainer: {
    paddingVertical: 16,
  },
  sheetItem: {
    paddingVertical: 16,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  sheetItemText: {
    fontSize: 18,
  },
  bottomSheet: {
    zIndex: 9000,
    borderColor: 'transparent',
    borderWidth: 4,
    borderRadius: 18,
  },
  captionWrap: {marginHorizontal: 10, marginBottom: 5},
  captionText: {
    color: '#373d4390',
  },
});

export const AvatarStyles = StyleSheet.create({
  avatarCard: {
    // width: 80,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'transparent',
  },
  avatarView: {
    width: 100,
    height: 100,
    borderWidth: 1,
    borderRadius: 50,
    overflow: 'hidden',
  },
});

export const ProfileStyles = StyleSheet.create({
  FTCenter: {textAlign: 'center'},
  FTLeft: {
    // fontWeight: 700,
    textAlign: 'right',
    marginRight: 5,
  },
  FTRight: {marginLeft: 5},
  optionContainer: {height: 35, flexDirection: 'row', marginVertical: 4},
  optionLeft: {
    borderWidth: 1,
    borderColor: '#373d43',
    borderTopLeftRadius: 8,
    borderBottomLeftRadius: 8,
    width: 40,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 1, height: 2},
    shadowOpacity: 0.3,
    elevation: 5,
  },
  olInner: {
    position: 'relative',
    left: 5,
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
  optionRight: {
    borderWidth: 1,
    borderColor: '#373d43',
    borderTopRightRadius: 8,
    borderBottomRightRadius: 8,
    width: 40,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 2, height: 3},
    shadowOpacity: 0.3,
    elevation: 5,
  },
  orInner: {
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
  optionView: {
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: '#373d43',
    justifyContent: 'center',
    alignItems: 'center',
    width: 150,
    backgroundColor: '#fff',
    shadowColor: 'black',
    shadowOffset: {width: 2, height: 3},
    shadowOpacity: 0.3,
    elevation: 5,
  },
});

export const AccountStyles = StyleSheet.create({
  section: {flex: 1, backgroundColor: '#fff', padding: 5, marginBottom: 10},
  sectionNav: {flexDirection: 'row'},
  sectionUsers: {
    borderWidth: 1,
    borderColor: '#c4c4c4',
    borderRadius: 5,
    backgroundColor: '#fff',
    shadowColor: '#373d4380',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 5,
    paddingBottom: 15,
  },
  usersHeader: {
    borderBottomWidth: 1,
    borderColor: '#c4c4c4',
    paddingVertical: 5,
    paddingHorizontal: 10,
  },
  avatarWrapper: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    marginHorizontal: 10,
    marginTop: 5,
  },
  subWrapper: {
    height: 65,
    borderWidth: 1,
    borderColor: '#c4c4c4',
    borderRadius: 5,
    backgroundColor: '#fff',
    shadowColor: '#373d4380',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 2,
    elevation: 5,
  },
  subIcon: {
    flex: 1,
    justifyContent: 'flex-end',
    alignItems: 'center',
    alignContent: 'center',
  },
  subTextWrap: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    alignContent: 'center',
  },
});

export const CMStyles = StyleSheet.create({
  shContainer: {height: 35, borderWidth: 0},
  shLine: {
    borderBottomWidth: 1,
    position: 'relative',
    top: 16,
    marginLeft: 15,
    marginRight: 50,
    zIndex: 1,
  },
  shTWrap: {alignItems: 'flex-end', marginRight: 1},
  shTO: {
    height: 30,
    width: 50,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
  shTitleWrap: {
    zIndex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    top: -7,
  },
  shTitle: {
    backgroundColor: '#fff',
    paddingHorizontal: 15,
    paddingVertical: 2,
  },
  sectionExpanded: {paddingHorizontal: 25, paddingVertical: 5, marginTop: -10},
  sectionCollapsed: {
    paddingHorizontal: 25,
    paddingTop: 3,
    paddingBottom: 10,
    alignItems: 'center',
    marginTop: -10,
  },
  sectionTO: {
    flexDirection: 'row',
    paddingVertical: 5,
    alignItems: 'center',
  },
  sectionIcon: {marginRight: 20},
});


--- FILE: src/utilities/categories.js ---

//* categories.js

export const displayCategories = [
  {index: 0, key: 'na', label: 'No Category', bg: '#319177'},
  {index: 1, key: 'meats-seafood', label: 'Meat & Seafood', bg: '#8B0000'},
  {index: 2, key: 'dairy', label: 'Dairy & Eggs', bg: '#FFB300'},
  {index: 3, key: 'produce', label: 'Produce', bg: '#2E8B57'},
  {index: 4, key: 'frozen', label: 'Frozen Goods', bg: '#4682B4'},
  {index: 5, key: 'baked', label: 'Baked Goods', bg: '#C5A27D'},
  {index: 6, key: 'dry-pasta', label: 'Dry Goods & Pasta', bg: '#C5A27D'},
  {index: 7, key: 'condiments', label: 'Condiments & Sauces', bg: '#A0522D'},
  {index: 8, key: 'canned', label: 'Canned Goods', bg: '#708090'},
  {index: 9, key: 'spices', label: 'Oils, Vinegars & Spices', bg: '#DAA520'},
  {index: 10, key: 'baking', label: 'Baking Ingredients', bg: '#C5A27D'},
  {index: 11, key: 'cereals', label: 'Breakfast & Cereal', bg: '#CD853F'},
  {index: 12, key: 'snacks', label: 'Snacks & Candy', bg: '#FF6347'},
  {index: 13, key: 'beverages', label: 'Beverages', bg: '#4682B4'},
  {index: 14, key: 'other', label: 'Other', bg: '#319177'},
  {index: 99, key: 'custom', label: 'Custom (Enter Your Own)', bg: '#319177'},
];

export const formatCategories = category => {
  if (!category) return '';

  // Replace dashes with spaces
  const cleaned = category.replace(/-/g, ' ');

  // Capitalize each word
  return cleaned
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};

export const categoryColors = category => {
  const found = displayCategories.find(cat => cat.key === category);

  if (category === undefined || category === null) {
    return '#319177';
  } else if (found) {
    return found.bg;
  } else {
    return '#319177';
  }
};


--- FILE: src/utilities/coreInfo.js ---

//* coreInfo.js
import {
  useUser,
  useAccount,
  useCupboard,
  useProfile,
  useShoppingCart,
} from '../hooks/useHooks';

export const useCoreInfo = () => {
  const user = useUser();
  const profile = useProfile();
  const account = useAccount();
  const shopping = useShoppingCart();
  const cupboard = useCupboard();

  return {
    // User
    userID: user?.uid,
    userEmail: user?.email,

    // Profile
    profileID: profile?.id,
    firstName: profile?.firstName,
    lastName: profile?.lastName,
    onlineName: profile?.onlineName,
    role: profile?.role,
    isActive: profile?.isActive,
    pictureApproved: profile?.pictureApproved,
    pictureUrl: profile?.pictureUrl,
    profileLastUpdated: profile?.lastUpdated,
    ppVersion: profile?.ppVersion,
    tosVersion: profile?.tosVersion,
    userSettings: profile?.userSettings,

    // Account
    accountID: account?.id,
    allowedUsers: account?.allowedUsers,
    shoppingCartID: account?.shoppingCartID,
    cupboardID: account?.cupboardID,
    accountCreatedOn: account?.createdOn,
    accountLastUpdated: account?.lastUpdated,
    accountLastUpdatedBy: account?.lastUpdatedBy,
    accountOwner: account?.owner,
    subType: account?.subType,

    // Shopping Cart Metadata
    shoppingCreatedOn: shopping?.createdOn,
    shoppingLastUpdated: shopping?.lastUpdated,
    shoppingLastUpdatedBy: shopping?.lastUpdatedBy,

    // Cupboard Metadata
    cupboardCreatedOn: cupboard?.createdOn,
    cupboardLastUpdated: cupboard?.lastUpdated,
    cupboardLastUpdatedBy: cupboard?.lastUpdatedBy,
  };
};


--- FILE: src/utilities/deviceUtils.js ---

// deviceUtils.js
export const hbDevices = [
  'iPhone SE',
  'iPad Air 3rd Gen (WiFi)',
  'iPad Air 3rd Gen (Cellular)',
  // Add other home-button models here as needed
];

export const isHBDevice = model => hbDevices.includes(model);

export const isAndroidPhone = device =>
  device?.system?.os === 'Android' && device?.system?.device === 'Handset';

export const isAndroidTablet = device =>
  device?.system?.os === 'Android' && device?.system?.device === 'Tablet';

export const isiOSPhone = device =>
  device?.system?.os === 'iOS' && device?.system?.device === 'Handset';

export const isiOSTablet = device =>
  device?.system?.os === 'iOS' && device?.system?.device === 'Tablet';

export const getNavMenuHeight = device => {
  const {deviceSize, model, os} = device?.system || {};
  const isHomeButton = isHBDevice(model);

  let baseHeight = 90; // Fallback for unknown devices (just to be safe)

  switch (deviceSize) {
    case 'xLarge':
      baseHeight = 100;
      break;
    case 'large':
      baseHeight = 100;
      break;
    case 'medium':
      baseHeight = 100;
      break;
    case 'small':
      baseHeight = 100;
      break;
    case 'xSmall':
      baseHeight = 100;
      break;
    default:
      baseHeight = 90; // Unknown devices default to xSmall
      break;
  }

  // Special adjustment for iOS devices
  if (os === 'iOS') {
    baseHeight -= 5;
  }

  // Special adjustment for home button devices
  if (isHomeButton) {
    baseHeight -= 30;
  }

  return baseHeight;
};

export const getNavBarHeight = (device, baseHeight) => {
  if (isHBDevice(device?.system?.model)) {
    return baseHeight;
  } else {
    return baseHeight - 20;
  }
};


--- FILE: src/utilities/helpers.js ---

//*helpers.js
export function displayCustom(value, mapData = []) {
  if (!value || typeof value !== 'string') return null;

  const found = mapData.find(item => item.key === value.toLowerCase());
  if (found) return found;

  const cleaned = value.trim().toLowerCase().replace(/\s+/g, '-');
  const label = cleaned
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');

  return {
    index: -1,
    key: cleaned,
    label: label,
  };
}

export const setNumericValue = setter => value => {
  if (value === '' || /^[0-9]*$/.test(value)) {
    setter(value); //
  }
};

export const titleCase = str => {
  if (!str) return ''; // Handle null or undefined inputs gracefully

  return str
    .toLowerCase() // Convert the entire string to lowercase first
    .split(' ') // Split the string into words
    .map(word => {
      // Capitalize the first letter and preserve the rest
      return word.charAt(0).toUpperCase() + word.slice(1);
    })
    .join(' '); // Rejoin the words into a single string
};

export const capFirst = str => {
  if (!str) return ''; // Handle null or undefined inputs gracefully

  const lowerCaseStr = str.toLowerCase(); // Convert entire string to lowercase
  return lowerCaseStr.charAt(0).toUpperCase() + lowerCaseStr.slice(1);
};


--- FILE: src/utilities/measurements.js ---

//* measurements.js

export const displayMeasurements = [
  {index: 0, key: 'each', label: 'Single (Each)'},
  {index: 1, key: 'slice', label: 'Slice'},
  {index: 2, key: 'bag', label: 'Bag'},
  {index: 3, key: 'roll', label: 'Roll'},
  {index: 4, key: 'tube', label: 'Tube'},
  {index: 5, key: 'package', label: 'Package'},
  {index: 6, key: 'box', label: 'Box'},
  {index: 7, key: 'fluidounce', label: 'Fluid Ounce'},
  {index: 8, key: 'milliliter', label: 'Milliliter'},
  {index: 9, key: 'liter', label: 'Liter'},
  {index: 10, key: 'pint', label: 'Pint'},
  {index: 11, key: 'quart', label: 'Quart'},
  {index: 12, key: 'gallon', label: 'Gallon'},
  {index: 13, key: 'ounce', label: 'Ounce'},
  {index: 14, key: 'pound', label: 'Pound'},
  {index: 15, key: 'gram', label: 'Gram'},
  {index: 16, key: 'kilogram', label: 'Kilogram'},
  {index: 17, key: 'can', label: 'Can'},
  {index: 18, key: 'cup', label: 'Cup'},
  {index: 19, key: 'tablespoon', label: 'Tablespoon'},
  {index: 20, key: 'teaspoon', label: 'Teaspoon'},
  {index: 99, key: 'custom', label: 'Custom (Enter Your Own)'},
];

export const formatMeasurement = measurement => {
  if (!measurement) return '';

  // Replace dashes with spaces
  const cleaned = measurement.replace(/-/g, ' ');

  // Capitalize each word
  return cleaned
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};


--- FILE: src/utilities/nutrients.js ---

//* nutrients.js

export const displayNutrients = [
  {index: 0, key: 'CA', label: 'Calcium', unit: 'mg'},
  {index: 1, key: 'CHOCDF', label: 'Total Carbohydrates', unit: 'g'},
  {index: 2, key: 'CHOCDF.net', label: 'Net Carbohydrates', unit: 'g'},
  {index: 3, key: 'CHOLE', label: 'Cholesterol', unit: 'mg'},
  {index: 4, key: 'ENERC_KCAL', label: 'Calories', unit: 'kcal'},
  {index: 5, key: 'FAMS', label: 'Monounsaturated Fat', unit: 'g'},
  {index: 6, key: 'FAPU', label: 'Polyunsaturated Fat', unit: 'g'},
  {index: 7, key: 'FASAT', label: 'Saturated Fat', unit: 'g'},
  {index: 8, key: 'FATRN', label: 'Trans Fat', unit: 'g'},
  {index: 9, key: 'FAT', label: 'Total Fat', unit: 'g'},
  {index: 10, key: 'FE', label: 'Iron', unit: 'mg'},
  {index: 11, key: 'FIBTG', label: 'Dietary Fiber', unit: 'g'},
  {index: 12, key: 'FOLAC', label: 'Folic Acid', unit: 'Âµg'},
  {index: 13, key: 'FOLDFE', label: 'Folate (DFE)', unit: 'Âµg'},
  {index: 14, key: 'FOLFD', label: 'Folate (Food)', unit: 'Âµg'},
  {index: 15, key: 'K', label: 'Potassium', unit: 'mg'},
  {index: 16, key: 'MG', label: 'Magnesium', unit: 'mg'},
  {index: 17, key: 'NA', label: 'Sodium', unit: 'mg'},
  {index: 18, key: 'NIA', label: 'Niacin', unit: 'mg'},
  {index: 19, key: 'P', label: 'Phosphorus', unit: 'mg'},
  {index: 20, key: 'PROCNT', label: 'Protein', unit: 'g'},
  {index: 21, key: 'RIBF', label: 'Riboflavin', unit: 'mg'},
  {index: 22, key: 'SUGAR', label: 'Total Sugars', unit: 'g'},
  {index: 23, key: 'SUGAR.added', label: 'Added Sugars', unit: 'g'},
  {index: 24, key: 'Sugar.alcohol', label: 'Sugar Alcohols', unit: 'g'},
  {index: 25, key: 'THIA', label: 'Thiamin', unit: 'mg'},
  {index: 26, key: 'TOCPHA', label: 'Vitamin E', unit: 'mg'},
  {index: 27, key: 'VITA_RAE', label: 'Vitamin A', unit: 'Âµg'},
  {index: 28, key: 'VITB12', label: 'Vitamin B12', unit: 'Âµg'},
  {index: 29, key: 'VITB6A', label: 'Vitamin B6', unit: 'mg'},
  {index: 30, key: 'VITC', label: 'Vitamin C', unit: 'mg'},
  {index: 31, key: 'VITD', label: 'Vitamin D', unit: 'Âµg'},
  {index: 32, key: 'VITK1', label: 'Vitamin K', unit: 'Âµg'},
  {index: 33, key: 'WATER', label: 'Water', unit: 'g'},
  {index: 34, key: 'ZN', label: 'Zinc', unit: 'mg'},
];

export const formatNutrient = nutrient => {
  const found = displayNutrients.find(n => n.key === nutrient);
  if (found) {
    return {label: found.label, unit: found.unit};
  }
  return {label: nutrient, unit: ''}; // Default if not found
};


--- FILE: src/utilities/realtime/RealTimeAccounts.jsx ---

//* RealTimeAccounts.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount, useProfile} from '../../hooks/useHooks';

const useRealTimeAccounts = () => {
  const dispatch = useDispatch();
  const profile = useProfile();
  const db = getFirestore();

  useEffect(() => {
    if (!profile?.account) {
      return;
    }

    console.log(`ðŸ”„ Fetching Account data from Firestore`);
    const accountRef = doc(db, 'accounts', profile.account);

    const unsubscribe = onSnapshot(
      accountRef,
      snapshot => {
        if (snapshot.exists) {
          const accountData = snapshot.data();
          const account = {
            ...accountData,
            lastUpdated: accountData?.lastUpdated || null, // âœ… No more toDate()
            createdOn: accountData?.createdOn || null, // âœ… No more toDate()
          };
          dispatch({type: 'SET_ACCOUNT', payload: account});
        } else {
          dispatch({type: 'SET_ACCOUNT', payload: null});
        }
      },
      error => {
        dispatch({type: 'ACCOUNT_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, profile?.account, db]); // âœ… Removed `storedAccount`
};

export default useRealTimeAccounts;


--- FILE: src/utilities/realtime/RealTimeAllowedProfiles.jsx ---

//* RealTimeAllowedProfiles.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {
  getFirestore,
  collection,
  query,
  where,
  onSnapshot,
} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeAllowedProfiles = () => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();

  useEffect(() => {
    if (!account?.allowedUsers?.length) {
      return;
    }

    console.log(`ðŸ”„ Fetching Allowed Profiles data from Firestore`);

    const profilesQuery = query(
      collection(db, 'profiles'),
      where('id', 'in', account.allowedUsers),
    );

    const unsubscribe = onSnapshot(
      profilesQuery,
      querySnapshot => {
        if (!querySnapshot.empty) {
          const profiles = querySnapshot.docs
            .map(doc => doc.data())
            .filter(profile => profile?.isActive)
            .sort((a, b) => (a.role === 'owner' ? -1 : 1));

          dispatch({type: 'SET_ALLOWED_PROFILES', payload: profiles});
        } else {
          dispatch({type: 'SET_ALLOWED_PROFILES', payload: []});
        }
      },
      error => {
        dispatch({
          type: 'ALLOWED_PROFILES_FETCH_FAILED',
          payload: error.message,
        });
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, account?.allowedUsers, db]); // âœ… Removed `persistedProfiles`
};

export default useRealTimeAllowedProfiles;


--- FILE: src/utilities/realtime/RealTimeCupboard.jsx ---

//* RealTimeCupboard.jsx
import {useEffect, useRef} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeCupboard = () => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();
  const prevCupboardRef = useRef(null);

  useEffect(() => {
    if (!account?.cupboardID) return;

    const cupboardRef = doc(db, 'cupboards', account.cupboardID);
    console.log('ðŸ” RealTimeCupboard listener mounted');

    const unsubscribe = onSnapshot(
      cupboardRef,
      snapshot => {
        if (!snapshot.exists) return;

        const cupboardData = snapshot.data();
        const nextCupboard = {
          ...cupboardData,
          items: Array.isArray(cupboardData.items) ? cupboardData.items : [],
          lastUpdated: cupboardData?.lastUpdated || null,
        };

        const prev = prevCupboardRef.current;
        const hasChanged =
          JSON.stringify(prev) !== JSON.stringify(nextCupboard);

        if (hasChanged) {
          console.log('ðŸŸ¢ RealTimeCupboard updated');
          prevCupboardRef.current = nextCupboard;
          dispatch({type: 'SET_CUPBOARD', payload: nextCupboard});
        } else {
          console.log('âšª No cupboard change detected');
        }
      },
      error => {
        console.error('âŒ RealTimeCupboard error:', error);
        dispatch({type: 'CUPBOARD_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      console.log('ðŸ›‘ RealTimeCupboard listener removed');
      unsubscribe();
    };
  }, [dispatch, account?.cupboardID, db]);
};

export default useRealTimeCupboard;


--- FILE: src/utilities/realtime/RealTimeProfiles.jsx ---

import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useUser} from '../../hooks/useHooks';

const useRealTimeProfiles = () => {
  const dispatch = useDispatch();
  const user = useUser();
  const db = getFirestore();

  useEffect(() => {
    if (!user?.uid) {
      return;
    }

    console.log(`ðŸ”„ Fetching Profile data from Firestore`);
    const profileRef = doc(db, 'profiles', user.uid);

    const unsubscribe = onSnapshot(
      profileRef,
      snapshot => {
        if (snapshot.exists) {
          const profileData = snapshot.data();
          const profilePayload = {
            ...profileData,
            lastUpdated: profileData?.lastUpdated || null, // âœ… No more toDate()
          };
          dispatch({type: 'SET_PROFILE', payload: profilePayload});
        } else {
          dispatch({type: 'SET_PROFILE', payload: null});
        }
      },
      error => {
        dispatch({type: 'PROFILE_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      unsubscribe();
    };
  }, [dispatch, user?.uid, db]); // âœ… Removed `storedProfile`
};

export default useRealTimeProfiles;


--- FILE: src/utilities/realtime/RealTimeShoppingCart.jsx ---

//* RealTimeShoppingCart.jsx
import {useEffect, useRef} from 'react';
import {useDispatch} from 'react-redux';
import {getFirestore, doc, onSnapshot} from '@react-native-firebase/firestore';
import {useAccount} from '../../hooks/useHooks';

const useRealTimeShoppingCart = () => {
  const dispatch = useDispatch();
  const account = useAccount();
  const db = getFirestore();
  const prevCartRef = useRef(null);

  useEffect(() => {
    if (!account?.shoppingCartID) return;

    const cartRef = doc(db, 'shoppingCarts', account.shoppingCartID);
    console.log('ðŸ” RealTimeShoppingCart listener mounted');

    const unsubscribe = onSnapshot(
      cartRef,
      snapshot => {
        if (!snapshot.exists) return;

        const shopCartData = snapshot.data();
        const nextCart = {
          ...shopCartData,
          items: Array.isArray(shopCartData.items) ? shopCartData.items : [],
          lastUpdated: shopCartData?.lastUpdated || null,
        };

        const prevCart = prevCartRef.current;
        const hasChanged =
          JSON.stringify(prevCart) !== JSON.stringify(nextCart);

        if (hasChanged) {
          console.log('ðŸŸ¢ RealTimeShoppingCart updated');
          prevCartRef.current = nextCart;
          dispatch({type: 'SET_SHOP_CART', payload: nextCart});
        } else {
          console.log('âšª No cart change detected');
        }
      },
      error => {
        console.error('âŒ RealTimeShoppingCart error:', error);
        dispatch({type: 'SHOP_CART_FETCH_FAILED', payload: error.message});
      },
    );

    return () => {
      console.log('ðŸ›‘ RealTimeShoppingCart listener removed');
      unsubscribe();
    };
  }, [dispatch, account?.shoppingCartID, db]);
};

export default useRealTimeShoppingCart;


--- FILE: src/utilities/realtime/RealTimeUsers.jsx ---

//* RealTimeUsers.jsx
import {useEffect} from 'react';
import {useDispatch} from 'react-redux';
import {getAuth, onAuthStateChanged} from '@react-native-firebase/auth';

const auth = getAuth();

const useRealTimeUsers = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    console.log(`ðŸ”„ Fetching User data from Firebase Auth`);

    const unsubscribe = onAuthStateChanged(auth, currentUser => {
      if (currentUser) {
        dispatch({type: 'SET_USER', payload: currentUser});
      } else {
        dispatch({type: 'UNSET_USER'});
      }
    });

    return () => {
      unsubscribe();
    };
  }, [dispatch]);
};

export default useRealTimeUsers;


--- FILE: src/utilities/realtime/index.js ---

//* index.js (RealTime Listeners)
export {default as RTAccounts} from './RealTimeAccounts';
export {default as RTProfiles} from './RealTimeProfiles';
export {default as RTShopping} from './RealTimeShoppingCart';
export {default as RTCupboards} from './RealTimeCupboard';
export {default as RTUsers} from './RealTimeUsers';
export {default as RTAllowedProfiles} from './RealTimeAllowedProfiles';


--- FILE: store.js ---

//*store.js
import {createStore, applyMiddleware} from 'redux';
import createSagaMiddleware from 'redux-saga';
import {persistStore, persistReducer} from 'redux-persist';
import AsyncStorage from '@react-native-async-storage/async-storage';
import rootReducer from './src/redux/reducers/_root.reducer';
import rootSaga from './src/redux/sagas/_root.saga';

const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['user', 'profile', 'account', 'shopping', 'cupboard'],
};

const persistedReducer = persistReducer(persistConfig, rootReducer);
const sagaMiddleware = createSagaMiddleware();
const store = createStore(persistedReducer, applyMiddleware(sagaMiddleware));
const persistor = persistStore(store);

sagaMiddleware.run(rootSaga);

export {store, persistor};
